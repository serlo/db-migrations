"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/fp-ts/lib/Alt.js
var require_Alt = __commonJS({
  "node_modules/fp-ts/lib/Alt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.altAll = void 0;
    function altAll(F) {
      return function(startWith) {
        return function(as) {
          return as.reduce(function(acc, a) {
            return F.alt(acc, function() {
              return a;
            });
          }, startWith);
        };
      };
    }
    exports.altAll = altAll;
  }
});

// node_modules/fp-ts/lib/function.js
var require_function = __commonJS({
  "node_modules/fp-ts/lib/function.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dual = exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    var getBooleanAlgebra = function(B) {
      return function() {
        return {
          meet: function(x, y) {
            return function(a) {
              return B.meet(x(a), y(a));
            };
          },
          join: function(x, y) {
            return function(a) {
              return B.join(x(a), y(a));
            };
          },
          zero: function() {
            return B.zero;
          },
          one: function() {
            return B.one;
          },
          implies: function(x, y) {
            return function(a) {
              return B.implies(x(a), y(a));
            };
          },
          not: function(x) {
            return function(a) {
              return B.not(x(a));
            };
          }
        };
      };
    };
    exports.getBooleanAlgebra = getBooleanAlgebra;
    var getSemigroup = function(S) {
      return function() {
        return {
          concat: function(f2, g) {
            return function(a) {
              return S.concat(f2(a), g(a));
            };
          }
        };
      };
    };
    exports.getSemigroup = getSemigroup;
    var getMonoid = function(M) {
      var getSemigroupM = (0, exports.getSemigroup)(M);
      return function() {
        return {
          concat: getSemigroupM().concat,
          empty: function() {
            return M.empty;
          }
        };
      };
    };
    exports.getMonoid = getMonoid;
    var getSemiring = function(S) {
      return {
        add: function(f2, g) {
          return function(x) {
            return S.add(f2(x), g(x));
          };
        },
        zero: function() {
          return S.zero;
        },
        mul: function(f2, g) {
          return function(x) {
            return S.mul(f2(x), g(x));
          };
        },
        one: function() {
          return S.one;
        }
      };
    };
    exports.getSemiring = getSemiring;
    var getRing = function(R) {
      var S = (0, exports.getSemiring)(R);
      return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function(f2, g) {
          return function(x) {
            return R.sub(f2(x), g(x));
          };
        }
      };
    };
    exports.getRing = getRing;
    var apply = function(a) {
      return function(f2) {
        return f2(a);
      };
    };
    exports.apply = apply;
    function identity(a) {
      return a;
    }
    exports.identity = identity;
    exports.unsafeCoerce = identity;
    function constant(a) {
      return function() {
        return a;
      };
    }
    exports.constant = constant;
    exports.constTrue = constant(true);
    exports.constFalse = constant(false);
    exports.constNull = constant(null);
    exports.constUndefined = constant(void 0);
    exports.constVoid = exports.constUndefined;
    function flip(f2) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length > 1) {
          return f2(args[1], args[0]);
        }
        return function(a) {
          return f2(a)(args[0]);
        };
      };
    }
    exports.flip = flip;
    function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
      switch (arguments.length) {
        case 1:
          return ab;
        case 2:
          return function() {
            return bc(ab.apply(this, arguments));
          };
        case 3:
          return function() {
            return cd(bc(ab.apply(this, arguments)));
          };
        case 4:
          return function() {
            return de(cd(bc(ab.apply(this, arguments))));
          };
        case 5:
          return function() {
            return ef(de(cd(bc(ab.apply(this, arguments)))));
          };
        case 6:
          return function() {
            return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
          };
        case 7:
          return function() {
            return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
          };
        case 8:
          return function() {
            return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
          };
        case 9:
          return function() {
            return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
          };
      }
      return;
    }
    exports.flow = flow;
    function tuple() {
      var t3 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        t3[_i] = arguments[_i];
      }
      return t3;
    }
    exports.tuple = tuple;
    function increment(n) {
      return n + 1;
    }
    exports.increment = increment;
    function decrement(n) {
      return n - 1;
    }
    exports.decrement = decrement;
    function absurd(_) {
      throw new Error("Called `absurd` function which should be uncallable");
    }
    exports.absurd = absurd;
    function tupled(f2) {
      return function(a) {
        return f2.apply(void 0, a);
      };
    }
    exports.tupled = tupled;
    function untupled(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return f2(a);
      };
    }
    exports.untupled = untupled;
    function pipe2(a, ab, bc, cd, de, ef, fg, gh, hi) {
      switch (arguments.length) {
        case 1:
          return a;
        case 2:
          return ab(a);
        case 3:
          return bc(ab(a));
        case 4:
          return cd(bc(ab(a)));
        case 5:
          return de(cd(bc(ab(a))));
        case 6:
          return ef(de(cd(bc(ab(a)))));
        case 7:
          return fg(ef(de(cd(bc(ab(a))))));
        case 8:
          return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
          return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
          var ret = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            ret = arguments[i](ret);
          }
          return ret;
        }
      }
    }
    exports.pipe = pipe2;
    exports.hole = absurd;
    var SK = function(_, b) {
      return b;
    };
    exports.SK = SK;
    function not(predicate) {
      return function(a) {
        return !predicate(a);
      };
    }
    exports.not = not;
    var getEndomorphismMonoid = function() {
      return {
        concat: function(first, second) {
          return flow(first, second);
        },
        empty: identity
      };
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
    var dual = function(arity, body) {
      var isDataFirst = typeof arity === "number" ? function(args) {
        return args.length >= arity;
      } : arity;
      return function() {
        var args = Array.from(arguments);
        if (isDataFirst(arguments)) {
          return body.apply(this, args);
        }
        return function(self) {
          return body.apply(void 0, __spreadArray([self], args, false));
        };
      };
    };
    exports.dual = dual;
  }
});

// node_modules/fp-ts/lib/internal.js
var require_internal = __commonJS({
  "node_modules/fp-ts/lib/internal.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
    var function_1 = require_function();
    var isNone = function(fa) {
      return fa._tag === "None";
    };
    exports.isNone = isNone;
    var isSome = function(fa) {
      return fa._tag === "Some";
    };
    exports.isSome = isSome;
    exports.none = { _tag: "None" };
    var some = function(a) {
      return { _tag: "Some", value: a };
    };
    exports.some = some;
    var isLeft = function(ma) {
      return ma._tag === "Left";
    };
    exports.isLeft = isLeft;
    var isRight = function(ma) {
      return ma._tag === "Right";
    };
    exports.isRight = isRight;
    var left = function(e) {
      return { _tag: "Left", left: e };
    };
    exports.left = left;
    var right = function(a) {
      return { _tag: "Right", right: a };
    };
    exports.right = right;
    var singleton = function(a) {
      return [a];
    };
    exports.singleton = singleton;
    var isNonEmpty = function(as) {
      return as.length > 0;
    };
    exports.isNonEmpty = isNonEmpty;
    var head = function(as) {
      return as[0];
    };
    exports.head = head;
    var tail = function(as) {
      return as.slice(1);
    };
    exports.tail = tail;
    exports.emptyReadonlyArray = [];
    exports.emptyRecord = {};
    exports.has = Object.prototype.hasOwnProperty;
    var fromReadonlyNonEmptyArray = function(as) {
      return __spreadArray([as[0]], as.slice(1), true);
    };
    exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
    var liftNullable = function(F) {
      return function(f2, onNullable) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          var o = f2.apply(void 0, a);
          return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a)) : (0, exports.right)(o));
        };
      };
    };
    exports.liftNullable = liftNullable;
    var liftOption = function(F) {
      return function(f2, onNone) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          var o = f2.apply(void 0, a);
          return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a)) : (0, exports.right)(o.value));
        };
      };
    };
    exports.liftOption = liftOption;
    var flatMapNullable = function(F, M) {
      return (0, function_1.dual)(3, function(self, f2, onNullable) {
        return M.flatMap(self, (0, exports.liftNullable)(F)(f2, onNullable));
      });
    };
    exports.flatMapNullable = flatMapNullable;
    var flatMapOption = function(F, M) {
      return (0, function_1.dual)(3, function(self, f2, onNone) {
        return M.flatMap(self, (0, exports.liftOption)(F)(f2, onNone));
      });
    };
    exports.flatMapOption = flatMapOption;
    var flatMapEither = function(F, M) {
      return (0, function_1.dual)(2, function(self, f2) {
        return M.flatMap(self, function(a) {
          return F.fromEither(f2(a));
        });
      });
    };
    exports.flatMapEither = flatMapEither;
    var flatMapIO = function(F, M) {
      return (0, function_1.dual)(2, function(self, f2) {
        return M.flatMap(self, function(a) {
          return F.fromIO(f2(a));
        });
      });
    };
    exports.flatMapIO = flatMapIO;
    var flatMapTask = function(F, M) {
      return (0, function_1.dual)(2, function(self, f2) {
        return M.flatMap(self, function(a) {
          return F.fromTask(f2(a));
        });
      });
    };
    exports.flatMapTask = flatMapTask;
    var flatMapReader = function(F, M) {
      return (0, function_1.dual)(2, function(self, f2) {
        return M.flatMap(self, function(a) {
          return F.fromReader(f2(a));
        });
      });
    };
    exports.flatMapReader = flatMapReader;
  }
});

// node_modules/fp-ts/lib/Apply.js
var require_Apply = __commonJS({
  "node_modules/fp-ts/lib/Apply.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function ap(F, G) {
      return function(fa) {
        return function(fab) {
          return F.ap(F.map(fab, function(gab) {
            return function(ga) {
              return G.ap(gab, ga);
            };
          }), fa);
        };
      };
    }
    exports.ap = ap;
    function apFirst(A) {
      return function(second) {
        return function(first) {
          return A.ap(A.map(first, function(a) {
            return function() {
              return a;
            };
          }), second);
        };
      };
    }
    exports.apFirst = apFirst;
    function apSecond(A) {
      return function(second) {
        return function(first) {
          return A.ap(A.map(first, function() {
            return function(b) {
              return b;
            };
          }), second);
        };
      };
    }
    exports.apSecond = apSecond;
    function apS(F) {
      return function(name, fb) {
        return function(fa) {
          return F.ap(F.map(fa, function(a) {
            return function(b) {
              var _a2;
              return Object.assign({}, a, (_a2 = {}, _a2[name] = b, _a2));
            };
          }), fb);
        };
      };
    }
    exports.apS = apS;
    function getApplySemigroup(F) {
      return function(S) {
        return {
          concat: function(first, second) {
            return F.ap(F.map(first, function(x) {
              return function(y) {
                return S.concat(x, y);
              };
            }), second);
          }
        };
      };
    }
    exports.getApplySemigroup = getApplySemigroup;
    function curried(f2, n, acc) {
      return function(x) {
        var combined = Array(acc.length + 1);
        for (var i = 0; i < acc.length; i++) {
          combined[i] = acc[i];
        }
        combined[acc.length] = x;
        return n === 0 ? f2.apply(null, combined) : curried(f2, n - 1, combined);
      };
    }
    var tupleConstructors = {
      1: function(a) {
        return [a];
      },
      2: function(a) {
        return function(b) {
          return [a, b];
        };
      },
      3: function(a) {
        return function(b) {
          return function(c) {
            return [a, b, c];
          };
        };
      },
      4: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return [a, b, c, d];
            };
          };
        };
      },
      5: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return function(e) {
                return [a, b, c, d, e];
              };
            };
          };
        };
      }
    };
    function getTupleConstructor(len) {
      if (!_.has.call(tupleConstructors, len)) {
        tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
      }
      return tupleConstructors[len];
    }
    function sequenceT(F) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var len = args.length;
        var f2 = getTupleConstructor(len);
        var fas = F.map(args[0], f2);
        for (var i = 1; i < len; i++) {
          fas = F.ap(fas, args[i]);
        }
        return fas;
      };
    }
    exports.sequenceT = sequenceT;
    function getRecordConstructor(keys4) {
      var len = keys4.length;
      switch (len) {
        case 1:
          return function(a) {
            var _a2;
            return _a2 = {}, _a2[keys4[0]] = a, _a2;
          };
        case 2:
          return function(a) {
            return function(b) {
              var _a2;
              return _a2 = {}, _a2[keys4[0]] = a, _a2[keys4[1]] = b, _a2;
            };
          };
        case 3:
          return function(a) {
            return function(b) {
              return function(c) {
                var _a2;
                return _a2 = {}, _a2[keys4[0]] = a, _a2[keys4[1]] = b, _a2[keys4[2]] = c, _a2;
              };
            };
          };
        case 4:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  var _a2;
                  return _a2 = {}, _a2[keys4[0]] = a, _a2[keys4[1]] = b, _a2[keys4[2]] = c, _a2[keys4[3]] = d, _a2;
                };
              };
            };
          };
        case 5:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  return function(e) {
                    var _a2;
                    return _a2 = {}, _a2[keys4[0]] = a, _a2[keys4[1]] = b, _a2[keys4[2]] = c, _a2[keys4[3]] = d, _a2[keys4[4]] = e, _a2;
                  };
                };
              };
            };
          };
        default:
          return curried(function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var r = {};
            for (var i = 0; i < len; i++) {
              r[keys4[i]] = args[i];
            }
            return r;
          }, len - 1, []);
      }
    }
    function sequenceS(F) {
      return function(r) {
        var keys4 = Object.keys(r);
        var len = keys4.length;
        var f2 = getRecordConstructor(keys4);
        var fr = F.map(r[keys4[0]], f2);
        for (var i = 1; i < len; i++) {
          fr = F.ap(fr, r[keys4[i]]);
        }
        return fr;
      };
    }
    exports.sequenceS = sequenceS;
  }
});

// node_modules/fp-ts/lib/Alternative.js
var require_Alternative = __commonJS({
  "node_modules/fp-ts/lib/Alternative.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAlternativeMonoid = exports.altAll = void 0;
    var Alt_1 = require_Alt();
    var Apply_1 = require_Apply();
    function altAll(F) {
      return (0, Alt_1.altAll)(F)(F.zero());
    }
    exports.altAll = altAll;
    function getAlternativeMonoid(F) {
      var f2 = (0, Apply_1.getApplySemigroup)(F);
      return function(S) {
        var SF = f2(S);
        return {
          concat: function(first, second) {
            return F.alt(SF.concat(first, second), function() {
              return F.alt(first, function() {
                return second;
              });
            });
          },
          empty: F.zero()
        };
      };
    }
    exports.getAlternativeMonoid = getAlternativeMonoid;
  }
});

// node_modules/fp-ts/lib/Functor.js
var require_Functor = __commonJS({
  "node_modules/fp-ts/lib/Functor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asUnit = exports.as = exports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;
    var function_1 = require_function();
    function map(F, G) {
      return function(f2) {
        return function(fa) {
          return F.map(fa, function(ga) {
            return G.map(ga, f2);
          });
        };
      };
    }
    exports.map = map;
    function flap(F) {
      return function(a) {
        return function(fab) {
          return F.map(fab, function(f2) {
            return f2(a);
          });
        };
      };
    }
    exports.flap = flap;
    function bindTo(F) {
      return function(name) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a2;
            return _a2 = {}, _a2[name] = a, _a2;
          });
        };
      };
    }
    exports.bindTo = bindTo;
    function let_(F) {
      return function(name, f2) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a2;
            return Object.assign({}, a, (_a2 = {}, _a2[name] = f2(a), _a2));
          });
        };
      };
    }
    exports.let = let_;
    function getFunctorComposition(F, G) {
      var _map2 = map(F, G);
      return {
        map: function(fga, f2) {
          return (0, function_1.pipe)(fga, _map2(f2));
        }
      };
    }
    exports.getFunctorComposition = getFunctorComposition;
    function as(F) {
      return function(self, b) {
        return F.map(self, function() {
          return b;
        });
      };
    }
    exports.as = as;
    function asUnit(F) {
      var asM = as(F);
      return function(self) {
        return asM(self, void 0);
      };
    }
    exports.asUnit = asUnit;
  }
});

// node_modules/fp-ts/lib/Applicative.js
var require_Applicative = __commonJS({
  "node_modules/fp-ts/lib/Applicative.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;
    var Apply_1 = require_Apply();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function getApplicativeMonoid(F) {
      var f2 = (0, Apply_1.getApplySemigroup)(F);
      return function(M) {
        return {
          concat: f2(M).concat,
          empty: F.of(M.empty)
        };
      };
    }
    exports.getApplicativeMonoid = getApplicativeMonoid;
    function getApplicativeComposition(F, G) {
      var map = (0, Functor_1.getFunctorComposition)(F, G).map;
      var _ap = (0, Apply_1.ap)(F, G);
      return {
        map,
        of: function(a) {
          return F.of(G.of(a));
        },
        ap: function(fgab, fga) {
          return (0, function_1.pipe)(fgab, _ap(fga));
        }
      };
    }
    exports.getApplicativeComposition = getApplicativeComposition;
  }
});

// node_modules/fp-ts/lib/Chain.js
var require_Chain = __commonJS({
  "node_modules/fp-ts/lib/Chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bind = exports.tap = exports.chainFirst = void 0;
    function chainFirst(M) {
      var tapM = tap(M);
      return function(f2) {
        return function(first) {
          return tapM(first, f2);
        };
      };
    }
    exports.chainFirst = chainFirst;
    function tap(M) {
      return function(first, f2) {
        return M.chain(first, function(a) {
          return M.map(f2(a), function() {
            return a;
          });
        });
      };
    }
    exports.tap = tap;
    function bind(M) {
      return function(name, f2) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return M.map(f2(a), function(b) {
              var _a2;
              return Object.assign({}, a, (_a2 = {}, _a2[name] = b, _a2));
            });
          });
        };
      };
    }
    exports.bind = bind;
  }
});

// node_modules/fp-ts/lib/FromEither.js
var require_FromEither = __commonJS({
  "node_modules/fp-ts/lib/FromEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tapEither = exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function fromOption(F) {
      return function(onNone) {
        return function(ma) {
          return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
        };
      };
    }
    exports.fromOption = fromOption;
    function fromPredicate(F) {
      return function(predicate, onFalse) {
        return function(a) {
          return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
        };
      };
    }
    exports.fromPredicate = fromPredicate;
    function fromOptionK(F) {
      var fromOptionF = fromOption(F);
      return function(onNone) {
        var from = fromOptionF(onNone);
        return function(f2) {
          return (0, function_1.flow)(f2, from);
        };
      };
    }
    exports.fromOptionK = fromOptionK;
    function chainOptionK(F, M) {
      var fromOptionKF = fromOptionK(F);
      return function(onNone) {
        var from = fromOptionKF(onNone);
        return function(f2) {
          return function(ma) {
            return M.chain(ma, from(f2));
          };
        };
      };
    }
    exports.chainOptionK = chainOptionK;
    function fromEitherK(F) {
      return function(f2) {
        return (0, function_1.flow)(f2, F.fromEither);
      };
    }
    exports.fromEitherK = fromEitherK;
    function chainEitherK(F, M) {
      var fromEitherKF = fromEitherK(F);
      return function(f2) {
        return function(ma) {
          return M.chain(ma, fromEitherKF(f2));
        };
      };
    }
    exports.chainEitherK = chainEitherK;
    function chainFirstEitherK(F, M) {
      var tapEitherM = tapEither(F, M);
      return function(f2) {
        return function(ma) {
          return tapEitherM(ma, f2);
        };
      };
    }
    exports.chainFirstEitherK = chainFirstEitherK;
    function filterOrElse(F, M) {
      return function(predicate, onFalse) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          });
        };
      };
    }
    exports.filterOrElse = filterOrElse;
    function tapEither(F, M) {
      var fromEither = fromEitherK(F);
      var tapM = (0, Chain_1.tap)(M);
      return function(self, f2) {
        return tapM(self, fromEither(f2));
      };
    }
    exports.tapEither = tapEither;
  }
});

// node_modules/fp-ts/lib/Eq.js
var require_Eq = __commonJS({
  "node_modules/fp-ts/lib/Eq.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;
    var function_1 = require_function();
    var fromEquals = function(equals) {
      return {
        equals: function(x, y) {
          return x === y || equals(x, y);
        }
      };
    };
    exports.fromEquals = fromEquals;
    var struct = function(eqs) {
      return (0, exports.fromEquals)(function(first, second) {
        for (var key in eqs) {
          if (!eqs[key].equals(first[key], second[key])) {
            return false;
          }
        }
        return true;
      });
    };
    exports.struct = struct;
    var tuple = function() {
      var eqs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        eqs[_i] = arguments[_i];
      }
      return (0, exports.fromEquals)(function(first, second) {
        return eqs.every(function(E, i) {
          return E.equals(first[i], second[i]);
        });
      });
    };
    exports.tuple = tuple;
    var contramap_ = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.contramap)(f2));
    };
    var contramap = function(f2) {
      return function(fa) {
        return (0, exports.fromEquals)(function(x, y) {
          return fa.equals(f2(x), f2(y));
        });
      };
    };
    exports.contramap = contramap;
    exports.URI = "Eq";
    exports.eqStrict = {
      equals: function(a, b) {
        return a === b;
      }
    };
    var empty = {
      equals: function() {
        return true;
      }
    };
    var getSemigroup = function() {
      return {
        concat: function(x, y) {
          return (0, exports.fromEquals)(function(a, b) {
            return x.equals(a, b) && y.equals(a, b);
          });
        }
      };
    };
    exports.getSemigroup = getSemigroup;
    var getMonoid = function() {
      return {
        concat: (0, exports.getSemigroup)().concat,
        empty
      };
    };
    exports.getMonoid = getMonoid;
    exports.Contravariant = {
      URI: exports.URI,
      contramap: contramap_
    };
    exports.getTupleEq = exports.tuple;
    exports.getStructEq = exports.struct;
    exports.strictEqual = exports.eqStrict.equals;
    exports.eq = exports.Contravariant;
    exports.eqBoolean = exports.eqStrict;
    exports.eqString = exports.eqStrict;
    exports.eqNumber = exports.eqStrict;
    exports.eqDate = {
      equals: function(first, second) {
        return first.valueOf() === second.valueOf();
      }
    };
  }
});

// node_modules/fp-ts/lib/Ord.js
var require_Ord = __commonJS({
  "node_modules/fp-ts/lib/Ord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;
    var Eq_1 = require_Eq();
    var function_1 = require_function();
    var equalsDefault = function(compare2) {
      return function(first, second) {
        return first === second || compare2(first, second) === 0;
      };
    };
    exports.equalsDefault = equalsDefault;
    var fromCompare = function(compare2) {
      return {
        equals: (0, exports.equalsDefault)(compare2),
        compare: function(first, second) {
          return first === second ? 0 : compare2(first, second);
        }
      };
    };
    exports.fromCompare = fromCompare;
    var tuple = function() {
      var ords = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        ords[_i] = arguments[_i];
      }
      return (0, exports.fromCompare)(function(first, second) {
        var i = 0;
        for (; i < ords.length - 1; i++) {
          var r = ords[i].compare(first[i], second[i]);
          if (r !== 0) {
            return r;
          }
        }
        return ords[i].compare(first[i], second[i]);
      });
    };
    exports.tuple = tuple;
    var reverse = function(O) {
      return (0, exports.fromCompare)(function(first, second) {
        return O.compare(second, first);
      });
    };
    exports.reverse = reverse;
    var contramap_ = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.contramap)(f2));
    };
    var contramap = function(f2) {
      return function(fa) {
        return (0, exports.fromCompare)(function(first, second) {
          return fa.compare(f2(first), f2(second));
        });
      };
    };
    exports.contramap = contramap;
    exports.URI = "Ord";
    var getSemigroup = function() {
      return {
        concat: function(first, second) {
          return (0, exports.fromCompare)(function(a, b) {
            var ox = first.compare(a, b);
            return ox !== 0 ? ox : second.compare(a, b);
          });
        }
      };
    };
    exports.getSemigroup = getSemigroup;
    var getMonoid = function() {
      return {
        concat: (0, exports.getSemigroup)().concat,
        empty: (0, exports.fromCompare)(function() {
          return 0;
        })
      };
    };
    exports.getMonoid = getMonoid;
    exports.Contravariant = {
      URI: exports.URI,
      contramap: contramap_
    };
    exports.trivial = {
      equals: function_1.constTrue,
      compare: /* @__PURE__ */ (0, function_1.constant)(0)
    };
    var equals = function(O) {
      return function(second) {
        return function(first) {
          return first === second || O.compare(first, second) === 0;
        };
      };
    };
    exports.equals = equals;
    var lt = function(O) {
      return function(first, second) {
        return O.compare(first, second) === -1;
      };
    };
    exports.lt = lt;
    var gt = function(O) {
      return function(first, second) {
        return O.compare(first, second) === 1;
      };
    };
    exports.gt = gt;
    var leq = function(O) {
      return function(first, second) {
        return O.compare(first, second) !== 1;
      };
    };
    exports.leq = leq;
    var geq = function(O) {
      return function(first, second) {
        return O.compare(first, second) !== -1;
      };
    };
    exports.geq = geq;
    var min = function(O) {
      return function(first, second) {
        return first === second || O.compare(first, second) < 1 ? first : second;
      };
    };
    exports.min = min;
    var max = function(O) {
      return function(first, second) {
        return first === second || O.compare(first, second) > -1 ? first : second;
      };
    };
    exports.max = max;
    var clamp = function(O) {
      var minO = (0, exports.min)(O);
      var maxO = (0, exports.max)(O);
      return function(low, hi) {
        return function(a) {
          return maxO(minO(a, hi), low);
        };
      };
    };
    exports.clamp = clamp;
    var between = function(O) {
      var ltO = (0, exports.lt)(O);
      var gtO = (0, exports.gt)(O);
      return function(low, hi) {
        return function(a) {
          return ltO(a, low) || gtO(a, hi) ? false : true;
        };
      };
    };
    exports.between = between;
    exports.getTupleOrd = exports.tuple;
    exports.getDualOrd = exports.reverse;
    exports.ord = exports.Contravariant;
    function compare(first, second) {
      return first < second ? -1 : first > second ? 1 : 0;
    }
    var strictOrd = {
      equals: Eq_1.eqStrict.equals,
      compare
    };
    exports.ordBoolean = strictOrd;
    exports.ordString = strictOrd;
    exports.ordNumber = strictOrd;
    exports.ordDate = (0, function_1.pipe)(
      exports.ordNumber,
      /* @__PURE__ */ (0, exports.contramap)(function(date) {
        return date.valueOf();
      })
    );
  }
});

// node_modules/fp-ts/lib/Magma.js
var require_Magma = __commonJS({
  "node_modules/fp-ts/lib/Magma.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatAll = exports.endo = exports.filterSecond = exports.filterFirst = exports.reverse = void 0;
    var reverse = function(M) {
      return {
        concat: function(first, second) {
          return M.concat(second, first);
        }
      };
    };
    exports.reverse = reverse;
    var filterFirst = function(predicate) {
      return function(M) {
        return {
          concat: function(first, second) {
            return predicate(first) ? M.concat(first, second) : second;
          }
        };
      };
    };
    exports.filterFirst = filterFirst;
    var filterSecond = function(predicate) {
      return function(M) {
        return {
          concat: function(first, second) {
            return predicate(second) ? M.concat(first, second) : first;
          }
        };
      };
    };
    exports.filterSecond = filterSecond;
    var endo = function(f2) {
      return function(M) {
        return {
          concat: function(first, second) {
            return M.concat(f2(first), f2(second));
          }
        };
      };
    };
    exports.endo = endo;
    var concatAll = function(M) {
      return function(startWith) {
        return function(as) {
          return as.reduce(function(a, acc) {
            return M.concat(a, acc);
          }, startWith);
        };
      };
    };
    exports.concatAll = concatAll;
  }
});

// node_modules/fp-ts/lib/Semigroup.js
var require_Semigroup = __commonJS({
  "node_modules/fp-ts/lib/Semigroup.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.fold = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    var M = __importStar(require_Magma());
    var Or = __importStar(require_Ord());
    var min = function(O) {
      return {
        concat: Or.min(O)
      };
    };
    exports.min = min;
    var max = function(O) {
      return {
        concat: Or.max(O)
      };
    };
    exports.max = max;
    var constant = function(a) {
      return {
        concat: function() {
          return a;
        }
      };
    };
    exports.constant = constant;
    exports.reverse = M.reverse;
    var struct = function(semigroups) {
      return {
        concat: function(first2, second) {
          var r = {};
          for (var k in semigroups) {
            if (_.has.call(semigroups, k)) {
              r[k] = semigroups[k].concat(first2[k], second[k]);
            }
          }
          return r;
        }
      };
    };
    exports.struct = struct;
    var tuple = function() {
      var semigroups = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        semigroups[_i] = arguments[_i];
      }
      return {
        concat: function(first2, second) {
          return semigroups.map(function(s, i) {
            return s.concat(first2[i], second[i]);
          });
        }
      };
    };
    exports.tuple = tuple;
    var intercalate = function(middle) {
      return function(S) {
        return {
          concat: function(x, y) {
            return S.concat(x, S.concat(middle, y));
          }
        };
      };
    };
    exports.intercalate = intercalate;
    var first = function() {
      return { concat: function_1.identity };
    };
    exports.first = first;
    var last = function() {
      return { concat: function(_2, y) {
        return y;
      } };
    };
    exports.last = last;
    exports.concatAll = M.concatAll;
    exports.semigroupVoid = (0, exports.constant)(void 0);
    var getObjectSemigroup = function() {
      return {
        concat: function(first2, second) {
          return Object.assign({}, first2, second);
        }
      };
    };
    exports.getObjectSemigroup = getObjectSemigroup;
    exports.getLastSemigroup = exports.last;
    exports.getFirstSemigroup = exports.first;
    exports.getTupleSemigroup = exports.tuple;
    exports.getStructSemigroup = exports.struct;
    exports.getDualSemigroup = exports.reverse;
    exports.getJoinSemigroup = exports.max;
    exports.getMeetSemigroup = exports.min;
    exports.getIntercalateSemigroup = exports.intercalate;
    function fold(S) {
      var concatAllS = (0, exports.concatAll)(S);
      return function(startWith, as) {
        return as === void 0 ? concatAllS(startWith) : concatAllS(startWith)(as);
      };
    }
    exports.fold = fold;
    exports.semigroupAll = {
      concat: function(x, y) {
        return x && y;
      }
    };
    exports.semigroupAny = {
      concat: function(x, y) {
        return x || y;
      }
    };
    exports.getFunctionSemigroup = function_1.getSemigroup;
    exports.semigroupString = {
      concat: function(x, y) {
        return x + y;
      }
    };
    exports.semigroupSum = {
      concat: function(x, y) {
        return x + y;
      }
    };
    exports.semigroupProduct = {
      concat: function(x, y) {
        return x * y;
      }
    };
  }
});

// node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js
var require_ReadonlyNonEmptyArray = __commonJS({
  "node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduceRight = exports.foldMap = exports.reduce = exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.of = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.modifyAt = exports.updateAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.fromArray = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromReadonlyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = exports.empty = void 0;
    exports.groupSort = exports.chain = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;
    exports.readonlyNonEmptyArray = exports.fold = exports.prependToAll = exports.insertAt = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = exports.filter = void 0;
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var Eq_1 = require_Eq();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Ord_1 = require_Ord();
    var Se = __importStar(require_Semigroup());
    exports.empty = _.emptyReadonlyArray;
    exports.isNonEmpty = _.isNonEmpty;
    var isOutOfBound = function(i, as) {
      return i < 0 || i >= as.length;
    };
    exports.isOutOfBound = isOutOfBound;
    var prependW = function(head) {
      return function(tail) {
        return __spreadArray([head], tail, true);
      };
    };
    exports.prependW = prependW;
    exports.prepend = exports.prependW;
    var appendW = function(end) {
      return function(init2) {
        return __spreadArray(__spreadArray([], init2, true), [end], false);
      };
    };
    exports.appendW = appendW;
    exports.append = exports.appendW;
    var unsafeInsertAt = function(i, a, as) {
      if ((0, exports.isNonEmpty)(as)) {
        var xs = _.fromReadonlyNonEmptyArray(as);
        xs.splice(i, 0, a);
        return xs;
      }
      return [a];
    };
    exports.unsafeInsertAt = unsafeInsertAt;
    var unsafeUpdateAt = function(i, a, as) {
      if (as[i] === a) {
        return as;
      } else {
        var xs = _.fromReadonlyNonEmptyArray(as);
        xs[i] = a;
        return xs;
      }
    };
    exports.unsafeUpdateAt = unsafeUpdateAt;
    var uniq = function(E) {
      return function(as) {
        if (as.length === 1) {
          return as;
        }
        var out = [(0, exports.head)(as)];
        var rest = (0, exports.tail)(as);
        var _loop_1 = function(a2) {
          if (out.every(function(o) {
            return !E.equals(o, a2);
          })) {
            out.push(a2);
          }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
          var a = rest_1[_i];
          _loop_1(a);
        }
        return out;
      };
    };
    exports.uniq = uniq;
    var sortBy = function(ords) {
      if ((0, exports.isNonEmpty)(ords)) {
        var M = (0, Ord_1.getMonoid)();
        return (0, exports.sort)(ords.reduce(M.concat, M.empty));
      }
      return function_1.identity;
    };
    exports.sortBy = sortBy;
    var union = function(E) {
      var uniqE = (0, exports.uniq)(E);
      return function(second) {
        return function(first) {
          return uniqE((0, function_1.pipe)(first, concat(second)));
        };
      };
    };
    exports.union = union;
    var rotate = function(n) {
      return function(as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
          return as;
        }
        if (m < 0) {
          var _a2 = (0, exports.splitAt)(-m)(as), f2 = _a2[0], s = _a2[1];
          return (0, function_1.pipe)(s, concat(f2));
        } else {
          return (0, exports.rotate)(m - len)(as);
        }
      };
    };
    exports.rotate = rotate;
    var fromReadonlyArray = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;
    };
    exports.fromReadonlyArray = fromReadonlyArray;
    var makeBy = function(f2) {
      return function(n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f2(0)];
        for (var i = 1; i < j; i++) {
          out.push(f2(i));
        }
        return out;
      };
    };
    exports.makeBy = makeBy;
    var replicate = function(a) {
      return (0, exports.makeBy)(function() {
        return a;
      });
    };
    exports.replicate = replicate;
    var range = function(start, end) {
      return start <= end ? (0, exports.makeBy)(function(i) {
        return start + i;
      })(end - start + 1) : [start];
    };
    exports.range = range;
    var unprepend = function(as) {
      return [(0, exports.head)(as), (0, exports.tail)(as)];
    };
    exports.unprepend = unprepend;
    var unappend = function(as) {
      return [(0, exports.init)(as), (0, exports.last)(as)];
    };
    exports.unappend = unappend;
    var fromArray = function(as) {
      return (0, exports.fromReadonlyArray)(as.slice());
    };
    exports.fromArray = fromArray;
    function concatW(second) {
      return function(first) {
        return first.concat(second);
      };
    }
    exports.concatW = concatW;
    function concat(x, y) {
      return y ? x.concat(y) : function(y2) {
        return y2.concat(x);
      };
    }
    exports.concat = concat;
    var reverse = function(as) {
      return as.length === 1 ? as : __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);
    };
    exports.reverse = reverse;
    function group(E) {
      return function(as) {
        var len = as.length;
        if (len === 0) {
          return exports.empty;
        }
        var out = [];
        var head = as[0];
        var nea = [head];
        for (var i = 1; i < len; i++) {
          var a = as[i];
          if (E.equals(a, head)) {
            nea.push(a);
          } else {
            out.push(nea);
            head = a;
            nea = [head];
          }
        }
        out.push(nea);
        return out;
      };
    }
    exports.group = group;
    var groupBy = function(f2) {
      return function(as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
          var a = as_1[_i];
          var k = f2(a);
          if (_.has.call(out, k)) {
            out[k].push(a);
          } else {
            out[k] = [a];
          }
        }
        return out;
      };
    };
    exports.groupBy = groupBy;
    var sort = function(O) {
      return function(as) {
        return as.length === 1 ? as : as.slice().sort(O.compare);
      };
    };
    exports.sort = sort;
    var updateAt = function(i, a) {
      return (0, exports.modifyAt)(i, function() {
        return a;
      });
    };
    exports.updateAt = updateAt;
    var modifyAt = function(i, f2) {
      return function(as) {
        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f2(as[i]), as));
      };
    };
    exports.modifyAt = modifyAt;
    var zipWith = function(as, bs, f2) {
      var cs = [f2(as[0], bs[0])];
      var len = Math.min(as.length, bs.length);
      for (var i = 1; i < len; i++) {
        cs[i] = f2(as[i], bs[i]);
      }
      return cs;
    };
    exports.zipWith = zipWith;
    function zip(as, bs) {
      if (bs === void 0) {
        return function(bs2) {
          return zip(bs2, as);
        };
      }
      return (0, exports.zipWith)(as, bs, function(a, b) {
        return [a, b];
      });
    }
    exports.zip = zip;
    var unzip = function(abs) {
      var fa = [abs[0][0]];
      var fb = [abs[0][1]];
      for (var i = 1; i < abs.length; i++) {
        fa[i] = abs[i][0];
        fb[i] = abs[i][1];
      }
      return [fa, fb];
    };
    exports.unzip = unzip;
    var prependAll = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    exports.prependAll = prependAll;
    var intersperse = function(middle) {
      return function(as) {
        var rest = (0, exports.tail)(as);
        return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : as;
      };
    };
    exports.intersperse = intersperse;
    var chainWithIndex = function(f2) {
      return function(as) {
        var out = _.fromReadonlyNonEmptyArray(f2(0, (0, exports.head)(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f2(i, as[i]));
        }
        return out;
      };
    };
    exports.chainWithIndex = chainWithIndex;
    var chop = function(f2) {
      return function(as) {
        var _a2 = f2(as), b = _a2[0], rest = _a2[1];
        var out = [b];
        var next = rest;
        while ((0, exports.isNonEmpty)(next)) {
          var _b = f2(next), b_1 = _b[0], rest_2 = _b[1];
          out.push(b_1);
          next = rest_2;
        }
        return out;
      };
    };
    exports.chop = chop;
    var splitAt = function(n) {
      return function(as) {
        var m = Math.max(1, n);
        return m >= as.length ? [as, exports.empty] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
      };
    };
    exports.splitAt = splitAt;
    var chunksOf = function(n) {
      return (0, exports.chop)((0, exports.splitAt)(n));
    };
    exports.chunksOf = chunksOf;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _mapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _reduceWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f2));
    };
    var _foldMapWithIndex = function(M) {
      var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapWithIndexM(f2));
      };
    };
    var _reduceRightWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f2));
    };
    var _traverseWithIndex = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseWithIndexF(f2));
      };
    };
    exports.of = _.singleton;
    var altW = function(that) {
      return function(as) {
        return (0, function_1.pipe)(as, concatW(that()));
      };
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    var ap = function(as) {
      return (0, exports.flatMap)(function(f2) {
        return (0, function_1.pipe)(as, (0, exports.map)(f2));
      });
    };
    exports.ap = ap;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(i, a) {
        return f2(a, i);
      }));
    });
    var extend = function(f2) {
      return function(as) {
        var next = (0, exports.tail)(as);
        var out = [f2(as)];
        while ((0, exports.isNonEmpty)(next)) {
          out.push(f2(next));
          next = (0, exports.tail)(next);
        }
        return out;
      };
    };
    exports.extend = extend;
    exports.duplicate = /* @__PURE__ */ (0, exports.extend)(function_1.identity);
    exports.flatten = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    var map = function(f2) {
      return (0, exports.mapWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.map = map;
    var mapWithIndex = function(f2) {
      return function(as) {
        var out = [f2(0, (0, exports.head)(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f2(i, as[i]));
        }
        return out;
      };
    };
    exports.mapWithIndex = mapWithIndex;
    var reduce = function(b, f2) {
      return (0, exports.reduceWithIndex)(b, function(_2, b2, a) {
        return f2(b2, a);
      });
    };
    exports.reduce = reduce;
    var foldMap = function(S) {
      return function(f2) {
        return function(as) {
          return as.slice(1).reduce(function(s, a) {
            return S.concat(s, f2(a));
          }, f2(as[0]));
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f2) {
      return (0, exports.reduceRightWithIndex)(b, function(_2, b2, a) {
        return f2(b2, a);
      });
    };
    exports.reduceRight = reduceRight;
    var reduceWithIndex = function(b, f2) {
      return function(as) {
        return as.reduce(function(b2, a, i) {
          return f2(i, b2, a);
        }, b);
      };
    };
    exports.reduceWithIndex = reduceWithIndex;
    var foldMapWithIndex = function(S) {
      return function(f2) {
        return function(as) {
          return as.slice(1).reduce(function(s, a, i) {
            return S.concat(s, f2(i + 1, a));
          }, f2(0, as[0]));
        };
      };
    };
    exports.foldMapWithIndex = foldMapWithIndex;
    var reduceRightWithIndex = function(b, f2) {
      return function(as) {
        return as.reduceRight(function(b2, a, i) {
          return f2(i, a, b2);
        }, b);
      };
    };
    exports.reduceRightWithIndex = reduceRightWithIndex;
    var traverse = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(f2) {
        return traverseWithIndexF(function(_2, a) {
          return f2(a);
        });
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return (0, exports.traverseWithIndex)(F)(function_1.SK);
    };
    exports.sequence = sequence;
    var traverseWithIndex = function(F) {
      return function(f2) {
        return function(as) {
          var out = F.map(f2(0, (0, exports.head)(as)), exports.of);
          for (var i = 1; i < as.length; i++) {
            out = F.ap(F.map(out, function(bs) {
              return function(b) {
                return (0, function_1.pipe)(bs, (0, exports.append)(b));
              };
            }), f2(i, as[i]));
          }
          return out;
        };
      };
    };
    exports.traverseWithIndex = traverseWithIndex;
    exports.extract = _.head;
    exports.URI = "ReadonlyNonEmptyArray";
    var getShow = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    exports.getShow = getShow;
    var getSemigroup = function() {
      return {
        concat
      };
    };
    exports.getSemigroup = getSemigroup;
    var getEq = function(E) {
      return (0, Eq_1.fromEquals)(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    exports.getEq = getEq;
    var getUnionSemigroup = function(E) {
      var unionE = (0, exports.union)(E);
      return {
        concat: function(first, second) {
          return unionE(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.FunctorWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.FoldableWithIndex = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.TraversableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.Comonad = {
      URI: exports.URI,
      map: _map2,
      extend: _extend,
      extract: exports.extract
    };
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.head = exports.extract;
    exports.tail = _.tail;
    var last = function(as) {
      return as[as.length - 1];
    };
    exports.last = last;
    var init = function(as) {
      return as.slice(0, -1);
    };
    exports.init = init;
    var min = function(O) {
      var S = Se.min(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    exports.min = min;
    var max = function(O) {
      var S = Se.max(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    exports.max = max;
    var concatAll = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    exports.concatAll = concatAll;
    var matchLeft = function(f2) {
      return function(as) {
        return f2((0, exports.head)(as), (0, exports.tail)(as));
      };
    };
    exports.matchLeft = matchLeft;
    var matchRight = function(f2) {
      return function(as) {
        return f2((0, exports.init)(as), (0, exports.last)(as));
      };
    };
    exports.matchRight = matchRight;
    var modifyHead = function(f2) {
      return function(as) {
        return __spreadArray([f2((0, exports.head)(as))], (0, exports.tail)(as), true);
      };
    };
    exports.modifyHead = modifyHead;
    var updateHead = function(a) {
      return (0, exports.modifyHead)(function() {
        return a;
      });
    };
    exports.updateHead = updateHead;
    var modifyLast = function(f2) {
      return function(as) {
        return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f2((0, exports.last)(as))));
      };
    };
    exports.modifyLast = modifyLast;
    var updateLast = function(a) {
      return (0, exports.modifyLast)(function() {
        return a;
      });
    };
    exports.updateLast = updateLast;
    var intercalate = function(S) {
      var concatAllS = (0, exports.concatAll)(S);
      return function(middle) {
        return (0, function_1.flow)((0, exports.intersperse)(middle), concatAllS);
      };
    };
    exports.intercalate = intercalate;
    exports.chain = exports.flatMap;
    function groupSort(O) {
      var sortO = (0, exports.sort)(O);
      var groupO = group(O);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : exports.empty;
      };
    }
    exports.groupSort = groupSort;
    function filter2(predicate) {
      return (0, exports.filterWithIndex)(function(_2, a) {
        return predicate(a);
      });
    }
    exports.filter = filter2;
    var filterWithIndex = function(predicate) {
      return function(as) {
        return (0, exports.fromReadonlyArray)(as.filter(function(a, i) {
          return predicate(i, a);
        }));
      };
    };
    exports.filterWithIndex = filterWithIndex;
    exports.uncons = exports.unprepend;
    exports.unsnoc = exports.unappend;
    function cons(head, tail) {
      return tail === void 0 ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail, (0, exports.prepend)(head));
    }
    exports.cons = cons;
    var snoc = function(init2, end) {
      return (0, function_1.pipe)(init2, concat([end]));
    };
    exports.snoc = snoc;
    var insertAt = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
      };
    };
    exports.insertAt = insertAt;
    exports.prependToAll = exports.prependAll;
    exports.fold = exports.concatAll;
    exports.readonlyNonEmptyArray = {
      URI: exports.URI,
      of: exports.of,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      ap: _ap,
      chain: exports.flatMap,
      extend: _extend,
      extract: exports.extract,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex,
      alt: _alt
    };
  }
});

// node_modules/fp-ts/lib/NonEmptyArray.js
var require_NonEmptyArray = __commonJS({
  "node_modules/fp-ts/lib/NonEmptyArray.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.foldMap = exports.foldMapWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.of = exports.copy = exports.modifyAt = exports.updateAt = exports.insertAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromArray = exports.fromReadonlyNonEmptyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = void 0;
    exports.chain = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = void 0;
    exports.nonEmptyArray = exports.fold = exports.prependToAll = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = exports.filter = exports.groupSort = void 0;
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Ord_1 = require_Ord();
    var RNEA = __importStar(require_ReadonlyNonEmptyArray());
    var isNonEmpty = function(as) {
      return as.length > 0;
    };
    exports.isNonEmpty = isNonEmpty;
    var isOutOfBound = function(i, as) {
      return i < 0 || i >= as.length;
    };
    exports.isOutOfBound = isOutOfBound;
    var prependW = function(head) {
      return function(tail2) {
        return __spreadArray([head], tail2, true);
      };
    };
    exports.prependW = prependW;
    exports.prepend = exports.prependW;
    var appendW = function(end) {
      return function(init2) {
        return __spreadArray(__spreadArray([], init2, true), [end], false);
      };
    };
    exports.appendW = appendW;
    exports.append = exports.appendW;
    var unsafeInsertAt = function(i, a, as) {
      if ((0, exports.isNonEmpty)(as)) {
        var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
        xs.splice(i, 0, a);
        return xs;
      }
      return [a];
    };
    exports.unsafeInsertAt = unsafeInsertAt;
    var unsafeUpdateAt = function(i, a, as) {
      var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
      xs[i] = a;
      return xs;
    };
    exports.unsafeUpdateAt = unsafeUpdateAt;
    var uniq = function(E) {
      return function(as) {
        if (as.length === 1) {
          return (0, exports.copy)(as);
        }
        var out = [(0, exports.head)(as)];
        var rest = (0, exports.tail)(as);
        var _loop_1 = function(a2) {
          if (out.every(function(o) {
            return !E.equals(o, a2);
          })) {
            out.push(a2);
          }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
          var a = rest_1[_i];
          _loop_1(a);
        }
        return out;
      };
    };
    exports.uniq = uniq;
    var sortBy = function(ords) {
      if ((0, exports.isNonEmpty)(ords)) {
        var M = (0, Ord_1.getMonoid)();
        return (0, exports.sort)(ords.reduce(M.concat, M.empty));
      }
      return exports.copy;
    };
    exports.sortBy = sortBy;
    var union = function(E) {
      var uniqE = (0, exports.uniq)(E);
      return function(second) {
        return function(first) {
          return uniqE((0, function_1.pipe)(first, concat(second)));
        };
      };
    };
    exports.union = union;
    var rotate = function(n) {
      return function(as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
          return (0, exports.copy)(as);
        }
        if (m < 0) {
          var _a2 = (0, exports.splitAt)(-m)(as), f2 = _a2[0], s = _a2[1];
          return (0, function_1.pipe)(s, concat(f2));
        } else {
          return (0, exports.rotate)(m - len)(as);
        }
      };
    };
    exports.rotate = rotate;
    exports.fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;
    var fromArray = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;
    };
    exports.fromArray = fromArray;
    var makeBy = function(f2) {
      return function(n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f2(0)];
        for (var i = 1; i < j; i++) {
          out.push(f2(i));
        }
        return out;
      };
    };
    exports.makeBy = makeBy;
    var replicate = function(a) {
      return (0, exports.makeBy)(function() {
        return a;
      });
    };
    exports.replicate = replicate;
    var range = function(start, end) {
      return start <= end ? (0, exports.makeBy)(function(i) {
        return start + i;
      })(end - start + 1) : [start];
    };
    exports.range = range;
    var unprepend = function(as) {
      return [(0, exports.head)(as), (0, exports.tail)(as)];
    };
    exports.unprepend = unprepend;
    var unappend = function(as) {
      return [(0, exports.init)(as), (0, exports.last)(as)];
    };
    exports.unappend = unappend;
    function concatW(second) {
      return function(first) {
        return first.concat(second);
      };
    }
    exports.concatW = concatW;
    function concat(x, y) {
      return y ? x.concat(y) : function(y2) {
        return y2.concat(x);
      };
    }
    exports.concat = concat;
    var reverse = function(as) {
      return __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);
    };
    exports.reverse = reverse;
    function group(E) {
      return function(as) {
        var len = as.length;
        if (len === 0) {
          return [];
        }
        var out = [];
        var head = as[0];
        var nea = [head];
        for (var i = 1; i < len; i++) {
          var a = as[i];
          if (E.equals(a, head)) {
            nea.push(a);
          } else {
            out.push(nea);
            head = a;
            nea = [head];
          }
        }
        out.push(nea);
        return out;
      };
    }
    exports.group = group;
    var groupBy = function(f2) {
      return function(as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
          var a = as_1[_i];
          var k = f2(a);
          if (_.has.call(out, k)) {
            out[k].push(a);
          } else {
            out[k] = [a];
          }
        }
        return out;
      };
    };
    exports.groupBy = groupBy;
    var sort = function(O) {
      return function(as) {
        return as.slice().sort(O.compare);
      };
    };
    exports.sort = sort;
    var insertAt = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
      };
    };
    exports.insertAt = insertAt;
    var updateAt = function(i, a) {
      return (0, exports.modifyAt)(i, function() {
        return a;
      });
    };
    exports.updateAt = updateAt;
    var modifyAt = function(i, f2) {
      return function(as) {
        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f2(as[i]), as));
      };
    };
    exports.modifyAt = modifyAt;
    exports.copy = exports.fromReadonlyNonEmptyArray;
    var of = function(a) {
      return [a];
    };
    exports.of = of;
    var zipWith = function(as, bs, f2) {
      var cs = [f2(as[0], bs[0])];
      var len = Math.min(as.length, bs.length);
      for (var i = 1; i < len; i++) {
        cs[i] = f2(as[i], bs[i]);
      }
      return cs;
    };
    exports.zipWith = zipWith;
    function zip(as, bs) {
      if (bs === void 0) {
        return function(bs2) {
          return zip(bs2, as);
        };
      }
      return (0, exports.zipWith)(as, bs, function(a, b) {
        return [a, b];
      });
    }
    exports.zip = zip;
    var unzip = function(abs) {
      var fa = [abs[0][0]];
      var fb = [abs[0][1]];
      for (var i = 1; i < abs.length; i++) {
        fa[i] = abs[i][0];
        fb[i] = abs[i][1];
      }
      return [fa, fb];
    };
    exports.unzip = unzip;
    var prependAll = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    exports.prependAll = prependAll;
    var intersperse = function(middle) {
      return function(as) {
        var rest = (0, exports.tail)(as);
        return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : (0, exports.copy)(as);
      };
    };
    exports.intersperse = intersperse;
    exports.foldMapWithIndex = RNEA.foldMapWithIndex;
    exports.foldMap = RNEA.foldMap;
    var chainWithIndex = function(f2) {
      return function(as) {
        var out = (0, exports.fromReadonlyNonEmptyArray)(f2(0, (0, exports.head)(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f2(i, as[i]));
        }
        return out;
      };
    };
    exports.chainWithIndex = chainWithIndex;
    var chop = function(f2) {
      return function(as) {
        var _a2 = f2(as), b = _a2[0], rest = _a2[1];
        var out = [b];
        var next = rest;
        while ((0, exports.isNonEmpty)(next)) {
          var _b = f2(next), b_1 = _b[0], rest_2 = _b[1];
          out.push(b_1);
          next = rest_2;
        }
        return out;
      };
    };
    exports.chop = chop;
    var splitAt = function(n) {
      return function(as) {
        var m = Math.max(1, n);
        return m >= as.length ? [(0, exports.copy)(as), []] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
      };
    };
    exports.splitAt = splitAt;
    var chunksOf = function(n) {
      return (0, exports.chop)((0, exports.splitAt)(n));
    };
    exports.chunksOf = chunksOf;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _mapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _reduceWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f2));
    };
    var _foldMapWithIndex = function(M) {
      var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapWithIndexM(f2));
      };
    };
    var _reduceRightWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f2));
    };
    var _traverseWithIndex = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseWithIndexF(f2));
      };
    };
    var altW = function(that) {
      return function(as) {
        return (0, function_1.pipe)(as, concatW(that()));
      };
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    var ap = function(as) {
      return (0, exports.flatMap)(function(f2) {
        return (0, function_1.pipe)(as, (0, exports.map)(f2));
      });
    };
    exports.ap = ap;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(i, a) {
        return f2(a, i);
      }));
    });
    var extend = function(f2) {
      return function(as) {
        var next = (0, exports.tail)(as);
        var out = [f2(as)];
        while ((0, exports.isNonEmpty)(next)) {
          out.push(f2(next));
          next = (0, exports.tail)(next);
        }
        return out;
      };
    };
    exports.extend = extend;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    var map = function(f2) {
      return (0, exports.mapWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.map = map;
    var mapWithIndex = function(f2) {
      return function(as) {
        var out = [f2(0, (0, exports.head)(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f2(i, as[i]));
        }
        return out;
      };
    };
    exports.mapWithIndex = mapWithIndex;
    exports.reduce = RNEA.reduce;
    exports.reduceWithIndex = RNEA.reduceWithIndex;
    exports.reduceRight = RNEA.reduceRight;
    exports.reduceRightWithIndex = RNEA.reduceRightWithIndex;
    var traverse = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(f2) {
        return traverseWithIndexF(function(_2, a) {
          return f2(a);
        });
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return (0, exports.traverseWithIndex)(F)(function(_2, a) {
        return a;
      });
    };
    exports.sequence = sequence;
    var traverseWithIndex = function(F) {
      return function(f2) {
        return function(as) {
          var out = F.map(f2(0, (0, exports.head)(as)), exports.of);
          for (var i = 1; i < as.length; i++) {
            out = F.ap(F.map(out, function(bs) {
              return function(b) {
                return (0, function_1.pipe)(bs, (0, exports.append)(b));
              };
            }), f2(i, as[i]));
          }
          return out;
        };
      };
    };
    exports.traverseWithIndex = traverseWithIndex;
    exports.extract = RNEA.head;
    exports.URI = "NonEmptyArray";
    exports.getShow = RNEA.getShow;
    var getSemigroup = function() {
      return {
        concat
      };
    };
    exports.getSemigroup = getSemigroup;
    exports.getEq = RNEA.getEq;
    var getUnionSemigroup = function(E) {
      var unionE = (0, exports.union)(E);
      return {
        concat: function(first, second) {
          return unionE(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.FunctorWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.FoldableWithIndex = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.TraversableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.Comonad = {
      URI: exports.URI,
      map: _map2,
      extend: _extend,
      extract: exports.extract
    };
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.head = RNEA.head;
    var tail = function(as) {
      return as.slice(1);
    };
    exports.tail = tail;
    exports.last = RNEA.last;
    var init = function(as) {
      return as.slice(0, -1);
    };
    exports.init = init;
    exports.min = RNEA.min;
    exports.max = RNEA.max;
    var concatAll = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    exports.concatAll = concatAll;
    var matchLeft = function(f2) {
      return function(as) {
        return f2((0, exports.head)(as), (0, exports.tail)(as));
      };
    };
    exports.matchLeft = matchLeft;
    var matchRight = function(f2) {
      return function(as) {
        return f2((0, exports.init)(as), (0, exports.last)(as));
      };
    };
    exports.matchRight = matchRight;
    var modifyHead = function(f2) {
      return function(as) {
        return __spreadArray([f2((0, exports.head)(as))], (0, exports.tail)(as), true);
      };
    };
    exports.modifyHead = modifyHead;
    var updateHead = function(a) {
      return (0, exports.modifyHead)(function() {
        return a;
      });
    };
    exports.updateHead = updateHead;
    var modifyLast = function(f2) {
      return function(as) {
        return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f2((0, exports.last)(as))));
      };
    };
    exports.modifyLast = modifyLast;
    var updateLast = function(a) {
      return (0, exports.modifyLast)(function() {
        return a;
      });
    };
    exports.updateLast = updateLast;
    exports.intercalate = RNEA.intercalate;
    exports.chain = exports.flatMap;
    function groupSort(O) {
      var sortO = (0, exports.sort)(O);
      var groupO = group(O);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : [];
      };
    }
    exports.groupSort = groupSort;
    function filter2(predicate) {
      return (0, exports.filterWithIndex)(function(_2, a) {
        return predicate(a);
      });
    }
    exports.filter = filter2;
    var filterWithIndex = function(predicate) {
      return function(as) {
        return (0, exports.fromArray)(as.filter(function(a, i) {
          return predicate(i, a);
        }));
      };
    };
    exports.filterWithIndex = filterWithIndex;
    exports.uncons = exports.unprepend;
    exports.unsnoc = exports.unappend;
    function cons(head, tail2) {
      return tail2 === void 0 ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail2, (0, exports.prepend)(head));
    }
    exports.cons = cons;
    var snoc = function(init2, end) {
      return (0, function_1.pipe)(init2, (0, exports.append)(end));
    };
    exports.snoc = snoc;
    exports.prependToAll = exports.prependAll;
    exports.fold = RNEA.concatAll;
    exports.nonEmptyArray = {
      URI: exports.URI,
      of: exports.of,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      ap: _ap,
      chain: exports.flatMap,
      extend: _extend,
      extract: exports.extract,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex,
      alt: _alt
    };
  }
});

// node_modules/fp-ts/lib/number.js
var require_number = __commonJS({
  "node_modules/fp-ts/lib/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Field = exports.MonoidProduct = exports.MonoidSum = exports.SemigroupProduct = exports.SemigroupSum = exports.MagmaSub = exports.Show = exports.Bounded = exports.Ord = exports.Eq = exports.isNumber = void 0;
    var isNumber2 = function(u) {
      return typeof u === "number";
    };
    exports.isNumber = isNumber2;
    exports.Eq = {
      equals: function(first, second) {
        return first === second;
      }
    };
    exports.Ord = {
      equals: exports.Eq.equals,
      compare: function(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
      }
    };
    exports.Bounded = {
      equals: exports.Eq.equals,
      compare: exports.Ord.compare,
      top: Infinity,
      bottom: -Infinity
    };
    exports.Show = {
      show: function(n) {
        return JSON.stringify(n);
      }
    };
    exports.MagmaSub = {
      concat: function(first, second) {
        return first - second;
      }
    };
    exports.SemigroupSum = {
      concat: function(first, second) {
        return first + second;
      }
    };
    exports.SemigroupProduct = {
      concat: function(first, second) {
        return first * second;
      }
    };
    exports.MonoidSum = {
      concat: exports.SemigroupSum.concat,
      empty: 0
    };
    exports.MonoidProduct = {
      concat: exports.SemigroupProduct.concat,
      empty: 1
    };
    exports.Field = {
      add: exports.SemigroupSum.concat,
      zero: 0,
      mul: exports.SemigroupProduct.concat,
      one: 1,
      sub: exports.MagmaSub.concat,
      degree: function(_) {
        return 1;
      },
      div: function(first, second) {
        return first / second;
      },
      mod: function(first, second) {
        return first % second;
      }
    };
  }
});

// node_modules/fp-ts/lib/Separated.js
var require_Separated = __commonJS({
  "node_modules/fp-ts/lib/Separated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var separated = function(left2, right2) {
      return { left: left2, right: right2 };
    };
    exports.separated = separated;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _mapLeft = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f2));
    };
    var _bimap = function(fa, g, f2) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f2));
    };
    var map = function(f2) {
      return function(fa) {
        return (0, exports.separated)((0, exports.left)(fa), f2((0, exports.right)(fa)));
      };
    };
    exports.map = map;
    var mapLeft = function(f2) {
      return function(fa) {
        return (0, exports.separated)(f2((0, exports.left)(fa)), (0, exports.right)(fa));
      };
    };
    exports.mapLeft = mapLeft;
    var bimap = function(f2, g) {
      return function(fa) {
        return (0, exports.separated)(f2((0, exports.left)(fa)), g((0, exports.right)(fa)));
      };
    };
    exports.bimap = bimap;
    exports.URI = "Separated";
    exports.Bifunctor = {
      URI: exports.URI,
      mapLeft: _mapLeft,
      bimap: _bimap
    };
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    var left = function(s) {
      return s.left;
    };
    exports.left = left;
    var right = function(s) {
      return s.right;
    };
    exports.right = right;
  }
});

// node_modules/fp-ts/lib/Witherable.js
var require_Witherable = __commonJS({
  "node_modules/fp-ts/lib/Witherable.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterE = exports.witherDefault = exports.wiltDefault = void 0;
    var _ = __importStar(require_internal());
    function wiltDefault(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f2) {
          return F.map(traverseF(wa, f2), C.separate);
        };
      };
    }
    exports.wiltDefault = wiltDefault;
    function witherDefault(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f2) {
          return F.map(traverseF(wa, f2), C.compact);
        };
      };
    }
    exports.witherDefault = witherDefault;
    function filterE(W) {
      return function(F) {
        var witherF = W.wither(F);
        return function(predicate) {
          return function(ga) {
            return witherF(ga, function(a) {
              return F.map(predicate(a), function(b) {
                return b ? _.some(a) : _.none;
              });
            });
          };
        };
      };
    }
    exports.filterE = filterE;
  }
});

// node_modules/fp-ts/lib/Zero.js
var require_Zero = __commonJS({
  "node_modules/fp-ts/lib/Zero.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.guard = void 0;
    function guard(F, P) {
      return function(b) {
        return b ? P.of(void 0) : F.zero();
      };
    }
    exports.guard = guard;
  }
});

// node_modules/fp-ts/lib/ReadonlyArray.js
var require_ReadonlyArray = __commonJS({
  "node_modules/fp-ts/lib/ReadonlyArray.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sort = exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
    exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.foldMap = exports.reduce = exports.foldMapWithIndex = exports.duplicate = exports.extend = exports.filterWithIndex = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.filter = exports.separate = exports.mapWithIndex = exports.map = exports.flatten = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.zero = exports.of = exports._chainRecBreadthFirst = exports._chainRecDepthFirst = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = void 0;
    exports.toArray = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.Witherable = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = exports.traverseWithIndex = void 0;
    exports.readonlyArray = exports.prependToAll = exports.snoc = exports.cons = exports.range = exports.chain = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = exports.some = exports.every = exports.empty = exports.fromArray = void 0;
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var Eq_1 = require_Eq();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var N = __importStar(require_number());
    var Ord_1 = require_Ord();
    var RNEA = __importStar(require_ReadonlyNonEmptyArray());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    var Zero_1 = require_Zero();
    var isEmpty = function(as) {
      return as.length === 0;
    };
    exports.isEmpty = isEmpty;
    exports.isNonEmpty = RNEA.isNonEmpty;
    exports.prepend = RNEA.prepend;
    exports.prependW = RNEA.prependW;
    exports.append = RNEA.append;
    exports.appendW = RNEA.appendW;
    var makeBy = function(n, f2) {
      return n <= 0 ? exports.empty : RNEA.makeBy(f2)(n);
    };
    exports.makeBy = makeBy;
    var replicate = function(n, a) {
      return (0, exports.makeBy)(n, function() {
        return a;
      });
    };
    exports.replicate = replicate;
    function fromPredicate(predicate) {
      return function(a) {
        return predicate(a) ? [a] : exports.empty;
      };
    }
    exports.fromPredicate = fromPredicate;
    var fromOption = function(ma) {
      return _.isNone(ma) ? exports.empty : [ma.value];
    };
    exports.fromOption = fromOption;
    var fromEither = function(e) {
      return _.isLeft(e) ? exports.empty : [e.right];
    };
    exports.fromEither = fromEither;
    var matchW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    exports.matchW = matchW;
    exports.match = exports.matchW;
    var matchLeftW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();
      };
    };
    exports.matchLeftW = matchLeftW;
    exports.matchLeft = exports.matchLeftW;
    exports.foldLeft = exports.matchLeft;
    var matchRightW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();
      };
    };
    exports.matchRightW = matchRightW;
    exports.matchRight = exports.matchRightW;
    exports.foldRight = exports.matchRight;
    var chainWithIndex = function(f2) {
      return function(as) {
        if ((0, exports.isEmpty)(as)) {
          return exports.empty;
        }
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f2(i, as[i]));
        }
        return out;
      };
    };
    exports.chainWithIndex = chainWithIndex;
    var scanLeft = function(b, f2) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
          out[i + 1] = f2(out[i], as[i]);
        }
        return out;
      };
    };
    exports.scanLeft = scanLeft;
    var scanRight = function(b, f2) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
          out[i] = f2(as[i], out[i + 1]);
        }
        return out;
      };
    };
    exports.scanRight = scanRight;
    var size = function(as) {
      return as.length;
    };
    exports.size = size;
    exports.isOutOfBound = RNEA.isOutOfBound;
    function lookup(i, as) {
      return as === void 0 ? function(as2) {
        return lookup(i, as2);
      } : (0, exports.isOutOfBound)(i, as) ? _.none : _.some(as[i]);
    }
    exports.lookup = lookup;
    var head = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(RNEA.head(as)) : _.none;
    };
    exports.head = head;
    var last = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(RNEA.last(as)) : _.none;
    };
    exports.last = last;
    var tail = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(RNEA.tail(as)) : _.none;
    };
    exports.tail = tail;
    var init = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(RNEA.init(as)) : _.none;
    };
    exports.init = init;
    var takeLeft = function(n) {
      return function(as) {
        return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(0, n);
      };
    };
    exports.takeLeft = takeLeft;
    var takeRight = function(n) {
      return function(as) {
        return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(-n);
      };
    };
    exports.takeRight = takeRight;
    function takeLeftWhile(predicate) {
      return function(as) {
        var out = [];
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
          var a = as_1[_i];
          if (!predicate(a)) {
            break;
          }
          out.push(a);
        }
        var len = out.length;
        return len === as.length ? as : len === 0 ? exports.empty : out;
      };
    }
    exports.takeLeftWhile = takeLeftWhile;
    var spanLeftIndex = function(as, predicate) {
      var l = as.length;
      var i = 0;
      for (; i < l; i++) {
        if (!predicate(as[i])) {
          break;
        }
      }
      return i;
    };
    function spanLeft(predicate) {
      return function(as) {
        var _a2 = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init2 = _a2[0], rest = _a2[1];
        return { init: init2, rest };
      };
    }
    exports.spanLeft = spanLeft;
    var dropLeft = function(n) {
      return function(as) {
        return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(n, as.length);
      };
    };
    exports.dropLeft = dropLeft;
    var dropRight = function(n) {
      return function(as) {
        return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(0, as.length - n);
      };
    };
    exports.dropRight = dropRight;
    function dropLeftWhile(predicate) {
      return function(as) {
        var i = spanLeftIndex(as, predicate);
        return i === 0 ? as : i === as.length ? exports.empty : as.slice(i);
      };
    }
    exports.dropLeftWhile = dropLeftWhile;
    var findIndex = function(predicate) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          if (predicate(as[i])) {
            return _.some(i);
          }
        }
        return _.none;
      };
    };
    exports.findIndex = findIndex;
    function findFirst(predicate) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          if (predicate(as[i])) {
            return _.some(as[i]);
          }
        }
        return _.none;
      };
    }
    exports.findFirst = findFirst;
    var findFirstMap = function(f2) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          var out = f2(as[i]);
          if (_.isSome(out)) {
            return out;
          }
        }
        return _.none;
      };
    };
    exports.findFirstMap = findFirstMap;
    function findLast(predicate) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          if (predicate(as[i])) {
            return _.some(as[i]);
          }
        }
        return _.none;
      };
    }
    exports.findLast = findLast;
    var findLastMap = function(f2) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          var out = f2(as[i]);
          if (_.isSome(out)) {
            return out;
          }
        }
        return _.none;
      };
    };
    exports.findLastMap = findLastMap;
    var findLastIndex = function(predicate) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          if (predicate(as[i])) {
            return _.some(i);
          }
        }
        return _.none;
      };
    };
    exports.findLastIndex = findLastIndex;
    var insertAt = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));
      };
    };
    exports.insertAt = insertAt;
    var updateAt = function(i, a) {
      return (0, exports.modifyAt)(i, function() {
        return a;
      });
    };
    exports.updateAt = updateAt;
    var deleteAt = function(i) {
      return function(as) {
        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
      };
    };
    exports.deleteAt = deleteAt;
    var modifyAt = function(i, f2) {
      return function(as) {
        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f2(as[i]), as));
      };
    };
    exports.modifyAt = modifyAt;
    var reverse = function(as) {
      return as.length <= 1 ? as : as.slice().reverse();
    };
    exports.reverse = reverse;
    var rights = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Right") {
          r.push(a.right);
        }
      }
      return r;
    };
    exports.rights = rights;
    var lefts = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Left") {
          r.push(a.left);
        }
      }
      return r;
    };
    exports.lefts = lefts;
    var sort = function(O) {
      return function(as) {
        return as.length <= 1 ? as : as.slice().sort(O.compare);
      };
    };
    exports.sort = sort;
    var zipWith = function(fa, fb, f2) {
      var fc = [];
      var len = Math.min(fa.length, fb.length);
      for (var i = 0; i < len; i++) {
        fc[i] = f2(fa[i], fb[i]);
      }
      return fc;
    };
    exports.zipWith = zipWith;
    function zip(as, bs) {
      if (bs === void 0) {
        return function(bs2) {
          return zip(bs2, as);
        };
      }
      return (0, exports.zipWith)(as, bs, function(a, b) {
        return [a, b];
      });
    }
    exports.zip = zip;
    var unzip = function(as) {
      var fa = [];
      var fb = [];
      for (var i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
      }
      return [fa, fb];
    };
    exports.unzip = unzip;
    var prependAll = function(middle) {
      var f2 = RNEA.prependAll(middle);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : as;
      };
    };
    exports.prependAll = prependAll;
    var intersperse = function(middle) {
      var f2 = RNEA.intersperse(middle);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : as;
      };
    };
    exports.intersperse = intersperse;
    var rotate = function(n) {
      var f2 = RNEA.rotate(n);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : as;
      };
    };
    exports.rotate = rotate;
    function elem(E) {
      return function(a, as) {
        if (as === void 0) {
          var elemE_1 = elem(E);
          return function(as2) {
            return elemE_1(a, as2);
          };
        }
        var predicate = function(element) {
          return E.equals(element, a);
        };
        var i = 0;
        for (; i < as.length; i++) {
          if (predicate(as[i])) {
            return true;
          }
        }
        return false;
      };
    }
    exports.elem = elem;
    var uniq = function(E) {
      var f2 = RNEA.uniq(E);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : as;
      };
    };
    exports.uniq = uniq;
    var sortBy = function(ords) {
      var f2 = RNEA.sortBy(ords);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : as;
      };
    };
    exports.sortBy = sortBy;
    var chop = function(f2) {
      var g = RNEA.chop(f2);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? g(as) : exports.empty;
      };
    };
    exports.chop = chop;
    var splitAt = function(n) {
      return function(as) {
        return n >= 1 && (0, exports.isNonEmpty)(as) ? RNEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [as, exports.empty] : [exports.empty, as];
      };
    };
    exports.splitAt = splitAt;
    var chunksOf = function(n) {
      var f2 = RNEA.chunksOf(n);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : exports.empty;
      };
    };
    exports.chunksOf = chunksOf;
    var fromOptionK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.fromOption)(f2.apply(void 0, a));
      };
    };
    exports.fromOptionK = fromOptionK;
    function comprehension(input, f2, g) {
      if (g === void 0) {
        g = function() {
          return true;
        };
      }
      var go = function(scope, input2) {
        return (0, exports.isNonEmpty)(input2) ? (0, exports.flatMap)(RNEA.head(input2), function(a) {
          return go((0, function_1.pipe)(scope, (0, exports.append)(a)), RNEA.tail(input2));
        }) : g.apply(void 0, scope) ? [f2.apply(void 0, scope)] : exports.empty;
      };
      return go(exports.empty, input);
    }
    exports.comprehension = comprehension;
    var concatW = function(second) {
      return function(first) {
        return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
      };
    };
    exports.concatW = concatW;
    exports.concat = exports.concatW;
    function union(E) {
      var unionE = RNEA.union(E);
      return function(first, second) {
        if (second === void 0) {
          var unionE_1 = union(E);
          return function(second2) {
            return unionE_1(second2, first);
          };
        }
        return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? first : second;
      };
    }
    exports.union = union;
    function intersection(E) {
      var elemE = elem(E);
      return function(xs, ys) {
        if (ys === void 0) {
          var intersectionE_1 = intersection(E);
          return function(ys2) {
            return intersectionE_1(ys2, xs);
          };
        }
        return xs.filter(function(a) {
          return elemE(a, ys);
        });
      };
    }
    exports.intersection = intersection;
    function difference(E) {
      var elemE = elem(E);
      return function(xs, ys) {
        if (ys === void 0) {
          var differenceE_1 = difference(E);
          return function(ys2) {
            return differenceE_1(ys2, xs);
          };
        }
        return xs.filter(function(a) {
          return !elemE(a, ys);
        });
      };
    }
    exports.difference = difference;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _mapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _filter2 = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
    };
    var _filterMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMap)(f2));
    };
    var _partition = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
    };
    var _partitionMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f2));
    };
    var _partitionWithIndex = function(fa, predicateWithIndex) {
      return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex));
    };
    var _partitionMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f2));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _reduceWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f2));
    };
    var _foldMapWithIndex = function(M) {
      var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapWithIndexM(f2));
      };
    };
    var _reduceRightWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f2));
    };
    var _filterMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f2));
    };
    var _filterWithIndex = function(fa, predicateWithIndex) {
      return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex));
    };
    var _extend = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.extend)(f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var _traverseWithIndex = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseWithIndexF(f2));
      };
    };
    var _chainRecDepthFirst = function(a, f2) {
      return (0, function_1.pipe)(a, (0, exports.chainRecDepthFirst)(f2));
    };
    exports._chainRecDepthFirst = _chainRecDepthFirst;
    var _chainRecBreadthFirst = function(a, f2) {
      return (0, function_1.pipe)(a, (0, exports.chainRecBreadthFirst)(f2));
    };
    exports._chainRecBreadthFirst = _chainRecBreadthFirst;
    exports.of = RNEA.of;
    var zero = function() {
      return exports.empty;
    };
    exports.zero = zero;
    var altW = function(that) {
      return function(fa) {
        return fa.concat(that());
      };
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    var ap = function(fa) {
      return (0, exports.flatMap)(function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    exports.ap = ap;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(i, a) {
        return f2(a, i);
      }));
    });
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    var map = function(f2) {
      return function(fa) {
        return fa.map(function(a) {
          return f2(a);
        });
      };
    };
    exports.map = map;
    var mapWithIndex = function(f2) {
      return function(fa) {
        return fa.map(function(a, i) {
          return f2(i, a);
        });
      };
    };
    exports.mapWithIndex = mapWithIndex;
    var separate = function(fa) {
      var left = [];
      var right = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left.push(e.left);
        } else {
          right.push(e.right);
        }
      }
      return (0, Separated_1.separated)(left, right);
    };
    exports.separate = separate;
    var filter2 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    exports.filter = filter2;
    var filterMapWithIndex = function(f2) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f2(i, fa[i]);
          if (_.isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    exports.filterMapWithIndex = filterMapWithIndex;
    var filterMap = function(f2) {
      return (0, exports.filterMapWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.filterMap = filterMap;
    exports.compact = (0, exports.filterMap)(function_1.identity);
    var partition = function(predicate) {
      return (0, exports.partitionWithIndex)(function(_2, a) {
        return predicate(a);
      });
    };
    exports.partition = partition;
    var partitionWithIndex = function(predicateWithIndex) {
      return function(as) {
        var left = [];
        var right = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (predicateWithIndex(i, a)) {
            right.push(a);
          } else {
            left.push(a);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    };
    exports.partitionWithIndex = partitionWithIndex;
    var partitionMap = function(f2) {
      return (0, exports.partitionMapWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.partitionMap = partitionMap;
    var partitionMapWithIndex = function(f2) {
      return function(fa) {
        var left = [];
        var right = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f2(i, fa[i]);
          if (e._tag === "Left") {
            left.push(e.left);
          } else {
            right.push(e.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    };
    exports.partitionMapWithIndex = partitionMapWithIndex;
    var filterWithIndex = function(predicateWithIndex) {
      return function(as) {
        return as.filter(function(a, i) {
          return predicateWithIndex(i, a);
        });
      };
    };
    exports.filterWithIndex = filterWithIndex;
    var extend = function(f2) {
      return function(wa) {
        return wa.map(function(_2, i) {
          return f2(wa.slice(i));
        });
      };
    };
    exports.extend = extend;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    var foldMapWithIndex = function(M) {
      return function(f2) {
        return function(fa) {
          return fa.reduce(function(b, a, i) {
            return M.concat(b, f2(i, a));
          }, M.empty);
        };
      };
    };
    exports.foldMapWithIndex = foldMapWithIndex;
    var reduce = function(b, f2) {
      return (0, exports.reduceWithIndex)(b, function(_2, b2, a) {
        return f2(b2, a);
      });
    };
    exports.reduce = reduce;
    var foldMap = function(M) {
      var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
      return function(f2) {
        return foldMapWithIndexM(function(_2, a) {
          return f2(a);
        });
      };
    };
    exports.foldMap = foldMap;
    var reduceWithIndex = function(b, f2) {
      return function(fa) {
        var len = fa.length;
        var out = b;
        for (var i = 0; i < len; i++) {
          out = f2(i, out, fa[i]);
        }
        return out;
      };
    };
    exports.reduceWithIndex = reduceWithIndex;
    var reduceRight = function(b, f2) {
      return (0, exports.reduceRightWithIndex)(b, function(_2, a, b2) {
        return f2(a, b2);
      });
    };
    exports.reduceRight = reduceRight;
    var reduceRightWithIndex = function(b, f2) {
      return function(fa) {
        return fa.reduceRight(function(b2, a, i) {
          return f2(i, a, b2);
        }, b);
      };
    };
    exports.reduceRightWithIndex = reduceRightWithIndex;
    var traverse = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(f2) {
        return traverseWithIndexF(function(_2, a) {
          return f2(a);
        });
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(ta) {
        return _reduce(ta, F.of((0, exports.zero)()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return (0, function_1.pipe)(as, (0, exports.append)(a));
            };
          }), fa);
        });
      };
    };
    exports.sequence = sequence;
    var traverseWithIndex = function(F) {
      return function(f2) {
        return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return (0, function_1.pipe)(bs, (0, exports.append)(b));
            };
          }), f2(i, a));
        });
      };
    };
    exports.traverseWithIndex = traverseWithIndex;
    var wither = function(F) {
      var _witherF = _wither(F);
      return function(f2) {
        return function(fa) {
          return _witherF(fa, f2);
        };
      };
    };
    exports.wither = wither;
    var wilt = function(F) {
      var _wiltF = _wilt(F);
      return function(f2) {
        return function(fa) {
          return _wiltF(fa, f2);
        };
      };
    };
    exports.wilt = wilt;
    var unfold = function(b, f2) {
      var out = [];
      var bb = b;
      while (true) {
        var mt = f2(bb);
        if (_.isSome(mt)) {
          var _a2 = mt.value, a = _a2[0], b_1 = _a2[1];
          out.push(a);
          bb = b_1;
        } else {
          break;
        }
      }
      return out;
    };
    exports.unfold = unfold;
    exports.URI = "ReadonlyArray";
    var getShow = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    exports.getShow = getShow;
    var getSemigroup = function() {
      return {
        concat: function(first, second) {
          return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
        }
      };
    };
    exports.getSemigroup = getSemigroup;
    var getMonoid = function() {
      return {
        concat: (0, exports.getSemigroup)().concat,
        empty: exports.empty
      };
    };
    exports.getMonoid = getMonoid;
    var getEq = function(E) {
      return (0, Eq_1.fromEquals)(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    exports.getEq = getEq;
    var getOrd = function(O) {
      return (0, Ord_1.fromCompare)(function(a, b) {
        var aLen = a.length;
        var bLen = b.length;
        var len = Math.min(aLen, bLen);
        for (var i = 0; i < len; i++) {
          var ordering = O.compare(a[i], b[i]);
          if (ordering !== 0) {
            return ordering;
          }
        }
        return N.Ord.compare(aLen, bLen);
      });
    };
    exports.getOrd = getOrd;
    var getUnionSemigroup = function(E) {
      var unionE = union(E);
      return {
        concat: function(first, second) {
          return unionE(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(E) {
      return {
        concat: (0, exports.getUnionSemigroup)(E).concat,
        empty: exports.empty
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(E) {
      var intersectionE = intersection(E);
      return {
        concat: function(first, second) {
          return intersectionE(second)(first);
        }
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function(E) {
      var differenceE = difference(E);
      return {
        concat: function(first, second) {
          return differenceE(second)(first);
        }
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.FunctorWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
    exports.Unfoldable = {
      URI: exports.URI,
      unfold: exports.unfold
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.Zero = {
      URI: exports.URI,
      zero: exports.zero
    };
    exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
    exports.Alternative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      alt: _alt,
      zero: exports.zero
    };
    exports.Extend = {
      URI: exports.URI,
      map: _map2,
      extend: _extend
    };
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    exports.FilterableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex
    };
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.FoldableWithIndex = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.TraversableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverse: _traverse,
      sequence: exports.sequence,
      traverseWithIndex: _traverseWithIndex
    };
    var chainRecDepthFirst = function(f2) {
      return function(a) {
        var todo = __spreadArray([], f2(a), true);
        var out = [];
        while (todo.length > 0) {
          var e = todo.shift();
          if (_.isLeft(e)) {
            todo.unshift.apply(todo, f2(e.left));
          } else {
            out.push(e.right);
          }
        }
        return out;
      };
    };
    exports.chainRecDepthFirst = chainRecDepthFirst;
    exports.ChainRecDepthFirst = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap,
      chainRec: exports._chainRecDepthFirst
    };
    var chainRecBreadthFirst = function(f2) {
      return function(a) {
        var initial = f2(a);
        var todo = [];
        var out = [];
        function go(e2) {
          if (_.isLeft(e2)) {
            f2(e2.left).forEach(function(v) {
              return todo.push(v);
            });
          } else {
            out.push(e2.right);
          }
        }
        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
          var e = initial_1[_i];
          go(e);
        }
        while (todo.length > 0) {
          go(todo.shift());
        }
        return out;
      };
    };
    exports.chainRecBreadthFirst = chainRecBreadthFirst;
    exports.ChainRecBreadthFirst = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap,
      chainRec: exports._chainRecBreadthFirst
    };
    var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
    var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
    exports.Witherable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      wither: _wither,
      wilt: _wilt
    };
    exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.unsafeInsertAt = RNEA.unsafeInsertAt;
    var unsafeUpdateAt = function(i, a, as) {
      return (0, exports.isNonEmpty)(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;
    };
    exports.unsafeUpdateAt = unsafeUpdateAt;
    var unsafeDeleteAt = function(i, as) {
      var xs = as.slice();
      xs.splice(i, 1);
      return xs;
    };
    exports.unsafeDeleteAt = unsafeDeleteAt;
    var toArray = function(as) {
      return as.slice();
    };
    exports.toArray = toArray;
    var fromArray = function(as) {
      return (0, exports.isEmpty)(as) ? exports.empty : as.slice();
    };
    exports.fromArray = fromArray;
    exports.empty = RNEA.empty;
    function every(predicate) {
      return function(as) {
        return as.every(predicate);
      };
    }
    exports.every = every;
    var some = function(predicate) {
      return function(as) {
        return as.some(predicate);
      };
    };
    exports.some = some;
    exports.exists = exports.some;
    var intercalate = function(M) {
      var intercalateM = RNEA.intercalate(M);
      return function(middle) {
        return (0, exports.match)(function() {
          return M.empty;
        }, intercalateM(middle));
      };
    };
    exports.intercalate = intercalate;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.chain = exports.flatMap;
    exports.range = RNEA.range;
    exports.cons = RNEA.cons;
    exports.snoc = RNEA.snoc;
    exports.prependToAll = exports.prependAll;
    exports.readonlyArray = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      mapWithIndex: _mapWithIndex,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex,
      alt: _alt,
      zero: exports.zero,
      unfold: exports.unfold,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex,
      extend: _extend,
      wither: _wither,
      wilt: _wilt
    };
  }
});

// node_modules/fp-ts/lib/Array.js
var require_Array = __commonJS({
  "node_modules/fp-ts/lib/Array.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.copy = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
    exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = exports.foldMapWithIndex = exports.foldMap = exports.duplicate = exports.extend = exports.filterWithIndex = exports.alt = exports.altW = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.filter = exports.separate = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.mapWithIndex = exports.flatten = exports.flatMap = exports.ap = exports.map = exports.zero = exports.of = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.sort = void 0;
    exports.some = exports.every = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = void 0;
    exports.array = exports.prependToAll = exports.snoc = exports.cons = exports.empty = exports.range = exports.chain = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = void 0;
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var NEA = __importStar(require_NonEmptyArray());
    var RA = __importStar(require_ReadonlyArray());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    var Zero_1 = require_Zero();
    var isEmpty = function(as) {
      return as.length === 0;
    };
    exports.isEmpty = isEmpty;
    exports.isNonEmpty = NEA.isNonEmpty;
    exports.prepend = NEA.prepend;
    exports.prependW = NEA.prependW;
    exports.append = NEA.append;
    exports.appendW = NEA.appendW;
    var makeBy = function(n, f2) {
      return n <= 0 ? [] : NEA.makeBy(f2)(n);
    };
    exports.makeBy = makeBy;
    var replicate = function(n, a) {
      return (0, exports.makeBy)(n, function() {
        return a;
      });
    };
    exports.replicate = replicate;
    function fromPredicate(predicate) {
      return function(a) {
        return predicate(a) ? [a] : [];
      };
    }
    exports.fromPredicate = fromPredicate;
    var fromOption = function(ma) {
      return _.isNone(ma) ? [] : [ma.value];
    };
    exports.fromOption = fromOption;
    var fromEither = function(e) {
      return _.isLeft(e) ? [] : [e.right];
    };
    exports.fromEither = fromEither;
    var matchW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    exports.matchW = matchW;
    exports.match = exports.matchW;
    var matchLeftW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty();
      };
    };
    exports.matchLeftW = matchLeftW;
    exports.matchLeft = exports.matchLeftW;
    exports.foldLeft = exports.matchLeft;
    var matchRightW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty();
      };
    };
    exports.matchRightW = matchRightW;
    exports.matchRight = exports.matchRightW;
    exports.foldRight = exports.matchRight;
    var chainWithIndex = function(f2) {
      return function(as) {
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f2(i, as[i]));
        }
        return out;
      };
    };
    exports.chainWithIndex = chainWithIndex;
    var scanLeft = function(b, f2) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
          out[i + 1] = f2(out[i], as[i]);
        }
        return out;
      };
    };
    exports.scanLeft = scanLeft;
    var scanRight = function(b, f2) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
          out[i] = f2(as[i], out[i + 1]);
        }
        return out;
      };
    };
    exports.scanRight = scanRight;
    var size = function(as) {
      return as.length;
    };
    exports.size = size;
    exports.isOutOfBound = NEA.isOutOfBound;
    exports.lookup = RA.lookup;
    exports.head = RA.head;
    exports.last = RA.last;
    var tail = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(NEA.tail(as)) : _.none;
    };
    exports.tail = tail;
    var init = function(as) {
      return (0, exports.isNonEmpty)(as) ? _.some(NEA.init(as)) : _.none;
    };
    exports.init = init;
    var takeLeft = function(n) {
      return function(as) {
        return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : as.slice(0, n);
      };
    };
    exports.takeLeft = takeLeft;
    var takeRight = function(n) {
      return function(as) {
        return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : n === 0 ? [] : as.slice(-n);
      };
    };
    exports.takeRight = takeRight;
    function takeLeftWhile(predicate) {
      return function(as) {
        var out = [];
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
          var a = as_1[_i];
          if (!predicate(a)) {
            break;
          }
          out.push(a);
        }
        return out;
      };
    }
    exports.takeLeftWhile = takeLeftWhile;
    var spanLeftIndex = function(as, predicate) {
      var l = as.length;
      var i = 0;
      for (; i < l; i++) {
        if (!predicate(as[i])) {
          break;
        }
      }
      return i;
    };
    function spanLeft(predicate) {
      return function(as) {
        var _a2 = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init2 = _a2[0], rest = _a2[1];
        return { init: init2, rest };
      };
    }
    exports.spanLeft = spanLeft;
    var dropLeft = function(n) {
      return function(as) {
        return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(n, as.length);
      };
    };
    exports.dropLeft = dropLeft;
    var dropRight = function(n) {
      return function(as) {
        return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(0, as.length - n);
      };
    };
    exports.dropRight = dropRight;
    function dropLeftWhile(predicate) {
      return function(as) {
        return as.slice(spanLeftIndex(as, predicate));
      };
    }
    exports.dropLeftWhile = dropLeftWhile;
    exports.findIndex = RA.findIndex;
    function findFirst(predicate) {
      return RA.findFirst(predicate);
    }
    exports.findFirst = findFirst;
    exports.findFirstMap = RA.findFirstMap;
    function findLast(predicate) {
      return RA.findLast(predicate);
    }
    exports.findLast = findLast;
    exports.findLastMap = RA.findLastMap;
    exports.findLastIndex = RA.findLastIndex;
    var copy = function(as) {
      return as.slice();
    };
    exports.copy = copy;
    var insertAt = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
      };
    };
    exports.insertAt = insertAt;
    var updateAt = function(i, a) {
      return (0, exports.modifyAt)(i, function() {
        return a;
      });
    };
    exports.updateAt = updateAt;
    var deleteAt = function(i) {
      return function(as) {
        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
      };
    };
    exports.deleteAt = deleteAt;
    var modifyAt = function(i, f2) {
      return function(as) {
        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f2(as[i]), as));
      };
    };
    exports.modifyAt = modifyAt;
    var reverse = function(as) {
      return (0, exports.isEmpty)(as) ? [] : as.slice().reverse();
    };
    exports.reverse = reverse;
    var rights = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Right") {
          r.push(a.right);
        }
      }
      return r;
    };
    exports.rights = rights;
    var lefts = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Left") {
          r.push(a.left);
        }
      }
      return r;
    };
    exports.lefts = lefts;
    var sort = function(O) {
      return function(as) {
        return as.length <= 1 ? (0, exports.copy)(as) : as.slice().sort(O.compare);
      };
    };
    exports.sort = sort;
    var zipWith = function(fa, fb, f2) {
      var fc = [];
      var len = Math.min(fa.length, fb.length);
      for (var i = 0; i < len; i++) {
        fc[i] = f2(fa[i], fb[i]);
      }
      return fc;
    };
    exports.zipWith = zipWith;
    function zip(as, bs) {
      if (bs === void 0) {
        return function(bs2) {
          return zip(bs2, as);
        };
      }
      return (0, exports.zipWith)(as, bs, function(a, b) {
        return [a, b];
      });
    }
    exports.zip = zip;
    var unzip = function(as) {
      var fa = [];
      var fb = [];
      for (var i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
      }
      return [fa, fb];
    };
    exports.unzip = unzip;
    var prependAll = function(middle) {
      var f2 = NEA.prependAll(middle);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : [];
      };
    };
    exports.prependAll = prependAll;
    var intersperse = function(middle) {
      var f2 = NEA.intersperse(middle);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : (0, exports.copy)(as);
      };
    };
    exports.intersperse = intersperse;
    var rotate = function(n) {
      var f2 = NEA.rotate(n);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : (0, exports.copy)(as);
      };
    };
    exports.rotate = rotate;
    exports.elem = RA.elem;
    var uniq = function(E) {
      var f2 = NEA.uniq(E);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : (0, exports.copy)(as);
      };
    };
    exports.uniq = uniq;
    var sortBy = function(ords) {
      var f2 = NEA.sortBy(ords);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : (0, exports.copy)(as);
      };
    };
    exports.sortBy = sortBy;
    var chop = function(f2) {
      var g = NEA.chop(f2);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? g(as) : [];
      };
    };
    exports.chop = chop;
    var splitAt = function(n) {
      return function(as) {
        return n >= 1 && (0, exports.isNonEmpty)(as) ? NEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [(0, exports.copy)(as), []] : [[], (0, exports.copy)(as)];
      };
    };
    exports.splitAt = splitAt;
    var chunksOf = function(n) {
      var f2 = NEA.chunksOf(n);
      return function(as) {
        return (0, exports.isNonEmpty)(as) ? f2(as) : [];
      };
    };
    exports.chunksOf = chunksOf;
    var fromOptionK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.fromOption)(f2.apply(void 0, a));
      };
    };
    exports.fromOptionK = fromOptionK;
    function comprehension(input, f2, g) {
      if (g === void 0) {
        g = function() {
          return true;
        };
      }
      var go = function(scope, input2) {
        return (0, exports.isNonEmpty)(input2) ? (0, exports.flatMap)(NEA.head(input2), function(a) {
          return go((0, function_1.pipe)(scope, (0, exports.append)(a)), NEA.tail(input2));
        }) : g.apply(void 0, scope) ? [f2.apply(void 0, scope)] : [];
      };
      return go([], input);
    }
    exports.comprehension = comprehension;
    var concatW = function(second) {
      return function(first) {
        return (0, exports.isEmpty)(first) ? (0, exports.copy)(second) : (0, exports.isEmpty)(second) ? (0, exports.copy)(first) : first.concat(second);
      };
    };
    exports.concatW = concatW;
    exports.concat = exports.concatW;
    function union(E) {
      var unionE = NEA.union(E);
      return function(first, second) {
        if (second === void 0) {
          var unionE_1 = union(E);
          return function(second2) {
            return unionE_1(second2, first);
          };
        }
        return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? (0, exports.copy)(first) : (0, exports.copy)(second);
      };
    }
    exports.union = union;
    function intersection(E) {
      var elemE = (0, exports.elem)(E);
      return function(xs, ys) {
        if (ys === void 0) {
          var intersectionE_1 = intersection(E);
          return function(ys2) {
            return intersectionE_1(ys2, xs);
          };
        }
        return xs.filter(function(a) {
          return elemE(a, ys);
        });
      };
    }
    exports.intersection = intersection;
    function difference(E) {
      var elemE = (0, exports.elem)(E);
      return function(xs, ys) {
        if (ys === void 0) {
          var differenceE_1 = difference(E);
          return function(ys2) {
            return differenceE_1(ys2, xs);
          };
        }
        return xs.filter(function(a) {
          return !elemE(a, ys);
        });
      };
    }
    exports.difference = difference;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _mapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _filter2 = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
    };
    var _filterMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMap)(f2));
    };
    var _partition = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
    };
    var _partitionMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f2));
    };
    var _partitionWithIndex = function(fa, predicateWithIndex) {
      return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex));
    };
    var _partitionMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f2));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _reduceWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f2));
    };
    var _foldMapWithIndex = function(M) {
      var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapWithIndexM(f2));
      };
    };
    var _reduceRightWithIndex = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f2));
    };
    var _filterMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f2));
    };
    var _filterWithIndex = function(fa, predicateWithIndex) {
      return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex));
    };
    var _extend = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.extend)(f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var _traverseWithIndex = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseWithIndexF(f2));
      };
    };
    var _chainRecDepthFirst = RA._chainRecDepthFirst;
    var _chainRecBreadthFirst = RA._chainRecBreadthFirst;
    exports.of = NEA.of;
    var zero = function() {
      return [];
    };
    exports.zero = zero;
    var map = function(f2) {
      return function(fa) {
        return fa.map(function(a) {
          return f2(a);
        });
      };
    };
    exports.map = map;
    var ap = function(fa) {
      return (0, exports.flatMap)(function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    exports.ap = ap;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(i, a) {
        return f2(a, i);
      }));
    });
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    var mapWithIndex = function(f2) {
      return function(fa) {
        return fa.map(function(a, i) {
          return f2(i, a);
        });
      };
    };
    exports.mapWithIndex = mapWithIndex;
    var filterMapWithIndex = function(f2) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f2(i, fa[i]);
          if (_.isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    exports.filterMapWithIndex = filterMapWithIndex;
    var filterMap = function(f2) {
      return (0, exports.filterMapWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.filterMap = filterMap;
    exports.compact = (0, exports.filterMap)(function_1.identity);
    var separate = function(fa) {
      var left = [];
      var right = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left.push(e.left);
        } else {
          right.push(e.right);
        }
      }
      return (0, Separated_1.separated)(left, right);
    };
    exports.separate = separate;
    var filter2 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    exports.filter = filter2;
    var partition = function(predicate) {
      return (0, exports.partitionWithIndex)(function(_2, a) {
        return predicate(a);
      });
    };
    exports.partition = partition;
    var partitionWithIndex = function(predicateWithIndex) {
      return function(as) {
        var left = [];
        var right = [];
        for (var i = 0; i < as.length; i++) {
          var b = as[i];
          if (predicateWithIndex(i, b)) {
            right.push(b);
          } else {
            left.push(b);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    };
    exports.partitionWithIndex = partitionWithIndex;
    var partitionMap = function(f2) {
      return (0, exports.partitionMapWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.partitionMap = partitionMap;
    var partitionMapWithIndex = function(f2) {
      return function(fa) {
        var left = [];
        var right = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f2(i, fa[i]);
          if (e._tag === "Left") {
            left.push(e.left);
          } else {
            right.push(e.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    };
    exports.partitionMapWithIndex = partitionMapWithIndex;
    var altW = function(that) {
      return function(fa) {
        return fa.concat(that());
      };
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    var filterWithIndex = function(predicateWithIndex) {
      return function(as) {
        return as.filter(function(b, i) {
          return predicateWithIndex(i, b);
        });
      };
    };
    exports.filterWithIndex = filterWithIndex;
    var extend = function(f2) {
      return function(wa) {
        return wa.map(function(_2, i) {
          return f2(wa.slice(i));
        });
      };
    };
    exports.extend = extend;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.foldMap = RA.foldMap;
    exports.foldMapWithIndex = RA.foldMapWithIndex;
    exports.reduce = RA.reduce;
    exports.reduceWithIndex = RA.reduceWithIndex;
    exports.reduceRight = RA.reduceRight;
    exports.reduceRightWithIndex = RA.reduceRightWithIndex;
    var traverse = function(F) {
      var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
      return function(f2) {
        return traverseWithIndexF(function(_2, a) {
          return f2(a);
        });
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(ta) {
        return _reduce(ta, F.of((0, exports.zero)()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return (0, function_1.pipe)(as, (0, exports.append)(a));
            };
          }), fa);
        });
      };
    };
    exports.sequence = sequence;
    var traverseWithIndex = function(F) {
      return function(f2) {
        return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return (0, function_1.pipe)(bs, (0, exports.append)(b));
            };
          }), f2(i, a));
        });
      };
    };
    exports.traverseWithIndex = traverseWithIndex;
    var wither = function(F) {
      var _witherF = _wither(F);
      return function(f2) {
        return function(fa) {
          return _witherF(fa, f2);
        };
      };
    };
    exports.wither = wither;
    var wilt = function(F) {
      var _wiltF = _wilt(F);
      return function(f2) {
        return function(fa) {
          return _wiltF(fa, f2);
        };
      };
    };
    exports.wilt = wilt;
    var unfold = function(b, f2) {
      var out = [];
      var bb = b;
      while (true) {
        var mt = f2(bb);
        if (_.isSome(mt)) {
          var _a2 = mt.value, a = _a2[0], b_1 = _a2[1];
          out.push(a);
          bb = b_1;
        } else {
          break;
        }
      }
      return out;
    };
    exports.unfold = unfold;
    exports.URI = "Array";
    exports.getShow = RA.getShow;
    var getSemigroup = function() {
      return {
        concat: function(first, second) {
          return first.concat(second);
        }
      };
    };
    exports.getSemigroup = getSemigroup;
    var getMonoid = function() {
      return {
        concat: (0, exports.getSemigroup)().concat,
        empty: []
      };
    };
    exports.getMonoid = getMonoid;
    exports.getEq = RA.getEq;
    exports.getOrd = RA.getOrd;
    var getUnionSemigroup = function(E) {
      var unionE = union(E);
      return {
        concat: function(first, second) {
          return unionE(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(E) {
      return {
        concat: (0, exports.getUnionSemigroup)(E).concat,
        empty: []
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(E) {
      var intersectionE = intersection(E);
      return {
        concat: function(first, second) {
          return intersectionE(second)(first);
        }
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function(E) {
      var differenceE = difference(E);
      return {
        concat: function(first, second) {
          return differenceE(second)(first);
        }
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.FunctorWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.Unfoldable = {
      URI: exports.URI,
      unfold: exports.unfold
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.Zero = {
      URI: exports.URI,
      zero: exports.zero
    };
    exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
    exports.Alternative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      alt: _alt,
      zero: exports.zero
    };
    exports.Extend = {
      URI: exports.URI,
      map: _map2,
      extend: _extend
    };
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    exports.FilterableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex
    };
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.FoldableWithIndex = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.TraversableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverse: _traverse,
      sequence: exports.sequence,
      traverseWithIndex: _traverseWithIndex
    };
    var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
    var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
    exports.Witherable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      wither: _wither,
      wilt: _wilt
    };
    exports.chainRecDepthFirst = RA.chainRecDepthFirst;
    exports.ChainRecDepthFirst = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap,
      chainRec: _chainRecDepthFirst
    };
    exports.chainRecBreadthFirst = RA.chainRecBreadthFirst;
    exports.ChainRecBreadthFirst = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap,
      chainRec: _chainRecBreadthFirst
    };
    exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.unsafeInsertAt = NEA.unsafeInsertAt;
    var unsafeUpdateAt = function(i, a, as) {
      return (0, exports.isNonEmpty)(as) ? NEA.unsafeUpdateAt(i, a, as) : [];
    };
    exports.unsafeUpdateAt = unsafeUpdateAt;
    var unsafeDeleteAt = function(i, as) {
      var xs = as.slice();
      xs.splice(i, 1);
      return xs;
    };
    exports.unsafeDeleteAt = unsafeDeleteAt;
    exports.every = RA.every;
    var some = function(predicate) {
      return function(as) {
        return as.some(predicate);
      };
    };
    exports.some = some;
    exports.exists = exports.some;
    exports.intercalate = RA.intercalate;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.chain = exports.flatMap;
    exports.range = NEA.range;
    exports.empty = [];
    exports.cons = NEA.cons;
    exports.snoc = NEA.snoc;
    exports.prependToAll = exports.prependAll;
    exports.array = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      mapWithIndex: _mapWithIndex,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex,
      alt: _alt,
      zero: exports.zero,
      unfold: exports.unfold,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex,
      extend: _extend,
      wither: _wither,
      wilt: _wilt
    };
  }
});

// node_modules/fp-ts/lib/Bifunctor.js
var require_Bifunctor = __commonJS({
  "node_modules/fp-ts/lib/Bifunctor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/boolean.js
var require_boolean = __commonJS({
  "node_modules/fp-ts/lib/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Show = exports.Ord = exports.MonoidAny = exports.MonoidAll = exports.SemigroupAny = exports.SemigroupAll = exports.BooleanAlgebra = exports.Eq = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isBoolean = void 0;
    var isBoolean = function(u) {
      return typeof u === "boolean";
    };
    exports.isBoolean = isBoolean;
    var matchW = function(onFalse, onTrue) {
      return function(value) {
        return value ? onTrue() : onFalse();
      };
    };
    exports.matchW = matchW;
    exports.foldW = exports.matchW;
    exports.match = exports.foldW;
    exports.fold = exports.match;
    exports.Eq = {
      equals: function(first, second) {
        return first === second;
      }
    };
    exports.BooleanAlgebra = {
      meet: function(first, second) {
        return first && second;
      },
      join: function(first, second) {
        return first || second;
      },
      zero: false,
      one: true,
      implies: function(first, second) {
        return !first || second;
      },
      not: function(b) {
        return !b;
      }
    };
    exports.SemigroupAll = {
      concat: function(first, second) {
        return first && second;
      }
    };
    exports.SemigroupAny = {
      concat: function(first, second) {
        return first || second;
      }
    };
    exports.MonoidAll = {
      concat: exports.SemigroupAll.concat,
      empty: true
    };
    exports.MonoidAny = {
      concat: exports.SemigroupAny.concat,
      empty: false
    };
    exports.Ord = {
      equals: exports.Eq.equals,
      compare: function(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
      }
    };
    exports.Show = {
      show: function(b) {
        return JSON.stringify(b);
      }
    };
  }
});

// node_modules/fp-ts/lib/BooleanAlgebra.js
var require_BooleanAlgebra = __commonJS({
  "node_modules/fp-ts/lib/BooleanAlgebra.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionBooleanAlgebra = exports.booleanAlgebraBoolean = exports.getDualBooleanAlgebra = exports.booleanAlgebraVoid = exports.reverse = void 0;
    var function_1 = require_function();
    var reverse = function(B) {
      return {
        meet: function(x, y) {
          return B.join(x, y);
        },
        join: function(x, y) {
          return B.meet(x, y);
        },
        zero: B.one,
        one: B.zero,
        implies: function(x, y) {
          return B.join(B.not(x), y);
        },
        not: B.not
      };
    };
    exports.reverse = reverse;
    exports.booleanAlgebraVoid = {
      meet: function() {
        return void 0;
      },
      join: function() {
        return void 0;
      },
      zero: void 0,
      one: void 0,
      implies: function() {
        return void 0;
      },
      not: function() {
        return void 0;
      }
    };
    exports.getDualBooleanAlgebra = exports.reverse;
    exports.booleanAlgebraBoolean = {
      meet: function(x, y) {
        return x && y;
      },
      join: function(x, y) {
        return x || y;
      },
      zero: false,
      one: true,
      implies: function(x, y) {
        return !x || y;
      },
      not: function(x) {
        return !x;
      }
    };
    exports.getFunctionBooleanAlgebra = function_1.getBooleanAlgebra;
  }
});

// node_modules/fp-ts/lib/Bounded.js
var require_Bounded = __commonJS({
  "node_modules/fp-ts/lib/Bounded.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boundedNumber = exports.reverse = exports.clamp = void 0;
    var O = __importStar(require_Ord());
    var clamp = function(B) {
      return O.clamp(B)(B.bottom, B.top);
    };
    exports.clamp = clamp;
    var reverse = function(B) {
      var R = O.reverse(B);
      return {
        equals: R.equals,
        compare: R.compare,
        top: B.bottom,
        bottom: B.top
      };
    };
    exports.reverse = reverse;
    exports.boundedNumber = {
      equals: O.ordNumber.equals,
      compare: O.ordNumber.compare,
      top: Infinity,
      bottom: -Infinity
    };
  }
});

// node_modules/fp-ts/lib/DistributiveLattice.js
var require_DistributiveLattice = __commonJS({
  "node_modules/fp-ts/lib/DistributiveLattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMinMaxDistributiveLattice = void 0;
    var Ord_1 = require_Ord();
    function getMinMaxDistributiveLattice(O) {
      return {
        meet: (0, Ord_1.min)(O),
        join: (0, Ord_1.max)(O)
      };
    }
    exports.getMinMaxDistributiveLattice = getMinMaxDistributiveLattice;
  }
});

// node_modules/fp-ts/lib/BoundedDistributiveLattice.js
var require_BoundedDistributiveLattice = __commonJS({
  "node_modules/fp-ts/lib/BoundedDistributiveLattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMinMaxBoundedDistributiveLattice = void 0;
    var DistributiveLattice_1 = require_DistributiveLattice();
    function getMinMaxBoundedDistributiveLattice(O) {
      var L = (0, DistributiveLattice_1.getMinMaxDistributiveLattice)(O);
      return function(min, max) {
        return {
          join: L.join,
          meet: L.meet,
          zero: min,
          one: max
        };
      };
    }
    exports.getMinMaxBoundedDistributiveLattice = getMinMaxBoundedDistributiveLattice;
  }
});

// node_modules/fp-ts/lib/BoundedJoinSemilattice.js
var require_BoundedJoinSemilattice = __commonJS({
  "node_modules/fp-ts/lib/BoundedJoinSemilattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/BoundedLattice.js
var require_BoundedLattice = __commonJS({
  "node_modules/fp-ts/lib/BoundedLattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/BoundedMeetSemilattice.js
var require_BoundedMeetSemilattice = __commonJS({
  "node_modules/fp-ts/lib/BoundedMeetSemilattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Category.js
var require_Category = __commonJS({
  "node_modules/fp-ts/lib/Category.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/ChainRec.js
var require_ChainRec = __commonJS({
  "node_modules/fp-ts/lib/ChainRec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tailRec = void 0;
    var tailRec = function(startWith, f2) {
      var ab = f2(startWith);
      while (ab._tag === "Left") {
        ab = f2(ab.left);
      }
      return ab.right;
    };
    exports.tailRec = tailRec;
  }
});

// node_modules/fp-ts/lib/Choice.js
var require_Choice = __commonJS({
  "node_modules/fp-ts/lib/Choice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fanin = exports.splitChoice = exports.fanIn = exports.split = void 0;
    var function_1 = require_function();
    function split(P, C) {
      return function(pab, pcd) {
        return C.compose(P.right(pcd), P.left(pab));
      };
    }
    exports.split = split;
    function fanIn(P, C) {
      var splitPC = split(P, C);
      return function(pac, pbc) {
        return C.compose(P.promap(C.id(), function(cc) {
          return cc._tag === "Left" ? cc.left : cc.right;
        }, function_1.identity), splitPC(pac, pbc));
      };
    }
    exports.fanIn = fanIn;
    function splitChoice(F) {
      return split(F, F);
    }
    exports.splitChoice = splitChoice;
    function fanin(F) {
      return fanIn(F, F);
    }
    exports.fanin = fanin;
  }
});

// node_modules/fp-ts/lib/Comonad.js
var require_Comonad = __commonJS({
  "node_modules/fp-ts/lib/Comonad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Predicate.js
var require_Predicate = __commonJS({
  "node_modules/fp-ts/lib/Predicate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;
    var function_1 = require_function();
    var contramap_ = function(predicate, f2) {
      return (0, function_1.pipe)(predicate, (0, exports.contramap)(f2));
    };
    var contramap = function(f2) {
      return function(predicate) {
        return (0, function_1.flow)(f2, predicate);
      };
    };
    exports.contramap = contramap;
    exports.URI = "Predicate";
    var getSemigroupAny = function() {
      return {
        concat: function(first, second) {
          return (0, function_1.pipe)(first, (0, exports.or)(second));
        }
      };
    };
    exports.getSemigroupAny = getSemigroupAny;
    var getMonoidAny = function() {
      return {
        concat: (0, exports.getSemigroupAny)().concat,
        empty: function_1.constFalse
      };
    };
    exports.getMonoidAny = getMonoidAny;
    var getSemigroupAll = function() {
      return {
        concat: function(first, second) {
          return (0, function_1.pipe)(first, (0, exports.and)(second));
        }
      };
    };
    exports.getSemigroupAll = getSemigroupAll;
    var getMonoidAll = function() {
      return {
        concat: (0, exports.getSemigroupAll)().concat,
        empty: function_1.constTrue
      };
    };
    exports.getMonoidAll = getMonoidAll;
    exports.Contravariant = {
      URI: exports.URI,
      contramap: contramap_
    };
    var not = function(predicate) {
      return function(a) {
        return !predicate(a);
      };
    };
    exports.not = not;
    var or = function(second) {
      return function(first) {
        return function(a) {
          return first(a) || second(a);
        };
      };
    };
    exports.or = or;
    var and = function(second) {
      return function(first) {
        return function(a) {
          return first(a) && second(a);
        };
      };
    };
    exports.and = and;
  }
});

// node_modules/fp-ts/lib/Option.js
var require_Option = __commonJS({
  "node_modules/fp-ts/lib/Option.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.orElse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.flatMap = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;
    exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.chainFirst = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.tapEither = exports.tap = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = exports.fromEither = exports.MonadThrow = exports.throwError = void 0;
    exports.getLastMonoid = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Predicate_1 = require_Predicate();
    var Semigroup_1 = require_Semigroup();
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    var Zero_1 = require_Zero();
    exports.none = _.none;
    exports.some = _.some;
    function fromPredicate(predicate) {
      return function(a) {
        return predicate(a) ? (0, exports.some)(a) : exports.none;
      };
    }
    exports.fromPredicate = fromPredicate;
    var getLeft = function(ma) {
      return ma._tag === "Right" ? exports.none : (0, exports.some)(ma.left);
    };
    exports.getLeft = getLeft;
    var getRight = function(ma) {
      return ma._tag === "Left" ? exports.none : (0, exports.some)(ma.right);
    };
    exports.getRight = getRight;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _filter2 = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
    };
    var _filterMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMap)(f2));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _partition = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
    };
    var _partitionMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f2));
    };
    exports.URI = "Option";
    var getShow = function(S) {
      return {
        show: function(ma) {
          return (0, exports.isNone)(ma) ? "none" : "some(".concat(S.show(ma.value), ")");
        }
      };
    };
    exports.getShow = getShow;
    var getEq = function(E) {
      return {
        equals: function(x, y) {
          return x === y || ((0, exports.isNone)(x) ? (0, exports.isNone)(y) : (0, exports.isNone)(y) ? false : E.equals(x.value, y.value));
        }
      };
    };
    exports.getEq = getEq;
    var getOrd = function(O) {
      return {
        equals: (0, exports.getEq)(O).equals,
        compare: function(x, y) {
          return x === y ? 0 : (0, exports.isSome)(x) ? (0, exports.isSome)(y) ? O.compare(x.value, y.value) : 1 : -1;
        }
      };
    };
    exports.getOrd = getOrd;
    var getMonoid = function(S) {
      return {
        concat: function(x, y) {
          return (0, exports.isNone)(x) ? y : (0, exports.isNone)(y) ? x : (0, exports.some)(S.concat(x.value, y.value));
        },
        empty: exports.none
      };
    };
    exports.getMonoid = getMonoid;
    var map = function(f2) {
      return function(fa) {
        return (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(f2(fa.value));
      };
    };
    exports.map = map;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.of = exports.some;
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    var ap = function(fa) {
      return function(fab) {
        return (0, exports.isNone)(fab) ? exports.none : (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(fab.value(fa.value));
      };
    };
    exports.ap = ap;
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return (0, exports.isNone)(ma) ? exports.none : f2(ma.value);
    });
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    var reduce = function(b, f2) {
      return function(fa) {
        return (0, exports.isNone)(fa) ? b : f2(b, fa.value);
      };
    };
    exports.reduce = reduce;
    var foldMap = function(M) {
      return function(f2) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? M.empty : f2(fa.value);
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f2) {
      return function(fa) {
        return (0, exports.isNone)(fa) ? b : f2(fa.value, b);
      };
    };
    exports.reduceRight = reduceRight;
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.orElse = (0, function_1.dual)(2, function(self, that) {
      return (0, exports.isNone)(self) ? that() : self;
    });
    exports.altW = exports.orElse;
    exports.alt = exports.orElse;
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    var zero = function() {
      return exports.none;
    };
    exports.zero = zero;
    exports.Zero = {
      URI: exports.URI,
      zero: exports.zero
    };
    exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
    exports.Alternative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      alt: _alt,
      zero: exports.zero
    };
    var extend = function(f2) {
      return function(wa) {
        return (0, exports.isNone)(wa) ? exports.none : (0, exports.some)(f2(wa));
      };
    };
    exports.extend = extend;
    exports.Extend = {
      URI: exports.URI,
      map: _map2,
      extend: _extend
    };
    exports.compact = (0, exports.flatMap)(function_1.identity);
    var defaultSeparated = /* @__PURE__ */ (0, Separated_1.separated)(exports.none, exports.none);
    var separate = function(ma) {
      return (0, exports.isNone)(ma) ? defaultSeparated : (0, Separated_1.separated)((0, exports.getLeft)(ma.value), (0, exports.getRight)(ma.value));
    };
    exports.separate = separate;
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    var filter2 = function(predicate) {
      return function(fa) {
        return (0, exports.isNone)(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;
      };
    };
    exports.filter = filter2;
    var filterMap = function(f2) {
      return function(fa) {
        return (0, exports.isNone)(fa) ? exports.none : f2(fa.value);
      };
    };
    exports.filterMap = filterMap;
    var partition = function(predicate) {
      return function(fa) {
        return (0, Separated_1.separated)(_filter2(fa, (0, Predicate_1.not)(predicate)), _filter2(fa, predicate));
      };
    };
    exports.partition = partition;
    var partitionMap = function(f2) {
      return (0, function_1.flow)((0, exports.map)(f2), exports.separate);
    };
    exports.partitionMap = partitionMap;
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    var traverse = function(F) {
      return function(f2) {
        return function(ta) {
          return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(f2(ta.value), exports.some);
        };
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(ta) {
        return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);
      };
    };
    exports.sequence = sequence;
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
    var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
    var wither = function(F) {
      var _witherF = _wither(F);
      return function(f2) {
        return function(fa) {
          return _witherF(fa, f2);
        };
      };
    };
    exports.wither = wither;
    var wilt = function(F) {
      var _wiltF = _wilt(F);
      return function(f2) {
        return function(fa) {
          return _wiltF(fa, f2);
        };
      };
    };
    exports.wilt = wilt;
    exports.Witherable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      wither: _wither,
      wilt: _wilt
    };
    var throwError = function() {
      return exports.none;
    };
    exports.throwError = throwError;
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      throwError: exports.throwError
    };
    exports.fromEither = exports.getRight;
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.isSome = _.isSome;
    var isNone = function(fa) {
      return fa._tag === "None";
    };
    exports.isNone = isNone;
    var matchW = function(onNone, onSome) {
      return function(ma) {
        return (0, exports.isNone)(ma) ? onNone() : onSome(ma.value);
      };
    };
    exports.matchW = matchW;
    exports.foldW = exports.matchW;
    exports.match = exports.matchW;
    exports.fold = exports.match;
    var getOrElseW = function(onNone) {
      return function(ma) {
        return (0, exports.isNone)(ma) ? onNone() : ma.value;
      };
    };
    exports.getOrElseW = getOrElseW;
    exports.getOrElse = exports.getOrElseW;
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.flatten = exports.compact;
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.chainEitherK = /* @__PURE__ */ (0, FromEither_1.chainEitherK)(exports.FromEither, exports.Chain);
    exports.chainFirstEitherK = exports.tapEither;
    var fromNullable = function(a) {
      return a == null ? exports.none : (0, exports.some)(a);
    };
    exports.fromNullable = fromNullable;
    var tryCatch = function(f2) {
      try {
        return (0, exports.some)(f2());
      } catch (e) {
        return exports.none;
      }
    };
    exports.tryCatch = tryCatch;
    var tryCatchK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f2.apply(void 0, a);
        });
      };
    };
    exports.tryCatchK = tryCatchK;
    var fromNullableK = function(f2) {
      return (0, function_1.flow)(f2, exports.fromNullable);
    };
    exports.fromNullableK = fromNullableK;
    var chainNullableK = function(f2) {
      return function(ma) {
        return (0, exports.isNone)(ma) ? exports.none : (0, exports.fromNullable)(f2(ma.value));
      };
    };
    exports.chainNullableK = chainNullableK;
    exports.toNullable = (0, exports.match)(function_1.constNull, function_1.identity);
    exports.toUndefined = (0, exports.match)(function_1.constUndefined, function_1.identity);
    function elem(E) {
      return function(a, ma) {
        if (ma === void 0) {
          var elemE_1 = elem(E);
          return function(ma2) {
            return elemE_1(a, ma2);
          };
        }
        return (0, exports.isNone)(ma) ? false : E.equals(a, ma.value);
      };
    }
    exports.elem = elem;
    var exists = function(predicate) {
      return function(ma) {
        return (0, exports.isNone)(ma) ? false : predicate(ma.value);
      };
    };
    exports.exists = exists;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return function(as) {
        var o = f2(0, _.head(as));
        if ((0, exports.isNone)(o)) {
          return exports.none;
        }
        var out = [o.value];
        for (var i = 1; i < as.length; i++) {
          var o_1 = f2(i, as[i]);
          if ((0, exports.isNone)(o_1)) {
            return exports.none;
          }
          out.push(o_1.value);
        }
        return (0, exports.some)(out);
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
    function getRefinement(getOption) {
      return function(a) {
        return (0, exports.isSome)(getOption(a));
      };
    }
    exports.getRefinement = getRefinement;
    exports.mapNullable = exports.chainNullableK;
    exports.option = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      zero: exports.zero,
      alt: _alt,
      extend: _extend,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      wither: _wither,
      wilt: _wilt,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
    var getFirstMonoid = function() {
      return (0, exports.getMonoid)((0, Semigroup_1.first)());
    };
    exports.getFirstMonoid = getFirstMonoid;
    var getLastMonoid = function() {
      return (0, exports.getMonoid)((0, Semigroup_1.last)());
    };
    exports.getLastMonoid = getLastMonoid;
  }
});

// node_modules/fp-ts/lib/Compactable.js
var require_Compactable = __commonJS({
  "node_modules/fp-ts/lib/Compactable.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCompactableComposition = exports.separate = exports.compact = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var Option_1 = require_Option();
    var S = __importStar(require_Separated());
    function compact(F, G) {
      return function(fga) {
        return F.map(fga, G.compact);
      };
    }
    exports.compact = compact;
    function separate(F, C, G) {
      var _compact = compact(F, C);
      var _map2 = (0, Functor_1.map)(F, G);
      return function(fge) {
        return S.separated(_compact((0, function_1.pipe)(fge, _map2(Option_1.getLeft))), _compact((0, function_1.pipe)(fge, _map2(Option_1.getRight))));
      };
    }
    exports.separate = separate;
    function getCompactableComposition(F, G) {
      var map = (0, Functor_1.getFunctorComposition)(F, G).map;
      return {
        map,
        compact: compact(F, G),
        separate: separate(F, G, G)
      };
    }
    exports.getCompactableComposition = getCompactableComposition;
  }
});

// node_modules/fp-ts/lib/Console.js
var require_Console = __commonJS({
  "node_modules/fp-ts/lib/Console.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.info = exports.error = exports.warn = exports.log = void 0;
    var log = function(a) {
      return function() {
        return console.log(a);
      };
    };
    exports.log = log;
    var warn = function(a) {
      return function() {
        return console.warn(a);
      };
    };
    exports.warn = warn;
    var error = function(a) {
      return function() {
        return console.error(a);
      };
    };
    exports.error = error;
    var info = function(a) {
      return function() {
        return console.info(a);
      };
    };
    exports.info = info;
  }
});

// node_modules/fp-ts/lib/Const.js
var require_Const = __commonJS({
  "node_modules/fp-ts/lib/Const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.const_ = exports.Bifunctor = exports.Contravariant = exports.flap = exports.Functor = exports.URI = exports.mapLeft = exports.bimap = exports.map = exports.contramap = exports.getApplicative = exports.getApply = exports.getBooleanAlgebra = exports.getHeytingAlgebra = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBounded = exports.getOrd = exports.getEq = exports.getShow = exports.make = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    exports.make = function_1.unsafeCoerce;
    function getShow(S) {
      return {
        show: function(c) {
          return "make(".concat(S.show(c), ")");
        }
      };
    }
    exports.getShow = getShow;
    exports.getEq = function_1.identity;
    exports.getOrd = function_1.identity;
    exports.getBounded = function_1.identity;
    exports.getSemigroup = function_1.identity;
    exports.getMonoid = function_1.identity;
    exports.getSemiring = function_1.identity;
    exports.getRing = function_1.identity;
    exports.getHeytingAlgebra = function_1.identity;
    exports.getBooleanAlgebra = function_1.identity;
    function getApply(S) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, exports.make)(S.concat(fab, fa));
        }
      };
    }
    exports.getApply = getApply;
    function getApplicative(M) {
      var A = getApply(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: A.map,
        ap: A.ap,
        of: function() {
          return (0, exports.make)(M.empty);
        }
      };
    }
    exports.getApplicative = getApplicative;
    var _contramap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.contramap)(f2));
    };
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _bimap = function(fa, f2, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f2, g));
    };
    var _mapLeft = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f2));
    };
    var contramap = function() {
      return function_1.unsafeCoerce;
    };
    exports.contramap = contramap;
    var map = function() {
      return function_1.unsafeCoerce;
    };
    exports.map = map;
    var bimap = function(f2) {
      return function(fa) {
        return (0, exports.make)(f2(fa));
      };
    };
    exports.bimap = bimap;
    var mapLeft = function(f2) {
      return function(fa) {
        return (0, exports.make)(f2(fa));
      };
    };
    exports.mapLeft = mapLeft;
    exports.URI = "Const";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Contravariant = {
      URI: exports.URI,
      contramap: _contramap
    };
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    exports.const_ = {
      URI: exports.URI,
      map: _map2,
      contramap: _contramap,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
  }
});

// node_modules/fp-ts/lib/Contravariant.js
var require_Contravariant = __commonJS({
  "node_modules/fp-ts/lib/Contravariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Date.js
var require_Date = __commonJS({
  "node_modules/fp-ts/lib/Date.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.now = exports.create = exports.Ord = exports.eqYear = exports.eqMonth = exports.eqDate = exports.Eq = void 0;
    var function_1 = require_function();
    var N = __importStar(require_number());
    var O = __importStar(require_Ord());
    exports.Eq = {
      equals: function(first, second) {
        return first.valueOf() === second.valueOf();
      }
    };
    exports.eqDate = {
      equals: function(x, y) {
        return x.getDate() === y.getDate();
      }
    };
    exports.eqMonth = {
      equals: function(x, y) {
        return x.getMonth() === y.getMonth();
      }
    };
    exports.eqYear = {
      equals: function(x, y) {
        return x.getFullYear() === y.getFullYear();
      }
    };
    exports.Ord = (0, function_1.pipe)(
      N.Ord,
      /* @__PURE__ */ O.contramap(function(date) {
        return date.valueOf();
      })
    );
    var create = function() {
      return /* @__PURE__ */ new Date();
    };
    exports.create = create;
    var now = function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    exports.now = now;
  }
});

// node_modules/fp-ts/lib/Either.js
var require_Either = __commonJS({
  "node_modules/fp-ts/lib/Either.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.flatMap = exports.right = exports.left = void 0;
    exports.chainFirstW = exports.chainFirst = exports.chain = exports.chainW = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.tap = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = void 0;
    exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var ChainRec_1 = require_ChainRec();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    exports.left = _.left;
    exports.right = _.right;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return (0, exports.isLeft)(ma) ? ma : f2(ma.right);
    });
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      return function(fa, f2) {
        var foldMapM = (0, exports.foldMap)(M);
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var _bimap = function(fa, f2, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f2, g));
    };
    var _mapLeft = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f2));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _chainRec = function(a, f2) {
      return (0, ChainRec_1.tailRec)(f2(a), function(e) {
        return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f2(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
      });
    };
    exports.URI = "Either";
    var getShow = function(SE, SA) {
      return {
        show: function(ma) {
          return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    exports.getShow = getShow;
    var getEq = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
        }
      };
    };
    exports.getEq = getEq;
    var getSemigroup = function(S) {
      return {
        concat: function(x, y) {
          return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right));
        }
      };
    };
    exports.getSemigroup = getSemigroup;
    var getCompactable = function(M) {
      var empty = (0, exports.left)(M.empty);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: function(ma) {
          return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty : (0, exports.right)(ma.right.value);
        },
        separate: function(ma) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(ma.right.right));
        }
      };
    };
    exports.getCompactable = getCompactable;
    var getFilterable = function(M) {
      var empty = (0, exports.left)(M.empty);
      var _a2 = (0, exports.getCompactable)(M), compact = _a2.compact, separate = _a2.separate;
      var filter2 = function(ma, predicate) {
        return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty;
      };
      var partition = function(ma, p) {
        return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p(ma.right) ? (0, Separated_1.separated)(empty, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty);
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact,
        separate,
        filter: filter2,
        filterMap: function(ma, f2) {
          if ((0, exports.isLeft)(ma)) {
            return ma;
          }
          var ob = f2(ma.right);
          return ob._tag === "None" ? empty : (0, exports.right)(ob.value);
        },
        partition,
        partitionMap: function(ma, f2) {
          if ((0, exports.isLeft)(ma)) {
            return (0, Separated_1.separated)(ma, ma);
          }
          var e = f2(ma.right);
          return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(e.right));
        }
      };
    };
    exports.getFilterable = getFilterable;
    var getWitherable = function(M) {
      var F_ = (0, exports.getFilterable)(M);
      var C = (0, exports.getCompactable)(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse,
        sequence: exports.sequence,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
        wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
      };
    };
    exports.getWitherable = getWitherable;
    var getApplicativeValidation = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        },
        of: exports.of
      };
    };
    exports.getApplicativeValidation = getApplicativeValidation;
    var getAltValidation = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        alt: function(me, that) {
          if ((0, exports.isRight)(me)) {
            return me;
          }
          var ea = that();
          return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    exports.getAltValidation = getAltValidation;
    var map = function(f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f2(fa.right));
      };
    };
    exports.map = map;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.of = exports.right;
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    var apW = function(fa) {
      return function(fab) {
        return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
      };
    };
    exports.apW = apW;
    exports.ap = exports.apW;
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    var reduce = function(b, f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f2(b, fa.right);
      };
    };
    exports.reduce = reduce;
    var foldMap = function(M) {
      return function(f2) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? M.empty : f2(fa.right);
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f2(fa.right, b);
      };
    };
    exports.reduceRight = reduceRight;
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    var traverse = function(F) {
      return function(f2) {
        return function(ta) {
          return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f2(ta.right), exports.right);
        };
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
      };
    };
    exports.sequence = sequence;
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    var bimap = function(f2, g) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f2(fa.left)) : (0, exports.right)(g(fa.right));
      };
    };
    exports.bimap = bimap;
    var mapLeft = function(f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f2(fa.left)) : fa;
      };
    };
    exports.mapLeft = mapLeft;
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    var altW = function(that) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? that() : fa;
      };
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    var extend = function(f2) {
      return function(wa) {
        return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f2(wa));
      };
    };
    exports.extend = extend;
    exports.Extend = {
      URI: exports.URI,
      map: _map2,
      extend: _extend
    };
    exports.ChainRec = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap,
      chainRec: _chainRec
    };
    exports.throwError = exports.left;
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: function_1.identity
    };
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.isLeft = _.isLeft;
    exports.isRight = _.isRight;
    var matchW = function(onLeft, onRight) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    exports.matchW = matchW;
    exports.foldW = exports.matchW;
    exports.match = exports.matchW;
    exports.fold = exports.match;
    var getOrElseW = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    exports.getOrElseW = getOrElseW;
    exports.getOrElse = exports.getOrElseW;
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.chainOptionKW = exports.chainOptionK;
    var _FromEither = {
      fromEither: exports.FromEither.fromEither
    };
    exports.liftNullable = _.liftNullable(_FromEither);
    exports.liftOption = _.liftOption(_FromEither);
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
    exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    var swap = function(ma) {
      return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
    };
    exports.swap = swap;
    var orElseW = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
      };
    };
    exports.orElseW = orElseW;
    exports.orElse = exports.orElseW;
    var fromNullable = function(e) {
      return function(a) {
        return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
      };
    };
    exports.fromNullable = fromNullable;
    var tryCatch = function(f2, onThrow) {
      try {
        return (0, exports.right)(f2());
      } catch (e) {
        return (0, exports.left)(onThrow(e));
      }
    };
    exports.tryCatch = tryCatch;
    var tryCatchK = function(f2, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f2.apply(void 0, a);
        }, onThrow);
      };
    };
    exports.tryCatchK = tryCatchK;
    var fromNullableK = function(e) {
      var from = (0, exports.fromNullable)(e);
      return function(f2) {
        return (0, function_1.flow)(f2, from);
      };
    };
    exports.fromNullableK = fromNullableK;
    var chainNullableK = function(e) {
      var from = (0, exports.fromNullableK)(e);
      return function(f2) {
        return (0, exports.flatMap)(from(f2));
      };
    };
    exports.chainNullableK = chainNullableK;
    exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
    function toError(e) {
      return e instanceof Error ? e : new Error(String(e));
    }
    exports.toError = toError;
    function elem(E) {
      return function(a, ma) {
        if (ma === void 0) {
          var elemE_1 = elem(E);
          return function(ma2) {
            return elemE_1(a, ma2);
          };
        }
        return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
      };
    }
    exports.elem = elem;
    var exists = function(predicate) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
      };
    };
    exports.exists = exists;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return function(as) {
        var e = f2(0, _.head(as));
        if ((0, exports.isLeft)(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
          var e_1 = f2(i, as[i]);
          if ((0, exports.isLeft)(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return (0, exports.right)(out);
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.chainW = exports.flatMap;
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    function parseJSON(s, onError) {
      return (0, exports.tryCatch)(function() {
        return JSON.parse(s);
      }, onError);
    }
    exports.parseJSON = parseJSON;
    var stringifyJSON = function(u, onError) {
      return (0, exports.tryCatch)(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    exports.stringifyJSON = stringifyJSON;
    exports.either = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      bimap: _bimap,
      mapLeft: _mapLeft,
      alt: _alt,
      extend: _extend,
      chainRec: _chainRec,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
    var getValidationSemigroup = function(SE, SA) {
      return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
    };
    exports.getValidationSemigroup = getValidationSemigroup;
    var getValidationMonoid = function(SE, MA) {
      return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
    };
    exports.getValidationMonoid = getValidationMonoid;
    function getValidation(SE) {
      var ap = (0, exports.getApplicativeValidation)(SE).ap;
      var alt = (0, exports.getAltValidation)(SE).alt;
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        of: exports.of,
        chain: exports.flatMap,
        bimap: _bimap,
        mapLeft: _mapLeft,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        extend: _extend,
        traverse: _traverse,
        sequence: exports.sequence,
        chainRec: _chainRec,
        throwError: exports.throwError,
        ap,
        alt
      };
    }
    exports.getValidation = getValidation;
  }
});

// node_modules/fp-ts/lib/EitherT.js
var require_EitherT = __commonJS({
  "node_modules/fp-ts/lib/EitherT.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEitherM = exports.toUnion = exports.swap = exports.orLeft = exports.tapError = exports.orElseFirst = exports.orElse = exports.getOrElse = exports.matchE = exports.match = exports.altValidation = exports.mapError = exports.mapLeft = exports.mapBoth = exports.bimap = exports.alt = exports.flatMap = exports.chain = exports.ap = exports.map = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.leftF = exports.rightF = exports.left = exports.right = void 0;
    var Apply_1 = require_Apply();
    var E = __importStar(require_Either());
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function right(F) {
      return (0, function_1.flow)(E.right, F.of);
    }
    exports.right = right;
    function left(F) {
      return (0, function_1.flow)(E.left, F.of);
    }
    exports.left = left;
    function rightF(F) {
      return function(fa) {
        return F.map(fa, E.right);
      };
    }
    exports.rightF = rightF;
    function leftF(F) {
      return function(fe) {
        return F.map(fe, E.left);
      };
    }
    exports.leftF = leftF;
    function fromNullable(F) {
      return function(e) {
        return (0, function_1.flow)(E.fromNullable(e), F.of);
      };
    }
    exports.fromNullable = fromNullable;
    function fromNullableK(F) {
      var fromNullableF = fromNullable(F);
      return function(e) {
        var fromNullableFE = fromNullableF(e);
        return function(f2) {
          return (0, function_1.flow)(f2, fromNullableFE);
        };
      };
    }
    exports.fromNullableK = fromNullableK;
    function chainNullableK(M) {
      var chainM = chain(M);
      var fromNullableKM = fromNullableK(M);
      return function(e) {
        var fromNullableKMe = fromNullableKM(e);
        return function(f2) {
          return chainM(fromNullableKMe(f2));
        };
      };
    }
    exports.chainNullableK = chainNullableK;
    function map(F) {
      return (0, Functor_1.map)(F, E.Functor);
    }
    exports.map = map;
    function ap(F) {
      return (0, Apply_1.ap)(F, E.Apply);
    }
    exports.ap = ap;
    function chain(M) {
      var flatMapM = flatMap(M);
      return function(f2) {
        return function(ma) {
          return flatMapM(ma, f2);
        };
      };
    }
    exports.chain = chain;
    function flatMap(M) {
      return function(ma, f2) {
        return M.chain(ma, function(e) {
          return E.isLeft(e) ? M.of(e) : f2(e.right);
        });
      };
    }
    exports.flatMap = flatMap;
    function alt(M) {
      return function(second) {
        return function(first) {
          return M.chain(first, function(e) {
            return E.isLeft(e) ? second() : M.of(e);
          });
        };
      };
    }
    exports.alt = alt;
    function bimap(F) {
      var mapBothF = mapBoth(F);
      return function(f2, g) {
        return function(self) {
          return mapBothF(self, f2, g);
        };
      };
    }
    exports.bimap = bimap;
    function mapBoth(F) {
      return function(self, f2, g) {
        return F.map(self, E.bimap(f2, g));
      };
    }
    exports.mapBoth = mapBoth;
    function mapLeft(F) {
      var mapErrorF = mapError(F);
      return function(f2) {
        return function(self) {
          return mapErrorF(self, f2);
        };
      };
    }
    exports.mapLeft = mapLeft;
    function mapError(F) {
      return function(self, f2) {
        return F.map(self, E.mapLeft(f2));
      };
    }
    exports.mapError = mapError;
    function altValidation(M, S) {
      return function(second) {
        return function(first) {
          return M.chain(first, E.match(function(e1) {
            return M.map(second(), E.mapLeft(function(e2) {
              return S.concat(e1, e2);
            }));
          }, right(M)));
        };
      };
    }
    exports.altValidation = altValidation;
    function match(F) {
      return function(onLeft, onRight) {
        return function(ma) {
          return F.map(ma, E.match(onLeft, onRight));
        };
      };
    }
    exports.match = match;
    function matchE(M) {
      return function(onLeft, onRight) {
        return function(ma) {
          return M.chain(ma, E.match(onLeft, onRight));
        };
      };
    }
    exports.matchE = matchE;
    function getOrElse(M) {
      return function(onLeft) {
        return function(ma) {
          return M.chain(ma, E.match(onLeft, M.of));
        };
      };
    }
    exports.getOrElse = getOrElse;
    function orElse(M) {
      return function(onLeft) {
        return function(ma) {
          return M.chain(ma, function(e) {
            return E.isLeft(e) ? onLeft(e.left) : M.of(e);
          });
        };
      };
    }
    exports.orElse = orElse;
    function orElseFirst(M) {
      var tapErrorM = tapError(M);
      return function(onLeft) {
        return function(ma) {
          return tapErrorM(ma, onLeft);
        };
      };
    }
    exports.orElseFirst = orElseFirst;
    function tapError(M) {
      var orElseM = orElse(M);
      return function(ma, onLeft) {
        return (0, function_1.pipe)(ma, orElseM(function(e) {
          return M.map(onLeft(e), function(eb) {
            return E.isLeft(eb) ? eb : E.left(e);
          });
        }));
      };
    }
    exports.tapError = tapError;
    function orLeft(M) {
      return function(onLeft) {
        return function(ma) {
          return M.chain(ma, E.match(function(e) {
            return M.map(onLeft(e), E.left);
          }, function(a) {
            return M.of(E.right(a));
          }));
        };
      };
    }
    exports.orLeft = orLeft;
    function swap(F) {
      return function(ma) {
        return F.map(ma, E.swap);
      };
    }
    exports.swap = swap;
    function toUnion(F) {
      return function(fa) {
        return F.map(fa, E.toUnion);
      };
    }
    exports.toUnion = toUnion;
    function getEitherM(M) {
      var _ap = ap(M);
      var _map2 = map(M);
      var _chain = chain(M);
      var _alt = alt(M);
      var _bimap = bimap(M);
      var _mapLeft = mapLeft(M);
      var _fold = matchE(M);
      var _getOrElse = getOrElse(M);
      var _orElse = orElse(M);
      return {
        map: function(fa, f2) {
          return (0, function_1.pipe)(fa, _map2(f2));
        },
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, _ap(fa));
        },
        of: right(M),
        chain: function(ma, f2) {
          return (0, function_1.pipe)(ma, _chain(f2));
        },
        alt: function(fa, that) {
          return (0, function_1.pipe)(fa, _alt(that));
        },
        bimap: function(fea, f2, g) {
          return (0, function_1.pipe)(fea, _bimap(f2, g));
        },
        mapLeft: function(fea, f2) {
          return (0, function_1.pipe)(fea, _mapLeft(f2));
        },
        fold: function(fa, onLeft, onRight) {
          return (0, function_1.pipe)(fa, _fold(onLeft, onRight));
        },
        getOrElse: function(fa, onLeft) {
          return (0, function_1.pipe)(fa, _getOrElse(onLeft));
        },
        orElse: function(fa, f2) {
          return (0, function_1.pipe)(fa, _orElse(f2));
        },
        swap: swap(M),
        rightM: rightF(M),
        leftM: leftF(M),
        left: left(M)
      };
    }
    exports.getEitherM = getEitherM;
  }
});

// node_modules/fp-ts/lib/Endomorphism.js
var require_Endomorphism = __commonJS({
  "node_modules/fp-ts/lib/Endomorphism.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMonoid = exports.getSemigroup = exports.URI = void 0;
    var function_1 = require_function();
    exports.URI = "Endomorphism";
    var getSemigroup = function() {
      return {
        concat: function(first, second) {
          return (0, function_1.flow)(first, second);
        }
      };
    };
    exports.getSemigroup = getSemigroup;
    var getMonoid = function() {
      return {
        concat: (0, exports.getSemigroup)().concat,
        empty: function_1.identity
      };
    };
    exports.getMonoid = getMonoid;
  }
});

// node_modules/fp-ts/lib/Extend.js
var require_Extend = __commonJS({
  "node_modules/fp-ts/lib/Extend.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Field.js
var require_Field = __commonJS({
  "node_modules/fp-ts/lib/Field.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fieldNumber = exports.lcm = exports.gcd = void 0;
    function gcd(E, field) {
      var zero = field.zero;
      var f2 = function(x, y) {
        return E.equals(y, zero) ? x : f2(y, field.mod(x, y));
      };
      return f2;
    }
    exports.gcd = gcd;
    function lcm(E, F) {
      var zero = F.zero;
      var gcdSF = gcd(E, F);
      return function(x, y) {
        return E.equals(x, zero) || E.equals(y, zero) ? zero : F.div(F.mul(x, y), gcdSF(x, y));
      };
    }
    exports.lcm = lcm;
    exports.fieldNumber = {
      add: function(x, y) {
        return x + y;
      },
      zero: 0,
      mul: function(x, y) {
        return x * y;
      },
      one: 1,
      sub: function(x, y) {
        return x - y;
      },
      degree: function(_) {
        return 1;
      },
      div: function(x, y) {
        return x / y;
      },
      mod: function(x, y) {
        return x % y;
      }
    };
  }
});

// node_modules/fp-ts/lib/Filterable.js
var require_Filterable = __commonJS({
  "node_modules/fp-ts/lib/Filterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterableComposition = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = void 0;
    var Compactable_1 = require_Compactable();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var Option_1 = require_Option();
    var Predicate_1 = require_Predicate();
    var Separated_1 = require_Separated();
    function filter2(F, G) {
      return function(predicate) {
        return function(fga) {
          return F.map(fga, function(ga) {
            return G.filter(ga, predicate);
          });
        };
      };
    }
    exports.filter = filter2;
    function filterMap(F, G) {
      return function(f2) {
        return function(fga) {
          return F.map(fga, function(ga) {
            return G.filterMap(ga, f2);
          });
        };
      };
    }
    exports.filterMap = filterMap;
    function partition(F, G) {
      var _filter2 = filter2(F, G);
      return function(predicate) {
        var left = _filter2((0, Predicate_1.not)(predicate));
        var right = _filter2(predicate);
        return function(fgb) {
          return (0, Separated_1.separated)(left(fgb), right(fgb));
        };
      };
    }
    exports.partition = partition;
    function partitionMap(F, G) {
      var _filterMap = filterMap(F, G);
      return function(f2) {
        return function(fga) {
          return (0, Separated_1.separated)((0, function_1.pipe)(fga, _filterMap(function(a) {
            return (0, Option_1.getLeft)(f2(a));
          })), (0, function_1.pipe)(fga, _filterMap(function(a) {
            return (0, Option_1.getRight)(f2(a));
          })));
        };
      };
    }
    exports.partitionMap = partitionMap;
    function getFilterableComposition(F, G) {
      var map = (0, Functor_1.getFunctorComposition)(F, G).map;
      var _compact = (0, Compactable_1.compact)(F, G);
      var _separate = (0, Compactable_1.separate)(F, G, G);
      var _filter2 = filter2(F, G);
      var _filterMap = filterMap(F, G);
      var _partition = partition(F, G);
      var _partitionMap = partitionMap(F, G);
      return {
        map,
        compact: _compact,
        separate: _separate,
        filter: function(fga, f2) {
          return (0, function_1.pipe)(fga, _filter2(f2));
        },
        filterMap: function(fga, f2) {
          return (0, function_1.pipe)(fga, _filterMap(f2));
        },
        partition: function(fga, p) {
          return (0, function_1.pipe)(fga, _partition(p));
        },
        partitionMap: function(fga, f2) {
          return (0, function_1.pipe)(fga, _partitionMap(f2));
        }
      };
    }
    exports.getFilterableComposition = getFilterableComposition;
  }
});

// node_modules/fp-ts/lib/FilterableWithIndex.js
var require_FilterableWithIndex = __commonJS({
  "node_modules/fp-ts/lib/FilterableWithIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Foldable.js
var require_Foldable = __commonJS({
  "node_modules/fp-ts/lib/Foldable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFoldableComposition = exports.toArray = exports.foldM = exports.traverse_ = exports.toReadonlyArray = exports.intercalate = exports.reduceM = exports.reduceRight = exports.foldMap = exports.reduce = void 0;
    var function_1 = require_function();
    function reduce(F, G) {
      return function(b, f2) {
        return function(fga) {
          return F.reduce(fga, b, function(b2, ga) {
            return G.reduce(ga, b2, f2);
          });
        };
      };
    }
    exports.reduce = reduce;
    function foldMap(F, G) {
      return function(M) {
        var foldMapF = F.foldMap(M);
        var foldMapG = G.foldMap(M);
        return function(f2) {
          return function(fga) {
            return foldMapF(fga, function(ga) {
              return foldMapG(ga, f2);
            });
          };
        };
      };
    }
    exports.foldMap = foldMap;
    function reduceRight(F, G) {
      return function(b, f2) {
        return function(fga) {
          return F.reduceRight(fga, b, function(ga, b2) {
            return G.reduceRight(ga, b2, f2);
          });
        };
      };
    }
    exports.reduceRight = reduceRight;
    function reduceM(M, F) {
      return function(b, f2) {
        return function(fa) {
          return F.reduce(fa, M.of(b), function(mb, a) {
            return M.chain(mb, function(b2) {
              return f2(b2, a);
            });
          });
        };
      };
    }
    exports.reduceM = reduceM;
    function intercalate(M, F) {
      return function(middle, fm) {
        var go = function(_a2, x) {
          var init = _a2.init, acc = _a2.acc;
          return init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, middle), x) };
        };
        return F.reduce(fm, { init: true, acc: M.empty }, go).acc;
      };
    }
    exports.intercalate = intercalate;
    function toReadonlyArray(F) {
      return function(fa) {
        return F.reduce(fa, [], function(acc, a) {
          acc.push(a);
          return acc;
        });
      };
    }
    exports.toReadonlyArray = toReadonlyArray;
    function traverse_(M, F) {
      var applyFirst = function(mu2, mb) {
        return M.ap(M.map(mu2, function_1.constant), mb);
      };
      var mu = M.of(void 0);
      return function(fa, f2) {
        return F.reduce(fa, mu, function(mu2, a) {
          return applyFirst(mu2, f2(a));
        });
      };
    }
    exports.traverse_ = traverse_;
    function foldM(M, F) {
      return function(fa, b, f2) {
        return F.reduce(fa, M.of(b), function(mb, a) {
          return M.chain(mb, function(b2) {
            return f2(b2, a);
          });
        });
      };
    }
    exports.foldM = foldM;
    exports.toArray = toReadonlyArray;
    function getFoldableComposition(F, G) {
      var _reduce = reduce(F, G);
      var _foldMap = foldMap(F, G);
      var _reduceRight = reduceRight(F, G);
      return {
        reduce: function(fga, b, f2) {
          return (0, function_1.pipe)(fga, _reduce(b, f2));
        },
        foldMap: function(M) {
          var foldMapM = _foldMap(M);
          return function(fga, f2) {
            return (0, function_1.pipe)(fga, foldMapM(f2));
          };
        },
        reduceRight: function(fga, b, f2) {
          return (0, function_1.pipe)(fga, _reduceRight(b, f2));
        }
      };
    }
    exports.getFoldableComposition = getFoldableComposition;
  }
});

// node_modules/fp-ts/lib/FoldableWithIndex.js
var require_FoldableWithIndex = __commonJS({
  "node_modules/fp-ts/lib/FoldableWithIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFoldableWithIndexComposition = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;
    var Foldable_1 = require_Foldable();
    var function_1 = require_function();
    function reduceWithIndex(F, G) {
      return function(b, f2) {
        return function(fga) {
          return F.reduceWithIndex(fga, b, function(i, b2, ga) {
            return G.reduceWithIndex(ga, b2, function(j, b3, a) {
              return f2([i, j], b3, a);
            });
          });
        };
      };
    }
    exports.reduceWithIndex = reduceWithIndex;
    function foldMapWithIndex(F, G) {
      return function(M) {
        var foldMapWithIndexF = F.foldMapWithIndex(M);
        var foldMapWithIndexG = G.foldMapWithIndex(M);
        return function(f2) {
          return function(fga) {
            return foldMapWithIndexF(fga, function(i, ga) {
              return foldMapWithIndexG(ga, function(j, a) {
                return f2([i, j], a);
              });
            });
          };
        };
      };
    }
    exports.foldMapWithIndex = foldMapWithIndex;
    function reduceRightWithIndex(F, G) {
      return function(b, f2) {
        return function(fga) {
          return F.reduceRightWithIndex(fga, b, function(i, ga, b2) {
            return G.reduceRightWithIndex(ga, b2, function(j, a, b3) {
              return f2([i, j], a, b3);
            });
          });
        };
      };
    }
    exports.reduceRightWithIndex = reduceRightWithIndex;
    function getFoldableWithIndexComposition(F, G) {
      var FC = (0, Foldable_1.getFoldableComposition)(F, G);
      var _reduceWithIndex = reduceWithIndex(F, G);
      var _foldMapWithIndex = foldMapWithIndex(F, G);
      var _reduceRightWithIndex = reduceRightWithIndex(F, G);
      return {
        reduce: FC.reduce,
        foldMap: FC.foldMap,
        reduceRight: FC.reduceRight,
        reduceWithIndex: function(fga, b, f2) {
          return (0, function_1.pipe)(fga, _reduceWithIndex(b, f2));
        },
        foldMapWithIndex: function(M) {
          var foldMapWithIndexM = _foldMapWithIndex(M);
          return function(fga, f2) {
            return (0, function_1.pipe)(fga, foldMapWithIndexM(f2));
          };
        },
        reduceRightWithIndex: function(fga, b, f2) {
          return (0, function_1.pipe)(fga, _reduceRightWithIndex(b, f2));
        }
      };
    }
    exports.getFoldableWithIndexComposition = getFoldableWithIndexComposition;
  }
});

// node_modules/fp-ts/lib/FromIO.js
var require_FromIO = __commonJS({
  "node_modules/fp-ts/lib/FromIO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tapIO = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = void 0;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    function fromIOK(F) {
      return function(f2) {
        return (0, function_1.flow)(f2, F.fromIO);
      };
    }
    exports.fromIOK = fromIOK;
    function chainIOK(F, M) {
      return function(f2) {
        var g = (0, function_1.flow)(f2, F.fromIO);
        return function(first) {
          return M.chain(first, g);
        };
      };
    }
    exports.chainIOK = chainIOK;
    function chainFirstIOK(F, M) {
      var tapIOM = tapIO(F, M);
      return function(f2) {
        return function(first) {
          return tapIOM(first, f2);
        };
      };
    }
    exports.chainFirstIOK = chainFirstIOK;
    function tapIO(F, M) {
      var chainFirstM = (0, Chain_1.tap)(M);
      return function(self, f2) {
        return chainFirstM(self, (0, function_1.flow)(f2, F.fromIO));
      };
    }
    exports.tapIO = tapIO;
  }
});

// node_modules/fp-ts/lib/Reader.js
var require_Reader = __commonJS({
  "node_modules/fp-ts/lib/Reader.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chainW = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.Do = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Choice = exports.Strong = exports.Category = exports.Profunctor = exports.tap = exports.Monad = exports.Chain = exports.Applicative = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.right = exports.left = exports.second = exports.first = exports.id = exports.promap = exports.compose = exports.flatten = exports.flattenW = exports.flatMap = exports.of = exports.ap = exports.apW = exports.map = exports.asksReader = exports.asksReaderW = exports.local = exports.asks = exports.ask = void 0;
    exports.getMonoid = exports.getSemigroup = exports.reader = exports.chainFirstW = exports.chainFirst = exports.chain = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var E = __importStar(require_Either());
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var ask = function() {
      return function_1.identity;
    };
    exports.ask = ask;
    exports.asks = function_1.identity;
    var local = function(f2) {
      return function(ma) {
        return function(r2) {
          return ma(f2(r2));
        };
      };
    };
    exports.local = local;
    var asksReaderW = function(f2) {
      return function(r) {
        return f2(r)(r);
      };
    };
    exports.asksReaderW = asksReaderW;
    exports.asksReader = exports.asksReaderW;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _compose = function(bc, ab) {
      return (0, function_1.pipe)(bc, (0, exports.compose)(ab));
    };
    var _promap2 = function(fea, f2, g) {
      return (0, function_1.pipe)(fea, (0, exports.promap)(f2, g));
    };
    var map = function(f2) {
      return function(fa) {
        return function(r) {
          return f2(fa(r));
        };
      };
    };
    exports.map = map;
    var apW = function(fa) {
      return function(fab) {
        return function(r) {
          return fab(r)(fa(r));
        };
      };
    };
    exports.apW = apW;
    exports.ap = exports.apW;
    exports.of = function_1.constant;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return function(r) {
        return f2(ma(r))(r);
      };
    });
    exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    var compose2 = function(ab) {
      return function(bc) {
        return (0, function_1.flow)(ab, bc);
      };
    };
    exports.compose = compose2;
    var promap = function(f2, g) {
      return function(fea) {
        return function(a) {
          return g(fea(f2(a)));
        };
      };
    };
    exports.promap = promap;
    var id = function() {
      return function_1.identity;
    };
    exports.id = id;
    var first = function(pab) {
      return function(_a2) {
        var a = _a2[0], c = _a2[1];
        return [pab(a), c];
      };
    };
    exports.first = first;
    var second = function(pbc) {
      return function(_a2) {
        var a = _a2[0], b = _a2[1];
        return [a, pbc(b)];
      };
    };
    exports.second = second;
    var left = function(pab) {
      return E.fold(function(a) {
        return _.left(pab(a));
      }, E.right);
    };
    exports.left = left;
    var right = function(pbc) {
      return E.fold(E.left, function(b) {
        return _.right(pbc(b));
      });
    };
    exports.right = right;
    exports.URI = "Reader";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.Profunctor = {
      URI: exports.URI,
      map: _map2,
      promap: _promap2
    };
    exports.Category = {
      URI: exports.URI,
      compose: _compose,
      id: exports.id
    };
    exports.Strong = {
      URI: exports.URI,
      map: _map2,
      promap: _promap2,
      first: exports.first,
      second: exports.second
    };
    exports.Choice = {
      URI: exports.URI,
      map: _map2,
      promap: _promap2,
      left: exports.left,
      right: exports.right
    };
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return function(as) {
        return function(r) {
          var out = [f2(0, _.head(as))(r)];
          for (var i = 1; i < as.length; i++) {
            out.push(f2(i, as[i])(r));
          }
          return out;
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.chainW = exports.flatMap;
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    exports.reader = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      promap: _promap2,
      compose: _compose,
      id: exports.id,
      first: exports.first,
      second: exports.second,
      left: exports.left,
      right: exports.right
    };
    exports.getSemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
  }
});

// node_modules/fp-ts/lib/FromReader.js
var require_FromReader = __commonJS({
  "node_modules/fp-ts/lib/FromReader.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tapReader = exports.chainFirstReaderK = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = void 0;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    var R = __importStar(require_Reader());
    function ask(F) {
      return function() {
        return F.fromReader(R.ask());
      };
    }
    exports.ask = ask;
    function asks(F) {
      return F.fromReader;
    }
    exports.asks = asks;
    function fromReaderK(F) {
      return function(f2) {
        return (0, function_1.flow)(f2, F.fromReader);
      };
    }
    exports.fromReaderK = fromReaderK;
    function chainReaderK(F, M) {
      var fromReaderKF = fromReaderK(F);
      return function(f2) {
        return function(ma) {
          return M.chain(ma, fromReaderKF(f2));
        };
      };
    }
    exports.chainReaderK = chainReaderK;
    function chainFirstReaderK(F, M) {
      var tapM = tapReader(F, M);
      return function(f2) {
        return function(self) {
          return tapM(self, f2);
        };
      };
    }
    exports.chainFirstReaderK = chainFirstReaderK;
    function tapReader(F, M) {
      var tapM = (0, Chain_1.tap)(M);
      return function(self, f2) {
        return tapM(self, (0, function_1.flow)(f2, F.fromReader));
      };
    }
    exports.tapReader = tapReader;
  }
});

// node_modules/fp-ts/lib/State.js
var require_State = __commonJS({
  "node_modules/fp-ts/lib/State.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.state = exports.execState = exports.evalState = exports.chainFirst = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.apS = exports.bind = exports.let = exports.bindTo = exports.execute = exports.evaluate = exports.FromState = exports.tap = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.flatten = exports.flatMap = exports.of = exports.ap = exports.map = exports.gets = exports.modify = exports.put = exports.get = void 0;
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var get = function() {
      return function(s) {
        return [s, s];
      };
    };
    exports.get = get;
    var put = function(s) {
      return function() {
        return [void 0, s];
      };
    };
    exports.put = put;
    var modify = function(f2) {
      return function(s) {
        return [void 0, f2(s)];
      };
    };
    exports.modify = modify;
    var gets = function(f2) {
      return function(s) {
        return [f2(s), s];
      };
    };
    exports.gets = gets;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var map = function(f2) {
      return function(fa) {
        return function(s1) {
          var _a2 = fa(s1), a = _a2[0], s2 = _a2[1];
          return [f2(a), s2];
        };
      };
    };
    exports.map = map;
    var ap = function(fa) {
      return function(fab) {
        return function(s1) {
          var _a2 = fab(s1), f2 = _a2[0], s2 = _a2[1];
          var _b = fa(s2), a = _b[0], s3 = _b[1];
          return [f2(a), s3];
        };
      };
    };
    exports.ap = ap;
    var of = function(a) {
      return function(s) {
        return [a, s];
      };
    };
    exports.of = of;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return function(s1) {
        var _a2 = ma(s1), a = _a2[0], s2 = _a2[1];
        return f2(a)(s2);
      };
    });
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    exports.URI = "State";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.FromState = {
      URI: exports.URI,
      fromState: function_1.identity
    };
    var evaluate = function(s) {
      return function(ma) {
        return ma(s)[0];
      };
    };
    exports.evaluate = evaluate;
    var execute = function(s) {
      return function(ma) {
        return ma(s)[1];
      };
    };
    exports.execute = execute;
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return function(as) {
        return function(s) {
          var _a2 = f2(0, _.head(as))(s), b = _a2[0], s2 = _a2[1];
          var bs = [b];
          var out = s2;
          for (var i = 1; i < as.length; i++) {
            var _b = f2(i, as[i])(out), b_1 = _b[0], s2_1 = _b[1];
            bs.push(b_1);
            out = s2_1;
          }
          return [bs, out];
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : (0, exports.of)(_.emptyReadonlyArray);
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
    var evalState = function(ma, s) {
      return ma(s)[0];
    };
    exports.evalState = evalState;
    var execState = function(ma, s) {
      return ma(s)[1];
    };
    exports.execState = execState;
    exports.state = exports.Monad;
  }
});

// node_modules/fp-ts/lib/FromState.js
var require_FromState = __commonJS({
  "node_modules/fp-ts/lib/FromState.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chainStateK = exports.fromStateK = exports.gets = exports.modify = exports.put = exports.get = void 0;
    var function_1 = require_function();
    var S = __importStar(require_State());
    function get(F) {
      return function() {
        return F.fromState(S.get());
      };
    }
    exports.get = get;
    function put(F) {
      return function(s) {
        return F.fromState(S.put(s));
      };
    }
    exports.put = put;
    function modify(F) {
      return (0, function_1.flow)(S.modify, F.fromState);
    }
    exports.modify = modify;
    function gets(F) {
      return (0, function_1.flow)(S.gets, F.fromState);
    }
    exports.gets = gets;
    function fromStateK(F) {
      return function(f2) {
        return (0, function_1.flow)(f2, F.fromState);
      };
    }
    exports.fromStateK = fromStateK;
    function chainStateK(F, M) {
      var fromStateKF = fromStateK(F);
      return function(f2) {
        return function(ma) {
          return M.chain(ma, fromStateKF(f2));
        };
      };
    }
    exports.chainStateK = chainStateK;
  }
});

// node_modules/fp-ts/lib/FromTask.js
var require_FromTask = __commonJS({
  "node_modules/fp-ts/lib/FromTask.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tapTask = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = void 0;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    function fromTaskK(F) {
      return function(f2) {
        return (0, function_1.flow)(f2, F.fromTask);
      };
    }
    exports.fromTaskK = fromTaskK;
    function chainTaskK(F, M) {
      return function(f2) {
        var g = (0, function_1.flow)(f2, F.fromTask);
        return function(first) {
          return M.chain(first, g);
        };
      };
    }
    exports.chainTaskK = chainTaskK;
    function chainFirstTaskK(F, M) {
      var tapTaskM = tapTask(F, M);
      return function(f2) {
        return function(first) {
          return tapTaskM(first, f2);
        };
      };
    }
    exports.chainFirstTaskK = chainFirstTaskK;
    function tapTask(F, M) {
      var tapM = (0, Chain_1.tap)(M);
      return function(self, f2) {
        return tapM(self, (0, function_1.flow)(f2, F.fromTask));
      };
    }
    exports.tapTask = tapTask;
  }
});

// node_modules/fp-ts/lib/FromThese.js
var require_FromThese = __commonJS({
  "node_modules/fp-ts/lib/FromThese.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromTheseK = void 0;
    var function_1 = require_function();
    function fromTheseK(F) {
      return function(f2) {
        return (0, function_1.flow)(f2, F.fromThese);
      };
    }
    exports.fromTheseK = fromTheseK;
  }
});

// node_modules/fp-ts/lib/FunctorWithIndex.js
var require_FunctorWithIndex = __commonJS({
  "node_modules/fp-ts/lib/FunctorWithIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctorWithIndexComposition = exports.mapWithIndex = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function mapWithIndex(F, G) {
      return function(f2) {
        return function(fa) {
          return F.mapWithIndex(fa, function(i, ga) {
            return G.mapWithIndex(ga, function(j, a) {
              return f2([i, j], a);
            });
          });
        };
      };
    }
    exports.mapWithIndex = mapWithIndex;
    function getFunctorWithIndexComposition(F, G) {
      var map = (0, Functor_1.getFunctorComposition)(F, G).map;
      var _mapWithIndex = mapWithIndex(F, G);
      return {
        map,
        mapWithIndex: function(fga, f2) {
          return (0, function_1.pipe)(fga, _mapWithIndex(f2));
        }
      };
    }
    exports.getFunctorWithIndexComposition = getFunctorWithIndexComposition;
  }
});

// node_modules/fp-ts/lib/Group.js
var require_Group = __commonJS({
  "node_modules/fp-ts/lib/Group.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/HeytingAlgebra.js
var require_HeytingAlgebra = __commonJS({
  "node_modules/fp-ts/lib/HeytingAlgebra.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/HKT/index.js
var require_HKT = __commonJS({
  "node_modules/fp-ts/lib/HKT/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Identity.js
var require_Identity = __commonJS({
  "node_modules/fp-ts/lib/Identity.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.identity = exports.chain = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.ChainRec = exports.Comonad = exports.Alt = exports.Traversable = exports.Foldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.getEq = exports.getShow = exports.URI = exports.alt = exports.altW = exports.sequence = exports.traverse = exports.reduceRight = exports.foldMap = exports.reduce = exports.flatten = exports.duplicate = exports.extract = exports.extend = exports.flatMap = exports.of = exports.ap = exports.map = void 0;
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var ChainRec_1 = require_ChainRec();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, (0, exports.foldMap)(M)(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var _chainRec = ChainRec_1.tailRec;
    var map = function(f2) {
      return function(fa) {
        return f2(fa);
      };
    };
    exports.map = map;
    var ap = function(fa) {
      return function(fab) {
        return fab(fa);
      };
    };
    exports.ap = ap;
    exports.of = function_1.identity;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return f2(ma);
    });
    var extend = function(f2) {
      return function(wa) {
        return f2(wa);
      };
    };
    exports.extend = extend;
    exports.extract = function_1.identity;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    var reduce = function(b, f2) {
      return function(fa) {
        return f2(b, fa);
      };
    };
    exports.reduce = reduce;
    var foldMap = function() {
      return function(f2) {
        return function(fa) {
          return f2(fa);
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f2) {
      return function(fa) {
        return f2(fa, b);
      };
    };
    exports.reduceRight = reduceRight;
    var traverse = function(F) {
      return function(f2) {
        return function(ta) {
          return F.map(f2(ta), function_1.identity);
        };
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(ta) {
        return F.map(ta, function_1.identity);
      };
    };
    exports.sequence = sequence;
    var altW = function() {
      return function_1.identity;
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    exports.URI = "Identity";
    exports.getShow = function_1.identity;
    exports.getEq = function_1.identity;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.Comonad = {
      URI: exports.URI,
      map: _map2,
      extend: _extend,
      extract: exports.extract
    };
    exports.ChainRec = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap,
      chainRec: _chainRec
    };
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.chain = exports.flatMap;
    exports.identity = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      alt: _alt,
      extract: exports.extract,
      extend: _extend,
      chainRec: _chainRec
    };
  }
});

// node_modules/fp-ts/lib/Invariant.js
var require_Invariant = __commonJS({
  "node_modules/fp-ts/lib/Invariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/IO.js
var require_IO = __commonJS({
  "node_modules/fp-ts/lib/IO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMonoid = exports.getSemigroup = exports.io = exports.chainFirst = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.FromIO = exports.ChainRec = exports.MonadIO = exports.fromIO = exports.tap = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.URI = exports.flatten = exports.flatMap = exports.of = exports.ap = exports.map = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var _map2 = function(ma, f2) {
      return function() {
        return f2(ma());
      };
    };
    var _ap = function(mab, ma) {
      return function() {
        return mab()(ma());
      };
    };
    var _chainRec = function(a, f2) {
      return function() {
        var e = f2(a)();
        while (e._tag === "Left") {
          e = f2(e.left)();
        }
        return e.right;
      };
    };
    var map = function(f2) {
      return function(fa) {
        return _map2(fa, f2);
      };
    };
    exports.map = map;
    var ap = function(fa) {
      return function(fab) {
        return _ap(fab, fa);
      };
    };
    exports.ap = ap;
    exports.of = function_1.constant;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return function() {
        return f2(ma())();
      };
    });
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    exports.URI = "IO";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.fromIO = function_1.identity;
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.ChainRec = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap,
      chainRec: _chainRec
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: function_1.identity
    };
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return function(as) {
        return function() {
          var out = [f2(0, _.head(as))()];
          for (var i = 1; i < as.length; i++) {
            out.push(f2(i, as[i])());
          }
          return out;
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.io = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      chainRec: _chainRec
    };
    exports.getSemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
  }
});

// node_modules/fp-ts/lib/IOEither.js
var require_IOEither = __commonJS({
  "node_modules/fp-ts/lib/IOEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apFirst = exports.ApplyPar = exports.Bifunctor = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.getFilterable = exports.getCompactable = exports.getAltIOValidation = exports.getApplicativeIOValidation = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.flatMap = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.mapError = exports.bimap = exports.mapBoth = exports.map = exports.swap = exports.orLeft = exports.orElseFirstIOK = exports.tapError = exports.orElseW = exports.orElse = exports.toUnion = exports.tryCatchK = exports.tryCatch = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromIO = exports.fromEither = exports.leftIO = exports.rightIO = exports.right = exports.left = void 0;
    exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.bracketW = exports.bracket = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.chainIOK = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.chainFirstIOK = exports.fromIOK = exports.MonadThrow = exports.MonadIO = exports.Alt = exports.tapIO = exports.tapEither = exports.tap = exports.FromIO = exports.FromEither = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplicativePar = exports.apSecondW = exports.apSecond = exports.apFirstW = void 0;
    exports.getIOValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.ioEither = exports.orElseFirstW = exports.orElseFirst = exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.Applicative = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var Compactable_1 = require_Compactable();
    var E = __importStar(require_Either());
    var ET = __importStar(require_EitherT());
    var Filterable_1 = require_Filterable();
    var FromEither_1 = require_FromEither();
    var FromIO_1 = require_FromIO();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var I = __importStar(require_IO());
    exports.left = ET.left(I.Pointed);
    exports.right = ET.right(I.Pointed);
    exports.rightIO = ET.rightF(I.Functor);
    exports.leftIO = ET.leftF(I.Functor);
    exports.fromEither = I.of;
    exports.fromIO = exports.rightIO;
    exports.match = /* @__PURE__ */ ET.match(I.Functor);
    exports.matchW = exports.match;
    exports.matchE = /* @__PURE__ */ ET.matchE(I.Monad);
    exports.fold = exports.matchE;
    exports.matchEW = exports.matchE;
    exports.foldW = exports.matchEW;
    exports.getOrElse = ET.getOrElse(I.Monad);
    exports.getOrElseW = exports.getOrElse;
    var tryCatch = function(f2, onThrow) {
      return function() {
        return E.tryCatch(f2, onThrow);
      };
    };
    exports.tryCatch = tryCatch;
    var tryCatchK = function(f2, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f2.apply(void 0, a);
        }, onThrow);
      };
    };
    exports.tryCatchK = tryCatchK;
    exports.toUnion = ET.toUnion(I.Functor);
    exports.orElse = /* @__PURE__ */ ET.orElse(I.Monad);
    exports.orElseW = exports.orElse;
    exports.tapError = (0, function_1.dual)(2, ET.tapError(I.Monad));
    var orElseFirstIOK = function(onLeft) {
      return (0, exports.tapError)((0, exports.fromIOK)(onLeft));
    };
    exports.orElseFirstIOK = orElseFirstIOK;
    exports.orLeft = /* @__PURE__ */ ET.orLeft(I.Monad);
    exports.swap = ET.swap(I.Functor);
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _apSeq = function(fab, fa) {
      return (0, exports.flatMap)(fab, function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    exports.map = ET.map(I.Functor);
    exports.mapBoth = (0, function_1.dual)(3, ET.mapBoth(I.Functor));
    exports.bimap = exports.mapBoth;
    exports.mapError = (0, function_1.dual)(2, ET.mapError(I.Functor));
    exports.mapLeft = exports.mapError;
    exports.ap = /* @__PURE__ */ ET.ap(I.Apply);
    exports.apW = exports.ap;
    exports.of = exports.right;
    exports.flatMap = (0, function_1.dual)(2, ET.flatMap(I.Monad));
    exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.alt = /* @__PURE__ */ ET.alt(I.Monad);
    exports.altW = exports.alt;
    exports.throwError = exports.left;
    exports.URI = "IOEither";
    function getApplicativeIOValidation(S) {
      var ap = (0, Apply_1.ap)(I.Apply, E.getApplicativeValidation(S));
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, ap(fa));
        },
        of: exports.of
      };
    }
    exports.getApplicativeIOValidation = getApplicativeIOValidation;
    function getAltIOValidation(S) {
      var alt = ET.altValidation(I.Monad, S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        alt: function(fa, that) {
          return (0, function_1.pipe)(fa, alt(that));
        }
      };
    }
    exports.getAltIOValidation = getAltIOValidation;
    var getCompactable = function(M) {
      var C = E.getCompactable(M);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: (0, Compactable_1.compact)(I.Functor, C),
        separate: (0, Compactable_1.separate)(I.Functor, C, E.Functor)
      };
    };
    exports.getCompactable = getCompactable;
    function getFilterable(M) {
      var F = E.getFilterable(M);
      var C = (0, exports.getCompactable)(M);
      var filter2 = (0, Filterable_1.filter)(I.Functor, F);
      var filterMap = (0, Filterable_1.filterMap)(I.Functor, F);
      var partition = (0, Filterable_1.partition)(I.Functor, F);
      var partitionMap = (0, Filterable_1.partitionMap)(I.Functor, F);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: C.compact,
        separate: C.separate,
        filter: function(fa, predicate) {
          return (0, function_1.pipe)(fa, filter2(predicate));
        },
        filterMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, filterMap(f2));
        },
        partition: function(fa, predicate) {
          return (0, function_1.pipe)(fa, partition(predicate));
        },
        partitionMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, partitionMap(f2));
        }
      };
    }
    exports.getFilterable = getFilterable;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError
    };
    exports.ApplyPar = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
    exports.apSecondW = exports.apSecond;
    exports.ApplicativePar = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.ApplicativeSeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      throwError: exports.throwError
    };
    exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainFirstIOK = exports.tapIO;
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.chainOptionKW = exports.chainOptionK;
    var _FromEither = {
      fromEither: exports.FromEither.fromEither
    };
    var _FromIO = {
      fromIO: exports.fromIO
    };
    exports.liftNullable = _.liftNullable(_FromEither);
    exports.liftOption = _.liftOption(_FromEither);
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
    exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
    exports.flatMapEither = _.flatMapEither(_FromEither, _FlatMap);
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.chainIOK = exports.flatMapIO;
    exports.chainEitherK = exports.flatMapEither;
    exports.chainEitherKW = exports.flatMapEither;
    exports.chainFirstEitherK = exports.tapEither;
    exports.chainFirstEitherKW = exports.tapEither;
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    var bracket = function(acquire, use, release) {
      return (0, exports.bracketW)(acquire, use, release);
    };
    exports.bracket = bracket;
    var bracketW = function(acquire, use, release) {
      return (0, exports.flatMap)(acquire, function(a) {
        return I.flatMap(use(a), function(e) {
          return (0, exports.flatMap)(release(a, e), function() {
            return I.of(e);
          });
        });
      });
    };
    exports.bracketW = bracketW;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(I.traverseReadonlyNonEmptyArrayWithIndex(f2), I.map(E.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f2) {
      return function(as) {
        return function() {
          var e = f2(0, _.head(as))();
          if (_.isLeft(e)) {
            return e;
          }
          var out = [e.right];
          for (var i = 1; i < as.length; i++) {
            var e_1 = f2(i, as[i])();
            if (_.isLeft(e_1)) {
              return e_1;
            }
            out.push(e_1.right);
          }
          return _.right(out);
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
    var traverseReadonlyArrayWithIndexSeq = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
    var traverseSeqArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndexSeq)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseSeqArray = traverseSeqArray;
    exports.sequenceSeqArray = /* @__PURE__ */ (0, exports.traverseSeqArray)(function_1.identity);
    exports.Applicative = exports.ApplicativePar;
    exports.chain = exports.flatMap;
    exports.chainW = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    exports.orElseFirst = exports.tapError;
    exports.orElseFirstW = exports.tapError;
    exports.ioEither = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      alt: _alt,
      fromIO: exports.fromIO,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.ApplyPar);
    exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.ApplicativePar);
    var getSemigroup = function(S) {
      return (0, Apply_1.getApplySemigroup)(I.Apply)(E.getSemigroup(S));
    };
    exports.getSemigroup = getSemigroup;
    function getIOValidation(SE) {
      var applicativeIOValidation = getApplicativeIOValidation(SE);
      var altIOValidation = getAltIOValidation(SE);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: applicativeIOValidation.ap,
        of: exports.of,
        chain: exports.flatMap,
        bimap: exports.mapBoth,
        mapLeft: exports.mapError,
        alt: altIOValidation.alt,
        fromIO: exports.fromIO,
        throwError: exports.throwError
      };
    }
    exports.getIOValidation = getIOValidation;
  }
});

// node_modules/fp-ts/lib/OptionT.js
var require_OptionT = __commonJS({
  "node_modules/fp-ts/lib/OptionT.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOptionM = exports.alt = exports.flatMap = exports.chain = exports.ap = exports.map = exports.getOrElse = exports.matchE = exports.match = exports.fromEither = exports.fromPredicate = exports.chainOptionK = exports.fromOptionK = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.fromF = exports.zero = exports.some = void 0;
    var Apply_1 = require_Apply();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var O = __importStar(require_Option());
    function some(F) {
      return (0, function_1.flow)(O.some, F.of);
    }
    exports.some = some;
    function zero(F) {
      return (0, function_1.constant)(F.of(O.none));
    }
    exports.zero = zero;
    function fromF(F) {
      return function(ma) {
        return F.map(ma, O.some);
      };
    }
    exports.fromF = fromF;
    function fromNullable(F) {
      return (0, function_1.flow)(O.fromNullable, F.of);
    }
    exports.fromNullable = fromNullable;
    function fromNullableK(F) {
      var fromNullableF = fromNullable(F);
      return function(f2) {
        return (0, function_1.flow)(f2, fromNullableF);
      };
    }
    exports.fromNullableK = fromNullableK;
    function chainNullableK(M) {
      var chainM = chain(M);
      var fromNullableKM = fromNullableK(M);
      return function(f2) {
        return chainM(fromNullableKM(f2));
      };
    }
    exports.chainNullableK = chainNullableK;
    function fromOptionK(F) {
      return function(f2) {
        return (0, function_1.flow)(f2, F.of);
      };
    }
    exports.fromOptionK = fromOptionK;
    function chainOptionK(M) {
      var chainM = chain(M);
      var fromOptionKM = fromOptionK(M);
      return function(f2) {
        return chainM(fromOptionKM(f2));
      };
    }
    exports.chainOptionK = chainOptionK;
    function fromPredicate(F) {
      return function(predicate) {
        return function(a) {
          return F.of(O.fromPredicate(predicate)(a));
        };
      };
    }
    exports.fromPredicate = fromPredicate;
    function fromEither(F) {
      return (0, function_1.flow)(O.fromEither, F.of);
    }
    exports.fromEither = fromEither;
    function match(F) {
      return function(onNone, onSome) {
        return function(ma) {
          return F.map(ma, O.match(onNone, onSome));
        };
      };
    }
    exports.match = match;
    function matchE(M) {
      return function(onNone, onSome) {
        return function(ma) {
          return M.chain(ma, O.match(onNone, onSome));
        };
      };
    }
    exports.matchE = matchE;
    function getOrElse(M) {
      return function(onNone) {
        return function(fa) {
          return M.chain(fa, O.match(onNone, M.of));
        };
      };
    }
    exports.getOrElse = getOrElse;
    function map(F) {
      return (0, Functor_1.map)(F, O.Functor);
    }
    exports.map = map;
    function ap(F) {
      return (0, Apply_1.ap)(F, O.Apply);
    }
    exports.ap = ap;
    function chain(M) {
      var flatMapM = flatMap(M);
      return function(f2) {
        return function(ma) {
          return flatMapM(ma, f2);
        };
      };
    }
    exports.chain = chain;
    function flatMap(M) {
      var zeroM = zero(M);
      return function(ma, f2) {
        return M.chain(ma, O.match(function() {
          return zeroM();
        }, f2));
      };
    }
    exports.flatMap = flatMap;
    function alt(M) {
      var _some = some(M);
      return function(second) {
        return function(first) {
          return M.chain(first, O.match(second, _some));
        };
      };
    }
    exports.alt = alt;
    function getOptionM(M) {
      var apM = ap(M);
      var mapM = map(M);
      var chainM = chain(M);
      var altM = alt(M);
      var foldM = matchE(M);
      var getOrElseM = getOrElse(M);
      var zeroM = zero(M);
      return {
        map: function(fa, f2) {
          return (0, function_1.pipe)(fa, mapM(f2));
        },
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, apM(fa));
        },
        of: some(M),
        chain: function(ma, f2) {
          return (0, function_1.pipe)(ma, chainM(f2));
        },
        alt: function(fa, that) {
          return (0, function_1.pipe)(fa, altM(that));
        },
        fold: function(fa, onNone, onSome) {
          return (0, function_1.pipe)(fa, foldM(onNone, onSome));
        },
        getOrElse: function(fa, onNone) {
          return (0, function_1.pipe)(fa, getOrElseM(onNone));
        },
        fromM: fromF(M),
        none: function() {
          return zeroM();
        }
      };
    }
    exports.getOptionM = getOptionM;
  }
});

// node_modules/fp-ts/lib/IOOption.js
var require_IOOption = __commonJS({
  "node_modules/fp-ts/lib/IOOption.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tapIO = exports.tapEither = exports.tap = exports.FromIO = exports.FromEither = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.URI = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.separate = exports.compact = exports.none = exports.zero = exports.altW = exports.alt = exports.flatten = exports.flatMap = exports.of = exports.ap = exports.map = exports.fromOptionK = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.toNullable = exports.toUndefined = exports.getOrElseW = exports.getOrElse = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromIOEither = exports.fromIO = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.some = void 0;
    exports.chainFirst = exports.chain = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.chainOptionK = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.flatMapNullable = exports.flatMapEither = exports.flatMapOption = exports.flatMapIO = exports.Filterable = exports.Compactable = exports.MonadIO = exports.Monad = exports.Alternative = exports.guard = exports.Zero = exports.Alt = void 0;
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var Compactable_1 = require_Compactable();
    var Filterable_1 = require_Filterable();
    var FromEither_1 = require_FromEither();
    var FromIO_1 = require_FromIO();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var I = __importStar(require_IO());
    var O = __importStar(require_Option());
    var OT = __importStar(require_OptionT());
    var Zero_1 = require_Zero();
    exports.some = OT.some(I.Pointed);
    exports.fromPredicate = OT.fromPredicate(I.Pointed);
    exports.fromOption = I.of;
    exports.fromEither = OT.fromEither(I.Pointed);
    exports.fromIO = OT.fromF(I.Functor);
    exports.fromIOEither = I.map(O.fromEither);
    exports.match = OT.match(I.Functor);
    exports.matchW = exports.match;
    exports.matchE = /* @__PURE__ */ OT.matchE(I.Chain);
    exports.fold = exports.matchE;
    exports.matchEW = exports.matchE;
    exports.getOrElse = OT.getOrElse(I.Monad);
    exports.getOrElseW = exports.getOrElse;
    exports.toUndefined = I.map(O.toUndefined);
    exports.toNullable = I.map(O.toNullable);
    exports.fromNullable = OT.fromNullable(I.Pointed);
    exports.fromNullableK = OT.fromNullableK(I.Pointed);
    exports.chainNullableK = OT.chainNullableK(I.Monad);
    exports.fromOptionK = /* @__PURE__ */ OT.fromOptionK(I.Pointed);
    exports.map = OT.map(I.Functor);
    exports.ap = OT.ap(I.Apply);
    exports.of = exports.some;
    exports.flatMap = (0, function_1.dual)(2, OT.flatMap(I.Monad));
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    exports.alt = OT.alt(I.Monad);
    exports.altW = exports.alt;
    exports.zero = OT.zero(I.Pointed);
    exports.none = (0, exports.zero)();
    exports.compact = (0, Compactable_1.compact)(I.Functor, O.Compactable);
    exports.separate = (0, Compactable_1.separate)(I.Functor, O.Compactable, O.Functor);
    exports.filter = (0, Filterable_1.filter)(I.Functor, O.Filterable);
    exports.filterMap = (0, Filterable_1.filterMap)(I.Functor, O.Filterable);
    exports.partition = (0, Filterable_1.partition)(I.Functor, O.Filterable);
    exports.partitionMap = (0, Filterable_1.partitionMap)(I.Functor, O.Filterable);
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _filter2 = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
    };
    var _filterMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMap)(f2));
    };
    var _partition = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
    };
    var _partitionMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f2));
    };
    exports.URI = "IOOption";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.Zero = {
      URI: exports.URI,
      zero: exports.zero
    };
    exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
    exports.Alternative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      alt: _alt,
      zero: exports.zero
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    var _FromIO = {
      fromIO: exports.FromIO.fromIO
    };
    var _FromEither = {
      fromEither: exports.fromEither
    };
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.flatMapOption = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromOptionK)(f2));
    });
    exports.flatMapEither = _.flatMapEither(_FromEither, _FlatMap);
    exports.flatMapNullable = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromNullableK)(f2));
    });
    exports.fromIOK = /* @__PURE__ */ (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.chainEitherK = exports.flatMapEither;
    exports.chainFirstEitherK = exports.tapEither;
    exports.chainOptionK = exports.flatMapOption;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(I.traverseReadonlyNonEmptyArrayWithIndex(f2), I.map(O.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
  }
});

// node_modules/fp-ts/lib/IORef.js
var require_IORef = __commonJS({
  "node_modules/fp-ts/lib/IORef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newIORef = exports.IORef = void 0;
    var IORef = (
      /** @class */
      function() {
        function IORef2(value) {
          var _this = this;
          this.value = value;
          this.read = function() {
            return _this.value;
          };
          this.write = this.write.bind(this);
          this.modify = this.modify.bind(this);
        }
        IORef2.prototype.write = function(a) {
          var _this = this;
          return function() {
            _this.value = a;
          };
        };
        IORef2.prototype.modify = function(f2) {
          var _this = this;
          return function() {
            _this.value = f2(_this.value);
          };
        };
        return IORef2;
      }()
    );
    exports.IORef = IORef;
    function newIORef(a) {
      return function() {
        return new IORef(a);
      };
    }
    exports.newIORef = newIORef;
  }
});

// node_modules/fp-ts/lib/JoinSemilattice.js
var require_JoinSemilattice = __commonJS({
  "node_modules/fp-ts/lib/JoinSemilattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Json.js
var require_Json = __commonJS({
  "node_modules/fp-ts/lib/Json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = void 0;
    var Either_1 = require_Either();
    var function_1 = require_function();
    var parse = function(s) {
      return (0, Either_1.tryCatch)(function() {
        return JSON.parse(s);
      }, function_1.identity);
    };
    exports.parse = parse;
    var stringify = function(a) {
      return (0, Either_1.tryCatch)(function() {
        var s = JSON.stringify(a);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, function_1.identity);
    };
    exports.stringify = stringify;
  }
});

// node_modules/fp-ts/lib/Lattice.js
var require_Lattice = __commonJS({
  "node_modules/fp-ts/lib/Lattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/ReadonlyMap.js
var require_ReadonlyMap = __commonJS({
  "node_modules/fp-ts/lib/ReadonlyMap.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.foldMap = exports.reduce = exports.Filterable = exports.Compactable = exports.getFunctorWithIndex = exports.flap = exports.Functor = exports.getFilterableWithIndex = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.URI = exports.separate = exports.partitionMap = exports.partition = exports.mapWithIndex = exports.map = exports.filterMap = exports.filter = exports.compact = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.fromFoldable = exports.singleton = exports.getMonoid = exports.getEq = exports.empty = exports.isSubmap = exports.lookup = exports.lookupWithKey = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.upsertAt = exports.toUnfoldable = exports.toReadonlyArray = exports.collect = exports.values = exports.keys = exports.elem = exports.member = exports.isEmpty = exports.size = exports.getShow = exports.toMap = exports.fromMap = void 0;
    exports.readonlyMap = exports.insertAt = exports.difference = exports.intersection = exports.union = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.getFoldableWithIndex = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.getFoldable = exports.reduceRight = void 0;
    var Eq_1 = require_Eq();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var O = __importStar(require_Option());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    var fromMap = function(m) {
      return new Map(m);
    };
    exports.fromMap = fromMap;
    function toMap(m) {
      return new Map(m);
    }
    exports.toMap = toMap;
    function getShow(SK, SA) {
      return {
        show: function(m) {
          var entries = [];
          m.forEach(function(a, k) {
            entries.push("[".concat(SK.show(k), ", ").concat(SA.show(a), "]"));
          });
          return "new Map([".concat(entries.sort().join(", "), "])");
        }
      };
    }
    exports.getShow = getShow;
    var size = function(m) {
      return m.size;
    };
    exports.size = size;
    var isEmpty = function(m) {
      return m.size === 0;
    };
    exports.isEmpty = isEmpty;
    function member(E) {
      var lookupE = lookup(E);
      return function(k, m) {
        if (m === void 0) {
          var memberE_1 = member(E);
          return function(m2) {
            return memberE_1(k, m2);
          };
        }
        return _.isSome(lookupE(k, m));
      };
    }
    exports.member = member;
    function elem(E) {
      return function(a, m) {
        if (m === void 0) {
          var elemE_1 = elem(E);
          return function(m2) {
            return elemE_1(a, m2);
          };
        }
        var values2 = m.values();
        var e;
        while (!(e = values2.next()).done) {
          var v = e.value;
          if (E.equals(a, v)) {
            return true;
          }
        }
        return false;
      };
    }
    exports.elem = elem;
    var keys4 = function(O2) {
      return function(m) {
        return Array.from(m.keys()).sort(O2.compare);
      };
    };
    exports.keys = keys4;
    var values = function(O2) {
      return function(m) {
        return Array.from(m.values()).sort(O2.compare);
      };
    };
    exports.values = values;
    function collect(O2) {
      var keysO = (0, exports.keys)(O2);
      return function(f2) {
        return function(m) {
          var out = [];
          var ks = keysO(m);
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            out.push(f2(key, m.get(key)));
          }
          return out;
        };
      };
    }
    exports.collect = collect;
    var toReadonlyArray = function(O2) {
      return collect(O2)(function(k, a) {
        return [k, a];
      });
    };
    exports.toReadonlyArray = toReadonlyArray;
    function toUnfoldable(ord, U) {
      var toReadonlyArrayO = (0, exports.toReadonlyArray)(ord);
      return function(d) {
        var kas = toReadonlyArrayO(d);
        var len = kas.length;
        return U.unfold(0, function(b) {
          return b < len ? _.some([kas[b], b + 1]) : _.none;
        });
      };
    }
    exports.toUnfoldable = toUnfoldable;
    var upsertAt = function(E) {
      var lookupWithKeyE = lookupWithKey(E);
      return function(k, a) {
        var lookupWithKeyEk = lookupWithKeyE(k);
        return function(m) {
          var found = lookupWithKeyEk(m);
          if (_.isNone(found)) {
            var out = new Map(m);
            out.set(k, a);
            return out;
          } else if (found.value[1] !== a) {
            var out = new Map(m);
            out.set(found.value[0], a);
            return out;
          }
          return m;
        };
      };
    };
    exports.upsertAt = upsertAt;
    var deleteAt = function(E) {
      var lookupWithKeyE = lookupWithKey(E);
      return function(k) {
        return function(m) {
          var found = lookupWithKeyE(k, m);
          if (_.isSome(found)) {
            var r = new Map(m);
            r.delete(found.value[0]);
            return r;
          }
          return m;
        };
      };
    };
    exports.deleteAt = deleteAt;
    var updateAt = function(E) {
      var modifyAtE = (0, exports.modifyAt)(E);
      return function(k, a) {
        return modifyAtE(k, function() {
          return a;
        });
      };
    };
    exports.updateAt = updateAt;
    var modifyAt = function(E) {
      var lookupWithKeyE = lookupWithKey(E);
      return function(k, f2) {
        return function(m) {
          var found = lookupWithKeyE(k, m);
          if (_.isNone(found)) {
            return _.none;
          }
          var _a2 = found.value, fk = _a2[0], fv = _a2[1];
          var next = f2(fv);
          if (next === fv) {
            return _.some(m);
          }
          var r = new Map(m);
          r.set(fk, next);
          return _.some(r);
        };
      };
    };
    exports.modifyAt = modifyAt;
    function pop(E) {
      var lookupE = lookup(E);
      var deleteAtE = (0, exports.deleteAt)(E);
      return function(k) {
        var deleteAtEk = deleteAtE(k);
        return function(m) {
          return (0, function_1.pipe)(lookupE(k, m), O.map(function(a) {
            return [a, deleteAtEk(m)];
          }));
        };
      };
    }
    exports.pop = pop;
    function lookupWithKey(E) {
      return function(k, m) {
        if (m === void 0) {
          var lookupWithKeyE_1 = lookupWithKey(E);
          return function(m2) {
            return lookupWithKeyE_1(k, m2);
          };
        }
        var entries = m.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, ka = _a2[0], a = _a2[1];
          if (E.equals(ka, k)) {
            return _.some([ka, a]);
          }
        }
        return _.none;
      };
    }
    exports.lookupWithKey = lookupWithKey;
    function lookup(E) {
      var lookupWithKeyE = lookupWithKey(E);
      return function(k, m) {
        if (m === void 0) {
          var lookupE_1 = lookup(E);
          return function(m2) {
            return lookupE_1(k, m2);
          };
        }
        return (0, function_1.pipe)(lookupWithKeyE(k, m), O.map(function(_a2) {
          var _2 = _a2[0], a = _a2[1];
          return a;
        }));
      };
    }
    exports.lookup = lookup;
    function isSubmap(SK, SA) {
      var lookupWithKeyS = lookupWithKey(SK);
      return function(me, that) {
        if (that === void 0) {
          var isSubmapSKSA_1 = isSubmap(SK, SA);
          return function(that2) {
            return isSubmapSKSA_1(that2, me);
          };
        }
        var entries = me.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          var d2OptA = lookupWithKeyS(k, that);
          if (_.isNone(d2OptA) || !SK.equals(k, d2OptA.value[0]) || !SA.equals(a, d2OptA.value[1])) {
            return false;
          }
        }
        return true;
      };
    }
    exports.isSubmap = isSubmap;
    exports.empty = // the type annotation here is intended (otherwise it doesn't type-check)
    /* @__PURE__ */ new Map();
    function getEq(SK, SA) {
      var isSubmapSKSA = isSubmap(SK, SA);
      return (0, Eq_1.fromEquals)(function(x, y) {
        return isSubmapSKSA(x, y) && isSubmapSKSA(y, x);
      });
    }
    exports.getEq = getEq;
    function getMonoid(SK, SA) {
      var lookupWithKeyS = lookupWithKey(SK);
      return {
        concat: function(mx, my) {
          if ((0, exports.isEmpty)(mx)) {
            return my;
          }
          if ((0, exports.isEmpty)(my)) {
            return mx;
          }
          var r = new Map(mx);
          var entries = my.entries();
          var e;
          while (!(e = entries.next()).done) {
            var _a2 = e.value, k = _a2[0], a = _a2[1];
            var mxOptA = lookupWithKeyS(k, mx);
            if (_.isSome(mxOptA)) {
              r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a));
            } else {
              r.set(k, a);
            }
          }
          return r;
        },
        empty: exports.empty
      };
    }
    exports.getMonoid = getMonoid;
    var singleton = function(k, a) {
      return /* @__PURE__ */ new Map([[k, a]]);
    };
    exports.singleton = singleton;
    function fromFoldable(E, M, F) {
      return function(fka) {
        var lookupWithKeyE = lookupWithKey(E);
        return F.reduce(fka, /* @__PURE__ */ new Map(), function(b, _a2) {
          var k = _a2[0], a = _a2[1];
          var bOpt = lookupWithKeyE(k, b);
          if (_.isSome(bOpt)) {
            b.set(bOpt.value[0], M.concat(bOpt.value[1], a));
          } else {
            b.set(k, a);
          }
          return b;
        });
      };
    }
    exports.fromFoldable = fromFoldable;
    var _mapWithIndex = function(fa, f2) {
      var m = /* @__PURE__ */ new Map();
      var entries = fa.entries();
      var e;
      while (!(e = entries.next()).done) {
        var _a2 = e.value, key = _a2[0], a = _a2[1];
        m.set(key, f2(key, a));
      }
      return m;
    };
    var partitionMapWithIndex = function(f2) {
      return function(fa) {
        var left = /* @__PURE__ */ new Map();
        var right = /* @__PURE__ */ new Map();
        var entries = fa.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          var ei = f2(k, a);
          if (_.isLeft(ei)) {
            left.set(k, ei.left);
          } else {
            right.set(k, ei.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    };
    exports.partitionMapWithIndex = partitionMapWithIndex;
    function partitionWithIndex(predicateWithIndex) {
      return function(m) {
        var left = /* @__PURE__ */ new Map();
        var right = /* @__PURE__ */ new Map();
        var entries = m.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          if (predicateWithIndex(k, a)) {
            right.set(k, a);
          } else {
            left.set(k, a);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.partitionWithIndex = partitionWithIndex;
    var filterMapWithIndex = function(f2) {
      return function(fa) {
        var m = /* @__PURE__ */ new Map();
        var entries = fa.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          var o = f2(k, a);
          if (_.isSome(o)) {
            m.set(k, o.value);
          }
        }
        return m;
      };
    };
    exports.filterMapWithIndex = filterMapWithIndex;
    function filterWithIndex(predicateWithIndex) {
      return function(m) {
        var out = /* @__PURE__ */ new Map();
        var entries = m.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          if (predicateWithIndex(k, a)) {
            out.set(k, a);
          }
        }
        return out;
      };
    }
    exports.filterWithIndex = filterWithIndex;
    var _map2 = function(fa, f2) {
      return _mapWithIndex(fa, function(_2, a) {
        return f2(a);
      });
    };
    var _filter2 = function(fa, p) {
      return _filterWithIndex(fa, function(_2, a) {
        return p(a);
      });
    };
    var _filterMap = function(fa, f2) {
      return _filterMapWithIndex(fa, function(_2, a) {
        return f2(a);
      });
    };
    var _partition = function(fa, predicate) {
      return _partitionWithIndex(fa, function(_2, a) {
        return predicate(a);
      });
    };
    var _partitionMap = function(fa, f2) {
      return _partitionMapWithIndex(fa, function(_2, a) {
        return f2(a);
      });
    };
    var _filterWithIndex = function(fa, p) {
      return (0, function_1.pipe)(fa, filterWithIndex(p));
    };
    var _filterMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f2));
    };
    var _partitionWithIndex = function(fa, p) {
      return (0, function_1.pipe)(fa, partitionWithIndex(p));
    };
    var _partitionMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f2));
    };
    var compact = function(fa) {
      var m = /* @__PURE__ */ new Map();
      var entries = fa.entries();
      var e;
      while (!(e = entries.next()).done) {
        var _a2 = e.value, k = _a2[0], oa = _a2[1];
        if (_.isSome(oa)) {
          m.set(k, oa.value);
        }
      }
      return m;
    };
    exports.compact = compact;
    var filter2 = function(predicate) {
      return function(fa) {
        return _filter2(fa, predicate);
      };
    };
    exports.filter = filter2;
    var filterMap = function(f2) {
      return function(fa) {
        return _filterMap(fa, f2);
      };
    };
    exports.filterMap = filterMap;
    var map = function(f2) {
      return function(fa) {
        return _map2(fa, f2);
      };
    };
    exports.map = map;
    var mapWithIndex = function(f2) {
      return function(fa) {
        return _mapWithIndex(fa, f2);
      };
    };
    exports.mapWithIndex = mapWithIndex;
    var partition = function(predicate) {
      return function(fa) {
        return _partition(fa, predicate);
      };
    };
    exports.partition = partition;
    var partitionMap = function(f2) {
      return function(fa) {
        return _partitionMap(fa, f2);
      };
    };
    exports.partitionMap = partitionMap;
    var separate = function(fa) {
      var left = /* @__PURE__ */ new Map();
      var right = /* @__PURE__ */ new Map();
      var entries = fa.entries();
      var e;
      while (!(e = entries.next()).done) {
        var _a2 = e.value, k = _a2[0], ei = _a2[1];
        if (_.isLeft(ei)) {
          left.set(k, ei.left);
        } else {
          right.set(k, ei.right);
        }
      }
      return (0, Separated_1.separated)(left, right);
    };
    exports.separate = separate;
    exports.URI = "ReadonlyMap";
    var getUnionSemigroup = function(E, S) {
      var unionES = (0, exports.union)(E, S);
      return {
        concat: function(first, second) {
          return unionES(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(E, S) {
      return {
        concat: (0, exports.getUnionSemigroup)(E, S).concat,
        empty: exports.empty
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(E, S) {
      var intersectionES = (0, exports.intersection)(E, S);
      return {
        concat: function(first, second) {
          return intersectionES(second)(first);
        }
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function(E) {
      return function() {
        var differenceE = (0, exports.difference)(E);
        return {
          concat: function(first, second) {
            return differenceE(second)(first);
          }
        };
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    function getFilterableWithIndex() {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter2,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex
      };
    }
    exports.getFilterableWithIndex = getFilterableWithIndex;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    var getFunctorWithIndex = function() {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        mapWithIndex: _mapWithIndex
      };
    };
    exports.getFunctorWithIndex = getFunctorWithIndex;
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    var reduce = function(O2) {
      var reduceWithIndexO = (0, exports.reduceWithIndex)(O2);
      return function(b, f2) {
        return reduceWithIndexO(b, function(_2, b2, a) {
          return f2(b2, a);
        });
      };
    };
    exports.reduce = reduce;
    var foldMap = function(O2) {
      var foldMapWithIndexO = (0, exports.foldMapWithIndex)(O2);
      return function(M) {
        var foldMapWithIndexOM = foldMapWithIndexO(M);
        return function(f2) {
          return foldMapWithIndexOM(function(_2, a) {
            return f2(a);
          });
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(O2) {
      var reduceRightWithIndexO = (0, exports.reduceRightWithIndex)(O2);
      return function(b, f2) {
        return reduceRightWithIndexO(b, function(_2, b2, a) {
          return f2(b2, a);
        });
      };
    };
    exports.reduceRight = reduceRight;
    var getFoldable = function(O2) {
      var reduceO = (0, exports.reduce)(O2);
      var foldMapO = (0, exports.foldMap)(O2);
      var reduceRightO = (0, exports.reduceRight)(O2);
      return {
        URI: exports.URI,
        _E: void 0,
        reduce: function(fa, b, f2) {
          return (0, function_1.pipe)(fa, reduceO(b, f2));
        },
        foldMap: function(M) {
          var foldMapOM = foldMapO(M);
          return function(fa, f2) {
            return (0, function_1.pipe)(fa, foldMapOM(f2));
          };
        },
        reduceRight: function(fa, b, f2) {
          return (0, function_1.pipe)(fa, reduceRightO(b, f2));
        }
      };
    };
    exports.getFoldable = getFoldable;
    var reduceWithIndex = function(O2) {
      var keysO = (0, exports.keys)(O2);
      return function(b, f2) {
        return function(m) {
          var out = b;
          for (var _i = 0, _a2 = keysO(m); _i < _a2.length; _i++) {
            var k = _a2[_i];
            out = f2(k, out, m.get(k));
          }
          return out;
        };
      };
    };
    exports.reduceWithIndex = reduceWithIndex;
    var foldMapWithIndex = function(O2) {
      var keysO = (0, exports.keys)(O2);
      return function(M) {
        return function(f2) {
          return function(m) {
            var out = M.empty;
            for (var _i = 0, _a2 = keysO(m); _i < _a2.length; _i++) {
              var k = _a2[_i];
              out = M.concat(out, f2(k, m.get(k)));
            }
            return out;
          };
        };
      };
    };
    exports.foldMapWithIndex = foldMapWithIndex;
    var reduceRightWithIndex = function(O2) {
      var keysO = (0, exports.keys)(O2);
      return function(b, f2) {
        return function(m) {
          var out = b;
          var ks = keysO(m);
          var len = ks.length;
          for (var i = len - 1; i >= 0; i--) {
            var k = ks[i];
            out = f2(k, m.get(k), out);
          }
          return out;
        };
      };
    };
    exports.reduceRightWithIndex = reduceRightWithIndex;
    var getFoldableWithIndex = function(O2) {
      var F = (0, exports.getFoldable)(O2);
      var reduceWithIndexO = (0, exports.reduceWithIndex)(O2);
      var foldMapWithIndexO = (0, exports.foldMapWithIndex)(O2);
      var reduceRightWithIndexO = (0, exports.reduceRightWithIndex)(O2);
      return {
        URI: exports.URI,
        _E: void 0,
        reduce: F.reduce,
        foldMap: F.foldMap,
        reduceRight: F.reduceRight,
        reduceWithIndex: function(fa, b, f2) {
          return (0, function_1.pipe)(fa, reduceWithIndexO(b, f2));
        },
        foldMapWithIndex: function(M) {
          var foldMapWithIndexOM = foldMapWithIndexO(M);
          return function(fa, f2) {
            return (0, function_1.pipe)(fa, foldMapWithIndexOM(f2));
          };
        },
        reduceRightWithIndex: function(fa, b, f2) {
          return (0, function_1.pipe)(fa, reduceRightWithIndexO(b, f2));
        }
      };
    };
    exports.getFoldableWithIndex = getFoldableWithIndex;
    var getTraversable = function(O2) {
      var TWI = (0, exports.getTraversableWithIndex)(O2);
      var F = (0, exports.getFoldable)(O2);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        reduce: F.reduce,
        foldMap: F.foldMap,
        reduceRight: F.reduceRight,
        traverse: TWI.traverse,
        sequence: TWI.sequence
      };
    };
    exports.getTraversable = getTraversable;
    var getTraversableWithIndex = function(O2) {
      var FWI = (0, exports.getFoldableWithIndex)(O2);
      var keysO = (0, exports.keys)(O2);
      var traverseWithIndex = function(F) {
        return function(ta, f2) {
          var fm = F.of(/* @__PURE__ */ new Map());
          var ks = keysO(ta);
          var len = ks.length;
          var _loop_1 = function(i2) {
            var key = ks[i2];
            var a = ta.get(key);
            fm = F.ap(F.map(fm, function(m) {
              return function(b) {
                return m.set(key, b);
              };
            }), f2(key, a));
          };
          for (var i = 0; i < len; i++) {
            _loop_1(i);
          }
          return fm;
        };
      };
      var traverse = function(F) {
        var traverseWithIndexF = traverseWithIndex(F);
        return function(ta, f2) {
          return traverseWithIndexF(ta, function(_2, a) {
            return f2(a);
          });
        };
      };
      var sequence = function(F) {
        var traverseWithIndexF = traverseWithIndex(F);
        return function(ta) {
          return traverseWithIndexF(ta, function_1.SK);
        };
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        mapWithIndex: _mapWithIndex,
        reduce: FWI.reduce,
        foldMap: FWI.foldMap,
        reduceRight: FWI.reduceRight,
        reduceWithIndex: FWI.reduceWithIndex,
        foldMapWithIndex: FWI.foldMapWithIndex,
        reduceRightWithIndex: FWI.reduceRightWithIndex,
        traverse,
        sequence,
        traverseWithIndex
      };
    };
    exports.getTraversableWithIndex = getTraversableWithIndex;
    function getWitherable(O2) {
      var TWI = (0, exports.getTraversableWithIndex)(O2);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter2,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        reduce: TWI.reduce,
        foldMap: TWI.foldMap,
        reduceRight: TWI.reduceRight,
        traverse: TWI.traverse,
        sequence: TWI.sequence,
        mapWithIndex: _mapWithIndex,
        reduceWithIndex: TWI.reduceWithIndex,
        foldMapWithIndex: TWI.foldMapWithIndex,
        reduceRightWithIndex: TWI.reduceRightWithIndex,
        traverseWithIndex: TWI.traverseWithIndex,
        wilt: (0, Witherable_1.wiltDefault)(TWI, exports.Compactable),
        wither: (0, Witherable_1.witherDefault)(TWI, exports.Compactable)
      };
    }
    exports.getWitherable = getWitherable;
    var union = function(E, M) {
      var lookupE = lookup(E);
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return second;
          }
          if ((0, exports.isEmpty)(second)) {
            return first;
          }
          var out = /* @__PURE__ */ new Map();
          var firstEntries = first.entries();
          var e;
          while (!(e = firstEntries.next()).done) {
            var _a2 = e.value, k = _a2[0], a = _a2[1];
            var oka = lookupE(k)(second);
            if (_.isSome(oka)) {
              out.set(k, M.concat(a, oka.value));
            } else {
              out.set(k, a);
            }
          }
          var secondEntries = second.entries();
          while (!(e = secondEntries.next()).done) {
            var _b = e.value, k = _b[0], a = _b[1];
            var oka = lookupE(k)(out);
            if (_.isNone(oka)) {
              out.set(k, a);
            }
          }
          return out;
        };
      };
    };
    exports.union = union;
    var intersection = function(E, M) {
      var lookupE = lookup(E);
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
            return exports.empty;
          }
          var out = /* @__PURE__ */ new Map();
          var entries = first.entries();
          var e;
          while (!(e = entries.next()).done) {
            var _a2 = e.value, k = _a2[0], a = _a2[1];
            var oka = lookupE(k)(second);
            if (_.isSome(oka)) {
              out.set(k, M.concat(a, oka.value));
            }
          }
          return out;
        };
      };
    };
    exports.intersection = intersection;
    var difference = function(E) {
      var memberE = member(E);
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return second;
          }
          if ((0, exports.isEmpty)(second)) {
            return first;
          }
          var out = /* @__PURE__ */ new Map();
          var firstEntries = first.entries();
          var e;
          while (!(e = firstEntries.next()).done) {
            var _a2 = e.value, k = _a2[0], a = _a2[1];
            if (!memberE(k)(second)) {
              out.set(k, a);
            }
          }
          var secondEntries = second.entries();
          while (!(e = secondEntries.next()).done) {
            var _b = e.value, k = _b[0], a = _b[1];
            if (!memberE(k)(first)) {
              out.set(k, a);
            }
          }
          return out;
        };
      };
    };
    exports.difference = difference;
    exports.insertAt = exports.upsertAt;
    exports.readonlyMap = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
  }
});

// node_modules/fp-ts/lib/Map.js
var require_Map = __commonJS({
  "node_modules/fp-ts/lib/Map.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t3[p] = s[p];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTraversableWithIndex = exports.getFoldableWithIndex = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.getFoldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.getWitherable = exports.getFilterableWithIndex = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.URI = exports.separate = exports.partitionMap = exports.partition = exports.mapWithIndex = exports.map = exports.filterMap = exports.filter = exports.compact = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.fromFoldable = exports.singleton = exports.getMonoid = exports.getEq = exports.isSubmap = exports.lookup = exports.lookupWithKey = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.upsertAt = exports.toUnfoldable = exports.toArray = exports.collect = exports.values = exports.keys = exports.elem = exports.member = exports.isEmpty = exports.size = exports.getShow = void 0;
    exports.map_ = exports.insertAt = exports.empty = exports.difference = exports.intersection = exports.union = exports.Filterable = exports.Compactable = exports.flap = exports.Functor = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var O = __importStar(require_Option());
    var RM = __importStar(require_ReadonlyMap());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    exports.getShow = RM.getShow;
    exports.size = RM.size;
    exports.isEmpty = RM.isEmpty;
    exports.member = RM.member;
    exports.elem = RM.elem;
    var keys4 = function(O2) {
      return function(m) {
        return Array.from(m.keys()).sort(O2.compare);
      };
    };
    exports.keys = keys4;
    var values = function(O2) {
      return function(m) {
        return Array.from(m.values()).sort(O2.compare);
      };
    };
    exports.values = values;
    function collect(O2) {
      var keysO = (0, exports.keys)(O2);
      return function(f2) {
        return function(m) {
          var out = [];
          var ks = keysO(m);
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            out.push(f2(key, m.get(key)));
          }
          return out;
        };
      };
    }
    exports.collect = collect;
    function toArray(O2) {
      return collect(O2)(function(k, a) {
        return [k, a];
      });
    }
    exports.toArray = toArray;
    function toUnfoldable(ord, U) {
      var toArrayO = toArray(ord);
      return function(d) {
        var kas = toArrayO(d);
        var len = kas.length;
        return U.unfold(0, function(b) {
          return b < len ? _.some([kas[b], b + 1]) : _.none;
        });
      };
    }
    exports.toUnfoldable = toUnfoldable;
    var upsertAt = function(E) {
      var lookupWithKeyE = lookupWithKey(E);
      return function(k, a) {
        var lookupWithKeyEk = lookupWithKeyE(k);
        return function(m) {
          var found = lookupWithKeyEk(m);
          if (_.isNone(found)) {
            var out = new Map(m);
            out.set(k, a);
            return out;
          } else if (found.value[1] !== a) {
            var out = new Map(m);
            out.set(found.value[0], a);
            return out;
          }
          return m;
        };
      };
    };
    exports.upsertAt = upsertAt;
    var deleteAt = function(E) {
      var lookupWithKeyE = lookupWithKey(E);
      return function(k) {
        return function(m) {
          var found = lookupWithKeyE(k, m);
          if (_.isSome(found)) {
            var r = new Map(m);
            r.delete(found.value[0]);
            return r;
          }
          return m;
        };
      };
    };
    exports.deleteAt = deleteAt;
    var updateAt = function(E) {
      var modifyAtE = (0, exports.modifyAt)(E);
      return function(k, a) {
        return modifyAtE(k, function() {
          return a;
        });
      };
    };
    exports.updateAt = updateAt;
    var modifyAt = function(E) {
      var lookupWithKeyE = lookupWithKey(E);
      return function(k, f2) {
        return function(m) {
          var found = lookupWithKeyE(k, m);
          if (_.isNone(found)) {
            return _.none;
          }
          var r = new Map(m);
          r.set(found.value[0], f2(found.value[1]));
          return _.some(r);
        };
      };
    };
    exports.modifyAt = modifyAt;
    function pop(E) {
      var lookupE = (0, exports.lookup)(E);
      var deleteAtE = (0, exports.deleteAt)(E);
      return function(k) {
        var deleteAtEk = deleteAtE(k);
        return function(m) {
          return (0, function_1.pipe)(lookupE(k, m), O.map(function(a) {
            return [a, deleteAtEk(m)];
          }));
        };
      };
    }
    exports.pop = pop;
    function lookupWithKey(E) {
      return function(k, m) {
        if (m === void 0) {
          var lookupWithKeyE_1 = lookupWithKey(E);
          return function(m2) {
            return lookupWithKeyE_1(k, m2);
          };
        }
        var entries = m.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, ka = _a2[0], a = _a2[1];
          if (E.equals(ka, k)) {
            return _.some([ka, a]);
          }
        }
        return _.none;
      };
    }
    exports.lookupWithKey = lookupWithKey;
    exports.lookup = RM.lookup;
    exports.isSubmap = RM.isSubmap;
    exports.getEq = RM.getEq;
    function getMonoid(SK, SA) {
      var lookupWithKeyS = lookupWithKey(SK);
      return {
        concat: function(mx, my) {
          if ((0, exports.isEmpty)(mx)) {
            return my;
          }
          if ((0, exports.isEmpty)(my)) {
            return mx;
          }
          var r = new Map(mx);
          var entries = my.entries();
          var e;
          while (!(e = entries.next()).done) {
            var _a2 = e.value, k = _a2[0], a = _a2[1];
            var mxOptA = lookupWithKeyS(k, mx);
            if (_.isSome(mxOptA)) {
              r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a));
            } else {
              r.set(k, a);
            }
          }
          return r;
        },
        empty: /* @__PURE__ */ new Map()
      };
    }
    exports.getMonoid = getMonoid;
    var singleton = function(k, a) {
      return /* @__PURE__ */ new Map([[k, a]]);
    };
    exports.singleton = singleton;
    function fromFoldable(E, M, F) {
      return function(fka) {
        var lookupWithKeyE = lookupWithKey(E);
        return F.reduce(fka, /* @__PURE__ */ new Map(), function(b, _a2) {
          var k = _a2[0], a = _a2[1];
          var bOpt = lookupWithKeyE(k, b);
          if (_.isSome(bOpt)) {
            b.set(bOpt.value[0], M.concat(bOpt.value[1], a));
          } else {
            b.set(k, a);
          }
          return b;
        });
      };
    }
    exports.fromFoldable = fromFoldable;
    var _mapWithIndex = function(fa, f2) {
      var m = /* @__PURE__ */ new Map();
      var entries = fa.entries();
      var e;
      while (!(e = entries.next()).done) {
        var _a2 = e.value, key = _a2[0], a = _a2[1];
        m.set(key, f2(key, a));
      }
      return m;
    };
    var partitionMapWithIndex = function(f2) {
      return function(fa) {
        var left = /* @__PURE__ */ new Map();
        var right = /* @__PURE__ */ new Map();
        var entries = fa.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          var ei = f2(k, a);
          if (_.isLeft(ei)) {
            left.set(k, ei.left);
          } else {
            right.set(k, ei.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    };
    exports.partitionMapWithIndex = partitionMapWithIndex;
    function partitionWithIndex(predicateWithIndex) {
      return function(fa) {
        var left = /* @__PURE__ */ new Map();
        var right = /* @__PURE__ */ new Map();
        var entries = fa.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          if (predicateWithIndex(k, a)) {
            right.set(k, a);
          } else {
            left.set(k, a);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.partitionWithIndex = partitionWithIndex;
    var filterMapWithIndex = function(f2) {
      return function(fa) {
        var m = /* @__PURE__ */ new Map();
        var entries = fa.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          var o = f2(k, a);
          if (_.isSome(o)) {
            m.set(k, o.value);
          }
        }
        return m;
      };
    };
    exports.filterMapWithIndex = filterMapWithIndex;
    function filterWithIndex(p) {
      return function(m) {
        var out = /* @__PURE__ */ new Map();
        var entries = m.entries();
        var e;
        while (!(e = entries.next()).done) {
          var _a2 = e.value, k = _a2[0], a = _a2[1];
          if (p(k, a)) {
            out.set(k, a);
          }
        }
        return out;
      };
    }
    exports.filterWithIndex = filterWithIndex;
    var _map2 = function(fa, f2) {
      return _mapWithIndex(fa, function(_2, a) {
        return f2(a);
      });
    };
    var _filter2 = function(fa, p) {
      return _filterWithIndex(fa, function(_2, a) {
        return p(a);
      });
    };
    var _filterMap = function(fa, f2) {
      return _filterMapWithIndex(fa, function(_2, a) {
        return f2(a);
      });
    };
    var _partition = function(fa, predicate) {
      return _partitionWithIndex(fa, function(_2, a) {
        return predicate(a);
      });
    };
    var _partitionMap = function(fa, f2) {
      return _partitionMapWithIndex(fa, function(_2, a) {
        return f2(a);
      });
    };
    var _filterWithIndex = function(fa, p) {
      return (0, function_1.pipe)(fa, filterWithIndex(p));
    };
    var _filterMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f2));
    };
    var _partitionWithIndex = function(fa, p) {
      return (0, function_1.pipe)(fa, partitionWithIndex(p));
    };
    var _partitionMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f2));
    };
    var compact = function(fa) {
      var m = /* @__PURE__ */ new Map();
      var entries = fa.entries();
      var e;
      while (!(e = entries.next()).done) {
        var _a2 = e.value, k = _a2[0], oa = _a2[1];
        if (_.isSome(oa)) {
          m.set(k, oa.value);
        }
      }
      return m;
    };
    exports.compact = compact;
    var filter2 = function(predicate) {
      return function(fa) {
        return _filter2(fa, predicate);
      };
    };
    exports.filter = filter2;
    var filterMap = function(f2) {
      return function(fa) {
        return _filterMap(fa, f2);
      };
    };
    exports.filterMap = filterMap;
    var map = function(f2) {
      return function(fa) {
        return _map2(fa, f2);
      };
    };
    exports.map = map;
    var mapWithIndex = function(f2) {
      return function(fa) {
        return _mapWithIndex(fa, f2);
      };
    };
    exports.mapWithIndex = mapWithIndex;
    var partition = function(predicate) {
      return function(fa) {
        return _partition(fa, predicate);
      };
    };
    exports.partition = partition;
    var partitionMap = function(f2) {
      return function(fa) {
        return _partitionMap(fa, f2);
      };
    };
    exports.partitionMap = partitionMap;
    var separate = function(fa) {
      var left = /* @__PURE__ */ new Map();
      var right = /* @__PURE__ */ new Map();
      var entries = fa.entries();
      var e;
      while (!(e = entries.next()).done) {
        var _a2 = e.value, k = _a2[0], ei = _a2[1];
        if (_.isLeft(ei)) {
          left.set(k, ei.left);
        } else {
          right.set(k, ei.right);
        }
      }
      return (0, Separated_1.separated)(left, right);
    };
    exports.separate = separate;
    exports.URI = "Map";
    var getUnionSemigroup = function(E, S) {
      var unionES = (0, exports.union)(E, S);
      return {
        concat: function(first, second) {
          return unionES(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(E, S) {
      return {
        concat: (0, exports.getUnionSemigroup)(E, S).concat,
        empty: /* @__PURE__ */ new Map()
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(E, S) {
      var intersectionES = (0, exports.intersection)(E, S);
      return {
        concat: function(first, second) {
          return intersectionES(second)(first);
        }
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function(E) {
      return function() {
        var differenceE = (0, exports.difference)(E);
        return {
          concat: function(first, second) {
            return differenceE(second)(first);
          }
        };
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    function getFilterableWithIndex() {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter2,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex
      };
    }
    exports.getFilterableWithIndex = getFilterableWithIndex;
    function getWitherable(O2) {
      var TWI = (0, exports.getTraversableWithIndex)(O2);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter2,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        reduce: TWI.reduce,
        foldMap: TWI.foldMap,
        reduceRight: TWI.reduceRight,
        traverse: TWI.traverse,
        sequence: TWI.sequence,
        mapWithIndex: _mapWithIndex,
        reduceWithIndex: TWI.reduceWithIndex,
        foldMapWithIndex: TWI.foldMapWithIndex,
        reduceRightWithIndex: TWI.reduceRightWithIndex,
        traverseWithIndex: TWI.traverseWithIndex,
        wilt: (0, Witherable_1.wiltDefault)(TWI, exports.Compactable),
        wither: (0, Witherable_1.witherDefault)(TWI, exports.Compactable)
      };
    }
    exports.getWitherable = getWitherable;
    exports.reduce = RM.reduce;
    exports.foldMap = RM.foldMap;
    exports.reduceRight = RM.reduceRight;
    var getFoldable = function(O2) {
      return __assign(__assign({}, RM.getFoldable(O2)), { URI: exports.URI });
    };
    exports.getFoldable = getFoldable;
    exports.reduceWithIndex = RM.reduceWithIndex;
    exports.foldMapWithIndex = RM.foldMapWithIndex;
    exports.reduceRightWithIndex = RM.reduceRightWithIndex;
    var getFoldableWithIndex = function(O2) {
      return __assign(__assign({}, RM.getFoldableWithIndex(O2)), { URI: exports.URI });
    };
    exports.getFoldableWithIndex = getFoldableWithIndex;
    var getTraversableWithIndex = function(O2) {
      var FWI = (0, exports.getFoldableWithIndex)(O2);
      var keysO = (0, exports.keys)(O2);
      var traverseWithIndex = function(F) {
        return function(ta, f2) {
          var fm = F.of(/* @__PURE__ */ new Map());
          var ks = keysO(ta);
          var len = ks.length;
          var _loop_1 = function(i2) {
            var key = ks[i2];
            var a = ta.get(key);
            fm = F.ap(F.map(fm, function(m) {
              return function(b) {
                return m.set(key, b);
              };
            }), f2(key, a));
          };
          for (var i = 0; i < len; i++) {
            _loop_1(i);
          }
          return fm;
        };
      };
      var traverse = function(F) {
        var traverseWithIndexF = traverseWithIndex(F);
        return function(ta, f2) {
          return traverseWithIndexF(ta, function(_2, a) {
            return f2(a);
          });
        };
      };
      var sequence = function(F) {
        var traverseWithIndexF = traverseWithIndex(F);
        return function(ta) {
          return traverseWithIndexF(ta, function(_2, a) {
            return a;
          });
        };
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        mapWithIndex: _mapWithIndex,
        reduce: FWI.reduce,
        foldMap: FWI.foldMap,
        reduceRight: FWI.reduceRight,
        reduceWithIndex: FWI.reduceWithIndex,
        foldMapWithIndex: FWI.foldMapWithIndex,
        reduceRightWithIndex: FWI.reduceRightWithIndex,
        traverse,
        sequence,
        traverseWithIndex
      };
    };
    exports.getTraversableWithIndex = getTraversableWithIndex;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    var copy = function(m) {
      return new Map(m);
    };
    var union = function(E, M) {
      var unionEM = RM.union(E, M);
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return copy(second);
          }
          if ((0, exports.isEmpty)(second)) {
            return copy(first);
          }
          return unionEM(second)(first);
        };
      };
    };
    exports.union = union;
    var intersection = function(E, M) {
      var intersectionEM = RM.intersection(E, M);
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
            return /* @__PURE__ */ new Map();
          }
          return intersectionEM(second)(first);
        };
      };
    };
    exports.intersection = intersection;
    var difference = function(E) {
      var differenceE = RM.difference(E);
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return copy(second);
          }
          if ((0, exports.isEmpty)(second)) {
            return copy(first);
          }
          return differenceE(second)(first);
        };
      };
    };
    exports.difference = difference;
    exports.empty = /* @__PURE__ */ new Map();
    exports.insertAt = exports.upsertAt;
    exports.map_ = exports.Filterable;
  }
});

// node_modules/fp-ts/lib/MeetSemilattice.js
var require_MeetSemilattice = __commonJS({
  "node_modules/fp-ts/lib/MeetSemilattice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Monad.js
var require_Monad = __commonJS({
  "node_modules/fp-ts/lib/Monad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/MonadIO.js
var require_MonadIO = __commonJS({
  "node_modules/fp-ts/lib/MonadIO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/MonadTask.js
var require_MonadTask = __commonJS({
  "node_modules/fp-ts/lib/MonadTask.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/MonadThrow.js
var require_MonadThrow = __commonJS({
  "node_modules/fp-ts/lib/MonadThrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Monoid.js
var require_Monoid = __commonJS({
  "node_modules/fp-ts/lib/Monoid.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.monoidProduct = exports.monoidSum = exports.monoidString = exports.getEndomorphismMonoid = exports.getFunctionMonoid = exports.monoidAny = exports.monoidAll = exports.fold = exports.getMeetMonoid = exports.getJoinMonoid = exports.getDualMonoid = exports.getStructMonoid = exports.getTupleMonoid = exports.monoidVoid = exports.concatAll = exports.tuple = exports.struct = exports.reverse = exports.max = exports.min = void 0;
    var Endomorphism_1 = require_Endomorphism();
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    var Se = __importStar(require_Semigroup());
    var min = function(B) {
      return {
        concat: Se.min(B).concat,
        empty: B.top
      };
    };
    exports.min = min;
    var max = function(B) {
      return {
        concat: Se.max(B).concat,
        empty: B.bottom
      };
    };
    exports.max = max;
    var reverse = function(M) {
      return {
        concat: Se.reverse(M).concat,
        empty: M.empty
      };
    };
    exports.reverse = reverse;
    var struct = function(monoids) {
      var empty = {};
      for (var k in monoids) {
        if (_.has.call(monoids, k)) {
          empty[k] = monoids[k].empty;
        }
      }
      return {
        concat: Se.struct(monoids).concat,
        empty
      };
    };
    exports.struct = struct;
    var tuple = function() {
      var monoids = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        monoids[_i] = arguments[_i];
      }
      return {
        concat: Se.tuple.apply(Se, monoids).concat,
        empty: monoids.map(function(m) {
          return m.empty;
        })
      };
    };
    exports.tuple = tuple;
    var concatAll = function(M) {
      return Se.concatAll(M)(M.empty);
    };
    exports.concatAll = concatAll;
    exports.monoidVoid = {
      concat: Se.semigroupVoid.concat,
      empty: void 0
    };
    exports.getTupleMonoid = exports.tuple;
    exports.getStructMonoid = exports.struct;
    exports.getDualMonoid = exports.reverse;
    exports.getJoinMonoid = exports.max;
    exports.getMeetMonoid = exports.min;
    exports.fold = exports.concatAll;
    exports.monoidAll = {
      concat: Se.semigroupAll.concat,
      empty: true
    };
    exports.monoidAny = {
      concat: Se.semigroupAny.concat,
      empty: false
    };
    exports.getFunctionMonoid = function_1.getMonoid;
    var getEndomorphismMonoid = function() {
      return (0, exports.reverse)((0, Endomorphism_1.getMonoid)());
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
    exports.monoidString = {
      concat: Se.semigroupString.concat,
      empty: ""
    };
    exports.monoidSum = {
      concat: Se.semigroupSum.concat,
      empty: 0
    };
    exports.monoidProduct = {
      concat: Se.semigroupProduct.concat,
      empty: 1
    };
  }
});

// node_modules/fp-ts/lib/NaturalTransformation.js
var require_NaturalTransformation = __commonJS({
  "node_modules/fp-ts/lib/NaturalTransformation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Ordering.js
var require_Ordering = __commonJS({
  "node_modules/fp-ts/lib/Ordering.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.monoidOrdering = exports.eqOrdering = exports.semigroupOrdering = exports.invert = exports.sign = exports.Monoid = exports.Semigroup = exports.Eq = exports.reverse = exports.match = exports.matchW = void 0;
    var matchW = function(onLessThan, onEqual, onGreaterThan) {
      return function(o) {
        return o === -1 ? onLessThan() : o === 0 ? onEqual() : onGreaterThan();
      };
    };
    exports.matchW = matchW;
    exports.match = exports.matchW;
    var reverse = function(o) {
      return o === -1 ? 1 : o === 1 ? -1 : 0;
    };
    exports.reverse = reverse;
    exports.Eq = {
      equals: function(x, y) {
        return x === y;
      }
    };
    exports.Semigroup = {
      concat: function(x, y) {
        return x !== 0 ? x : y;
      }
    };
    exports.Monoid = {
      concat: exports.Semigroup.concat,
      empty: 0
    };
    var sign = function(n) {
      return n <= -1 ? -1 : n >= 1 ? 1 : 0;
    };
    exports.sign = sign;
    exports.invert = exports.reverse;
    exports.semigroupOrdering = exports.Semigroup;
    exports.eqOrdering = exports.Eq;
    exports.monoidOrdering = exports.Monoid;
  }
});

// node_modules/fp-ts/lib/pipeable.js
var require_pipeable = __commonJS({
  "node_modules/fp-ts/lib/pipeable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pipe = exports.pipeable = exports.compose = exports.promap = exports.partitionMapWithIndex = exports.partitionWithIndex = exports.filterMapWithIndex = exports.filterWithIndex = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.alt = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.reduceRight = exports.foldMap = exports.reduce = exports.extend = exports.mapLeft = exports.bimap = exports.chain = exports.ap = exports.mapWithIndex = exports.contramap = exports.map = void 0;
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    function map(F) {
      return function(f2) {
        return function(fa) {
          return F.map(fa, f2);
        };
      };
    }
    exports.map = map;
    function contramap(F) {
      return function(f2) {
        return function(fa) {
          return F.contramap(fa, f2);
        };
      };
    }
    exports.contramap = contramap;
    function mapWithIndex(F) {
      return function(f2) {
        return function(fa) {
          return F.mapWithIndex(fa, f2);
        };
      };
    }
    exports.mapWithIndex = mapWithIndex;
    function ap(F) {
      return function(fa) {
        return function(fab) {
          return F.ap(fab, fa);
        };
      };
    }
    exports.ap = ap;
    function chain(F) {
      return function(f2) {
        return function(fa) {
          return F.chain(fa, f2);
        };
      };
    }
    exports.chain = chain;
    function bimap(F) {
      return function(f2, g) {
        return function(fea) {
          return F.bimap(fea, f2, g);
        };
      };
    }
    exports.bimap = bimap;
    function mapLeft(F) {
      return function(f2) {
        return function(fea) {
          return F.mapLeft(fea, f2);
        };
      };
    }
    exports.mapLeft = mapLeft;
    function extend(F) {
      return function(f2) {
        return function(wa) {
          return F.extend(wa, f2);
        };
      };
    }
    exports.extend = extend;
    function reduce(F) {
      return function(b, f2) {
        return function(fa) {
          return F.reduce(fa, b, f2);
        };
      };
    }
    exports.reduce = reduce;
    function foldMap(F) {
      return function(M) {
        var foldMapM = F.foldMap(M);
        return function(f2) {
          return function(fa) {
            return foldMapM(fa, f2);
          };
        };
      };
    }
    exports.foldMap = foldMap;
    function reduceRight(F) {
      return function(b, f2) {
        return function(fa) {
          return F.reduceRight(fa, b, f2);
        };
      };
    }
    exports.reduceRight = reduceRight;
    function reduceWithIndex(F) {
      return function(b, f2) {
        return function(fa) {
          return F.reduceWithIndex(fa, b, f2);
        };
      };
    }
    exports.reduceWithIndex = reduceWithIndex;
    function foldMapWithIndex(F) {
      return function(M) {
        var foldMapWithIndexM = F.foldMapWithIndex(M);
        return function(f2) {
          return function(fa) {
            return foldMapWithIndexM(fa, f2);
          };
        };
      };
    }
    exports.foldMapWithIndex = foldMapWithIndex;
    function reduceRightWithIndex(F) {
      return function(b, f2) {
        return function(fa) {
          return F.reduceRightWithIndex(fa, b, f2);
        };
      };
    }
    exports.reduceRightWithIndex = reduceRightWithIndex;
    function alt(F) {
      return function(that) {
        return function(fa) {
          return F.alt(fa, that);
        };
      };
    }
    exports.alt = alt;
    function filter2(F) {
      return function(predicate) {
        return function(fa) {
          return F.filter(fa, predicate);
        };
      };
    }
    exports.filter = filter2;
    function filterMap(F) {
      return function(f2) {
        return function(fa) {
          return F.filterMap(fa, f2);
        };
      };
    }
    exports.filterMap = filterMap;
    function partition(F) {
      return function(f2) {
        return function(fa) {
          return F.partition(fa, f2);
        };
      };
    }
    exports.partition = partition;
    function partitionMap(F) {
      return function(f2) {
        return function(fa) {
          return F.partitionMap(fa, f2);
        };
      };
    }
    exports.partitionMap = partitionMap;
    function filterWithIndex(F) {
      return function(predicate) {
        return function(fa) {
          return F.filterWithIndex(fa, predicate);
        };
      };
    }
    exports.filterWithIndex = filterWithIndex;
    function filterMapWithIndex(F) {
      return function(f2) {
        return function(fa) {
          return F.filterMapWithIndex(fa, f2);
        };
      };
    }
    exports.filterMapWithIndex = filterMapWithIndex;
    function partitionWithIndex(F) {
      return function(f2) {
        return function(fa) {
          return F.partitionWithIndex(fa, f2);
        };
      };
    }
    exports.partitionWithIndex = partitionWithIndex;
    function partitionMapWithIndex(F) {
      return function(f2) {
        return function(fa) {
          return F.partitionMapWithIndex(fa, f2);
        };
      };
    }
    exports.partitionMapWithIndex = partitionMapWithIndex;
    function promap(F) {
      return function(f2, g) {
        return function(fbc) {
          return F.promap(fbc, f2, g);
        };
      };
    }
    exports.promap = promap;
    function compose2(F) {
      return function(ea) {
        return function(ab) {
          return F.compose(ab, ea);
        };
      };
    }
    exports.compose = compose2;
    var isFunctor = function(I) {
      return typeof I.map === "function";
    };
    var isContravariant = function(I) {
      return typeof I.contramap === "function";
    };
    var isFunctorWithIndex = function(I) {
      return typeof I.mapWithIndex === "function";
    };
    var isApply = function(I) {
      return typeof I.ap === "function";
    };
    var isChain = function(I) {
      return typeof I.chain === "function";
    };
    var isBifunctor = function(I) {
      return typeof I.bimap === "function";
    };
    var isExtend = function(I) {
      return typeof I.extend === "function";
    };
    var isFoldable = function(I) {
      return typeof I.reduce === "function";
    };
    var isFoldableWithIndex = function(I) {
      return typeof I.reduceWithIndex === "function";
    };
    var isAlt = function(I) {
      return typeof I.alt === "function";
    };
    var isCompactable = function(I) {
      return typeof I.compact === "function";
    };
    var isFilterable = function(I) {
      return typeof I.filter === "function";
    };
    var isFilterableWithIndex = function(I) {
      return typeof I.filterWithIndex === "function";
    };
    var isProfunctor = function(I) {
      return typeof I.promap === "function";
    };
    var isSemigroupoid = function(I) {
      return typeof I.compose === "function";
    };
    var isMonadThrow = function(I) {
      return typeof I.throwError === "function";
    };
    function pipeable(I) {
      var r = {};
      if (isFunctor(I)) {
        r.map = map(I);
      }
      if (isContravariant(I)) {
        r.contramap = contramap(I);
      }
      if (isFunctorWithIndex(I)) {
        r.mapWithIndex = mapWithIndex(I);
      }
      if (isApply(I)) {
        r.ap = ap(I);
        r.apFirst = (0, Apply_1.apFirst)(I);
        r.apSecond = (0, Apply_1.apSecond)(I);
      }
      if (isChain(I)) {
        r.chain = chain(I);
        r.chainFirst = (0, Chain_1.chainFirst)(I);
        r.flatten = r.chain(function_1.identity);
      }
      if (isBifunctor(I)) {
        r.bimap = bimap(I);
        r.mapLeft = mapLeft(I);
      }
      if (isExtend(I)) {
        r.extend = extend(I);
        r.duplicate = r.extend(function_1.identity);
      }
      if (isFoldable(I)) {
        r.reduce = reduce(I);
        r.foldMap = foldMap(I);
        r.reduceRight = reduceRight(I);
      }
      if (isFoldableWithIndex(I)) {
        r.reduceWithIndex = reduceWithIndex(I);
        r.foldMapWithIndex = foldMapWithIndex(I);
        r.reduceRightWithIndex = reduceRightWithIndex(I);
      }
      if (isAlt(I)) {
        r.alt = alt(I);
      }
      if (isCompactable(I)) {
        r.compact = I.compact;
        r.separate = I.separate;
      }
      if (isFilterable(I)) {
        r.filter = filter2(I);
        r.filterMap = filterMap(I);
        r.partition = partition(I);
        r.partitionMap = partitionMap(I);
      }
      if (isFilterableWithIndex(I)) {
        r.filterWithIndex = filterWithIndex(I);
        r.filterMapWithIndex = filterMapWithIndex(I);
        r.partitionWithIndex = partitionWithIndex(I);
        r.partitionMapWithIndex = partitionMapWithIndex(I);
      }
      if (isProfunctor(I)) {
        r.promap = promap(I);
      }
      if (isSemigroupoid(I)) {
        r.compose = compose2(I);
      }
      if (isMonadThrow(I)) {
        var fromOption = function(onNone) {
          return function(ma) {
            return ma._tag === "None" ? I.throwError(onNone()) : I.of(ma.value);
          };
        };
        var fromEither = function(ma) {
          return ma._tag === "Left" ? I.throwError(ma.left) : I.of(ma.right);
        };
        var fromPredicate = function(predicate, onFalse) {
          return function(a) {
            return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
          };
        };
        var filterOrElse = function(predicate, onFalse) {
          return function(ma) {
            return I.chain(ma, function(a) {
              return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
            });
          };
        };
        r.fromOption = fromOption;
        r.fromEither = fromEither;
        r.fromPredicate = fromPredicate;
        r.filterOrElse = filterOrElse;
      }
      return r;
    }
    exports.pipeable = pipeable;
    exports.pipe = function_1.pipe;
  }
});

// node_modules/fp-ts/lib/Pointed.js
var require_Pointed = __commonJS({
  "node_modules/fp-ts/lib/Pointed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Profunctor.js
var require_Profunctor = __commonJS({
  "node_modules/fp-ts/lib/Profunctor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Random.js
var require_Random = __commonJS({
  "node_modules/fp-ts/lib/Random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomElem = exports.randomBool = exports.randomRange = exports.randomInt = exports.random = void 0;
    var function_1 = require_function();
    var IO_1 = require_IO();
    var random = function() {
      return Math.random();
    };
    exports.random = random;
    function randomInt(low, high) {
      return (0, function_1.pipe)(exports.random, (0, IO_1.map)(function(n) {
        return Math.floor((high - low + 1) * n + low);
      }));
    }
    exports.randomInt = randomInt;
    function randomRange(min, max) {
      return (0, function_1.pipe)(exports.random, (0, IO_1.map)(function(n) {
        return (max - min) * n + min;
      }));
    }
    exports.randomRange = randomRange;
    exports.randomBool = (0, function_1.pipe)(exports.random, (0, IO_1.map)(function(n) {
      return n < 0.5;
    }));
    var randomElem = function(as) {
      return (0, function_1.pipe)(randomInt(0, as.length - 1), (0, IO_1.map)(function(i) {
        return as[i];
      }));
    };
    exports.randomElem = randomElem;
  }
});

// node_modules/fp-ts/lib/ReaderEither.js
var require_ReaderEither = __commonJS({
  "node_modules/fp-ts/lib/ReaderEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apFirstW = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.getAltReaderValidation = exports.getApplicativeReaderValidation = exports.getFilterable = exports.getCompactable = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.flatMap = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.mapError = exports.bimap = exports.mapBoth = exports.map = exports.swap = exports.orLeft = exports.tapError = exports.orElseW = exports.orElse = exports.asksReaderEither = exports.asksReaderEitherW = exports.local = exports.toUnion = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromReader = exports.fromEither = exports.leftReader = exports.rightReader = exports.right = exports.left = void 0;
    exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainReaderKW = exports.chainReaderK = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.flatMapReader = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.MonadThrow = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.Alt = exports.Bifunctor = exports.tapReader = exports.tapEither = exports.tap = exports.FromReader = exports.FromEither = exports.Monad = exports.Chain = exports.Applicative = exports.apSecondW = exports.apSecond = void 0;
    exports.getReaderValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.readerEither = exports.orElseFirstW = exports.orElseFirst = exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.sequenceArray = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var Compactable_1 = require_Compactable();
    var E = __importStar(require_Either());
    var ET = __importStar(require_EitherT());
    var Filterable_1 = require_Filterable();
    var FromEither_1 = require_FromEither();
    var FromReader_1 = require_FromReader();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var R = __importStar(require_Reader());
    exports.left = ET.left(R.Pointed);
    exports.right = ET.right(R.Pointed);
    exports.rightReader = /* @__PURE__ */ ET.rightF(R.Functor);
    exports.leftReader = ET.leftF(R.Functor);
    exports.fromEither = R.of;
    exports.fromReader = exports.rightReader;
    exports.match = ET.match(R.Functor);
    exports.matchW = exports.match;
    exports.matchE = ET.matchE(R.Monad);
    exports.fold = exports.matchE;
    exports.matchEW = exports.matchE;
    exports.foldW = exports.matchEW;
    exports.getOrElse = /* @__PURE__ */ ET.getOrElse(R.Monad);
    exports.getOrElseW = exports.getOrElse;
    exports.toUnion = ET.toUnion(R.Functor);
    exports.local = R.local;
    exports.asksReaderEitherW = R.asksReaderW;
    exports.asksReaderEither = exports.asksReaderEitherW;
    exports.orElse = ET.orElse(R.Monad);
    exports.orElseW = exports.orElse;
    exports.tapError = (0, function_1.dual)(2, ET.tapError(R.Monad));
    exports.orLeft = ET.orLeft(R.Monad);
    exports.swap = ET.swap(R.Functor);
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    exports.map = /* @__PURE__ */ ET.map(R.Functor);
    exports.mapBoth = (0, function_1.dual)(3, ET.mapBoth(R.Functor));
    exports.bimap = exports.mapBoth;
    exports.mapError = (0, function_1.dual)(2, ET.mapError(R.Functor));
    exports.mapLeft = exports.mapError;
    exports.ap = ET.ap(R.Apply);
    exports.apW = exports.ap;
    exports.of = exports.right;
    exports.flatMap = (0, function_1.dual)(2, ET.flatMap(R.Monad));
    exports.flattenW = (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.alt = /* @__PURE__ */ ET.alt(R.Monad);
    exports.altW = exports.alt;
    exports.throwError = exports.left;
    exports.URI = "ReaderEither";
    var getCompactable = function(M) {
      var C = E.getCompactable(M);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: (0, Compactable_1.compact)(R.Functor, C),
        separate: (0, Compactable_1.separate)(R.Functor, C, E.Functor)
      };
    };
    exports.getCompactable = getCompactable;
    function getFilterable(M) {
      var F = E.getFilterable(M);
      var C = (0, exports.getCompactable)(M);
      var filter2 = (0, Filterable_1.filter)(R.Functor, F);
      var filterMap = (0, Filterable_1.filterMap)(R.Functor, F);
      var partition = (0, Filterable_1.partition)(R.Functor, F);
      var partitionMap = (0, Filterable_1.partitionMap)(R.Functor, F);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: C.compact,
        separate: C.separate,
        filter: function(fa, predicate) {
          return (0, function_1.pipe)(fa, filter2(predicate));
        },
        filterMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, filterMap(f2));
        },
        partition: function(fa, predicate) {
          return (0, function_1.pipe)(fa, partition(predicate));
        },
        partitionMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, partitionMap(f2));
        }
      };
    }
    exports.getFilterable = getFilterable;
    function getApplicativeReaderValidation(S) {
      var ap = (0, Apply_1.ap)(R.Apply, E.getApplicativeValidation(S));
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, ap(fa));
        },
        of: exports.of
      };
    }
    exports.getApplicativeReaderValidation = getApplicativeReaderValidation;
    function getAltReaderValidation(S) {
      var alt = ET.altValidation(R.Monad, S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        alt: function(fa, that) {
          return (0, function_1.pipe)(fa, alt(that));
        }
      };
    }
    exports.getAltReaderValidation = getAltReaderValidation;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.FromReader = {
      URI: exports.URI,
      fromReader: exports.fromReader
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.tapReader = (0, function_1.dual)(2, (0, FromReader_1.tapReader)(exports.FromReader, exports.Chain));
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.ask = (0, FromReader_1.ask)(exports.FromReader);
    exports.asks = (0, FromReader_1.asks)(exports.FromReader);
    exports.fromReaderK = (0, FromReader_1.fromReaderK)(exports.FromReader);
    exports.chainFirstReaderK = exports.tapReader;
    exports.chainFirstReaderKW = exports.tapReader;
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      throwError: exports.throwError
    };
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.fromOptionK = (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = /* @__PURE__ */ (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.chainOptionKW = exports.chainOptionK;
    var _FromEither = {
      fromEither: exports.FromEither.fromEither
    };
    var _FromReader = {
      fromReader: exports.FromReader.fromReader
    };
    exports.liftNullable = _.liftNullable(_FromEither);
    exports.liftOption = _.liftOption(_FromEither);
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
    exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
    exports.flatMapEither = _.flatMapEither(_FromEither, _FlatMap);
    exports.flatMapReader = _.flatMapReader(_FromReader, _FlatMap);
    exports.chainEitherK = exports.flatMapEither;
    exports.chainEitherKW = exports.flatMapEither;
    exports.chainFirstEitherK = exports.tapEither;
    exports.chainFirstEitherKW = exports.tapEither;
    exports.chainReaderK = exports.flatMapReader;
    exports.chainReaderKW = exports.flatMapReader;
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(R.traverseReadonlyNonEmptyArrayWithIndex(f2), R.map(E.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = (0, exports.traverseArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainW = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    exports.orElseFirst = exports.tapError;
    exports.orElseFirstW = exports.tapError;
    exports.readerEither = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      alt: _alt,
      throwError: exports.left
    };
    exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
    var getSemigroup = function(S) {
      return (0, Apply_1.getApplySemigroup)(R.Apply)(E.getSemigroup(S));
    };
    exports.getSemigroup = getSemigroup;
    function getReaderValidation(SE) {
      var applicativeReaderValidation = getApplicativeReaderValidation(SE);
      var altReaderValidation = getAltReaderValidation(SE);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: applicativeReaderValidation.ap,
        of: exports.of,
        chain: exports.flatMap,
        bimap: exports.mapBoth,
        mapLeft: exports.mapError,
        alt: altReaderValidation.alt,
        throwError: exports.throwError
      };
    }
    exports.getReaderValidation = getReaderValidation;
  }
});

// node_modules/fp-ts/lib/ReaderT.js
var require_ReaderT = __commonJS({
  "node_modules/fp-ts/lib/ReaderT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getReaderM = exports.fromNaturalTransformation = exports.fromReader = exports.flatMap = exports.chain = exports.ap = exports.map = exports.of = void 0;
    var function_1 = require_function();
    function of(F) {
      return function(a) {
        return function() {
          return F.of(a);
        };
      };
    }
    exports.of = of;
    function map(F) {
      return function(f2) {
        return function(fa) {
          return function(r) {
            return F.map(fa(r), f2);
          };
        };
      };
    }
    exports.map = map;
    function ap(F) {
      return function(fa) {
        return function(fab) {
          return function(r) {
            return F.ap(fab(r), fa(r));
          };
        };
      };
    }
    exports.ap = ap;
    function chain(M) {
      var flatMapM = flatMap(M);
      return function(f2) {
        return function(ma) {
          return flatMapM(ma, f2);
        };
      };
    }
    exports.chain = chain;
    function flatMap(M) {
      return function(ma, f2) {
        return function(r) {
          return M.chain(ma(r), function(a) {
            return f2(a)(r);
          });
        };
      };
    }
    exports.flatMap = flatMap;
    function fromReader(F) {
      return function(ma) {
        return (0, function_1.flow)(ma, F.of);
      };
    }
    exports.fromReader = fromReader;
    function fromNaturalTransformation(nt) {
      return function(f2) {
        return (0, function_1.flow)(f2, nt);
      };
    }
    exports.fromNaturalTransformation = fromNaturalTransformation;
    function getReaderM(M) {
      var _ap = ap(M);
      var _map2 = map(M);
      var _chain = chain(M);
      return {
        map: function(fa, f2) {
          return (0, function_1.pipe)(fa, _map2(f2));
        },
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, _ap(fa));
        },
        of: of(M),
        chain: function(ma, f2) {
          return (0, function_1.pipe)(ma, _chain(f2));
        },
        ask: function() {
          return M.of;
        },
        asks: function(f2) {
          return (0, function_1.flow)(f2, M.of);
        },
        local: function(ma, f2) {
          return function(q) {
            return ma(f2(q));
          };
        },
        fromReader: fromReader(M),
        fromM: function(ma) {
          return function() {
            return ma;
          };
        }
      };
    }
    exports.getReaderM = getReaderM;
  }
});

// node_modules/fp-ts/lib/ReaderIO.js
var require_ReaderIO = __commonJS({
  "node_modules/fp-ts/lib/ReaderIO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.tapReader = exports.tapIO = exports.tap = exports.flatMapReader = exports.flatMapIO = exports.FromReader = exports.FromIO = exports.MonadIO = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.URI = exports.flatten = exports.flattenW = exports.flatMap = exports.of = exports.apW = exports.ap = exports.map = exports.asksReaderIO = exports.asksReaderIOW = exports.local = exports.fromIO = exports.fromReader = void 0;
    exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = void 0;
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var FromIO_1 = require_FromIO();
    var FromReader_1 = require_FromReader();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var I = __importStar(require_IO());
    var R = __importStar(require_Reader());
    var RT = __importStar(require_ReaderT());
    exports.fromReader = RT.fromReader(I.Pointed);
    exports.fromIO = R.of;
    exports.local = R.local;
    exports.asksReaderIOW = R.asksReaderW;
    exports.asksReaderIO = exports.asksReaderIOW;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    exports.map = RT.map(I.Functor);
    exports.ap = /* @__PURE__ */ RT.ap(I.Apply);
    exports.apW = exports.ap;
    exports.of = RT.of(I.Pointed);
    exports.flatMap = (0, function_1.dual)(2, RT.flatMap(I.Monad));
    exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.URI = "ReaderIO";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.FromReader = {
      URI: exports.URI,
      fromReader: exports.fromReader
    };
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    var _FromIO = {
      fromIO: exports.FromIO.fromIO
    };
    var _FromReader = {
      fromReader: exports.fromReader
    };
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.flatMapReader = _.flatMapReader(_FromReader, _FlatMap);
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.tapReader = (0, function_1.dual)(2, (0, FromReader_1.tapReader)(exports.FromReader, exports.Chain));
    exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.ask = (0, FromReader_1.ask)(exports.FromReader);
    exports.asks = (0, FromReader_1.asks)(exports.FromReader);
    exports.fromReaderK = (0, FromReader_1.fromReaderK)(exports.FromReader);
    exports.chainReaderK = exports.flatMapReader;
    exports.chainReaderKW = exports.flatMapReader;
    exports.chainFirstReaderK = exports.tapReader;
    exports.chainFirstReaderKW = exports.tapReader;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(R.traverseReadonlyNonEmptyArrayWithIndex(f2), R.map(I.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainW = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
  }
});

// node_modules/fp-ts/lib/Task.js
var require_Task = __commonJS({
  "node_modules/fp-ts/lib/Task.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.never = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.tapIO = exports.tap = exports.flatMapIO = exports.FromIO = exports.MonadTask = exports.fromTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.getRaceMonoid = exports.URI = exports.flatten = exports.flatMap = exports.of = exports.ap = exports.map = exports.delay = exports.fromIO = void 0;
    exports.getMonoid = exports.getSemigroup = exports.taskSeq = exports.task = exports.chainFirst = exports.chain = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var FromIO_1 = require_FromIO();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var fromIO = function(ma) {
      return function() {
        return Promise.resolve().then(ma);
      };
    };
    exports.fromIO = fromIO;
    function delay(millis) {
      return function(ma) {
        return function() {
          return new Promise(function(resolve) {
            setTimeout(function() {
              Promise.resolve().then(ma).then(resolve);
            }, millis);
          });
        };
      };
    }
    exports.delay = delay;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _apPar = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _apSeq = function(fab, fa) {
      return (0, exports.flatMap)(fab, function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    var map = function(f2) {
      return function(fa) {
        return function() {
          return Promise.resolve().then(fa).then(f2);
        };
      };
    };
    exports.map = map;
    var ap = function(fa) {
      return function(fab) {
        return function() {
          return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function(_a2) {
            var f2 = _a2[0], a = _a2[1];
            return f2(a);
          });
        };
      };
    };
    exports.ap = ap;
    var of = function(a) {
      return function() {
        return Promise.resolve(a);
      };
    };
    exports.of = of;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      return function() {
        return Promise.resolve().then(ma).then(function(a) {
          return f2(a)();
        });
      };
    });
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    exports.URI = "Task";
    function getRaceMonoid() {
      return {
        concat: function(x, y) {
          return function() {
            return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]);
          };
        },
        empty: exports.never
      };
    }
    exports.getRaceMonoid = getRaceMonoid;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.ApplyPar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
    exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
    exports.ApplicativePar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      of: exports.of
    };
    exports.ApplySeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq
    };
    exports.ApplicativeSeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.fromTask = function_1.identity;
    exports.MonadTask = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    var _FromIO = {
      fromIO: exports.FromIO.fromIO
    };
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.fromIOK = /* @__PURE__ */ (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.FromTask = {
      URI: exports.URI,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    var never = function() {
      return new Promise(function(_2) {
        return void 0;
      });
    };
    exports.never = never;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return function(as) {
        return function() {
          return Promise.all(as.map(function(a, i) {
            return Promise.resolve().then(function() {
              return f2(i, a)();
            });
          }));
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f2) {
      return function(as) {
        return function() {
          return _.tail(as).reduce(function(acc, a, i) {
            return acc.then(function(bs) {
              return Promise.resolve().then(f2(i + 1, a)).then(function(b) {
                bs.push(b);
                return bs;
              });
            });
          }, Promise.resolve().then(f2(0, _.head(as))).then(_.singleton));
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
    var traverseReadonlyArrayWithIndexSeq = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
    var traverseSeqArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndexSeq)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseSeqArray = traverseSeqArray;
    exports.sequenceSeqArray = /* @__PURE__ */ (0, exports.traverseSeqArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.task = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.taskSeq = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apSeq,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.getSemigroup = (0, Apply_1.getApplySemigroup)(exports.ApplySeq);
    exports.getMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.ApplicativeSeq);
  }
});

// node_modules/fp-ts/lib/ReaderTask.js
var require_ReaderTask = __commonJS({
  "node_modules/fp-ts/lib/ReaderTask.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.tapReaderIO = exports.tapTask = exports.tapReader = exports.tapIO = exports.tap = exports.flatMapReaderIO = exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.FromReader = exports.FromTask = exports.FromIO = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.URI = exports.flatten = exports.flattenW = exports.flatMap = exports.of = exports.apW = exports.ap = exports.map = exports.asksReaderTask = exports.asksReaderTaskW = exports.local = exports.fromReaderIO = exports.fromIO = exports.fromTask = exports.fromReader = void 0;
    exports.run = exports.getMonoid = exports.getSemigroup = exports.readerTaskSeq = exports.readerTask = exports.sequenceSeqArray = exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.chainFirstReaderIOK = exports.chainFirstReaderIOKW = exports.chainReaderIOK = exports.chainReaderIOKW = exports.fromReaderIOK = exports.chainFirstReaderKW = exports.chainFirstReaderK = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var FromIO_1 = require_FromIO();
    var FromReader_1 = require_FromReader();
    var FromTask_1 = require_FromTask();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var R = __importStar(require_Reader());
    var RT = __importStar(require_ReaderT());
    var T = __importStar(require_Task());
    exports.fromReader = RT.fromReader(T.Pointed);
    exports.fromTask = R.of;
    exports.fromIO = (0, function_1.flow)(T.fromIO, exports.fromTask);
    exports.fromReaderIO = R.map(T.fromIO);
    exports.local = R.local;
    exports.asksReaderTaskW = R.asksReaderW;
    exports.asksReaderTask = exports.asksReaderTaskW;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _apPar = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _apSeq = function(fab, fa) {
      return (0, exports.flatMap)(fab, function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    exports.map = RT.map(T.Functor);
    exports.ap = /* @__PURE__ */ RT.ap(T.ApplyPar);
    exports.apW = exports.ap;
    exports.of = RT.of(T.Pointed);
    exports.flatMap = (0, function_1.dual)(2, RT.flatMap(T.Monad));
    exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.URI = "ReaderTask";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.ApplyPar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
    exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
    exports.ApplicativePar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      of: exports.of
    };
    exports.ApplySeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq
    };
    exports.ApplicativeSeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.MonadTask = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.FromTask = {
      URI: exports.URI,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.FromReader = {
      URI: exports.URI,
      fromReader: exports.fromReader
    };
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    var _FromIO = {
      fromIO: exports.FromIO.fromIO
    };
    var _FromTask = {
      fromTask: exports.fromTask
    };
    var _FromReader = {
      fromReader: exports.fromReader
    };
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.flatMapTask = _.flatMapTask(_FromTask, _FlatMap);
    exports.flatMapReader = _.flatMapReader(_FromReader, _FlatMap);
    exports.flatMapReaderIO = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromReaderIOK)(f2));
    });
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.tapReader = (0, function_1.dual)(2, (0, FromReader_1.tapReader)(exports.FromReader, exports.Chain));
    exports.tapTask = (0, function_1.dual)(2, (0, FromTask_1.tapTask)(exports.FromTask, exports.Chain));
    exports.tapReaderIO = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.tap)(self, (0, exports.fromReaderIOK)(f2));
    });
    exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.ask = (0, FromReader_1.ask)(exports.FromReader);
    exports.asks = (0, FromReader_1.asks)(exports.FromReader);
    exports.fromReaderK = (0, FromReader_1.fromReaderK)(exports.FromReader);
    exports.chainReaderK = exports.flatMapReader;
    exports.chainReaderKW = exports.flatMapReader;
    exports.chainFirstReaderK = exports.tapReader;
    exports.chainFirstReaderKW = exports.tapReader;
    var fromReaderIOK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.fromReaderIO)(f2.apply(void 0, a));
      };
    };
    exports.fromReaderIOK = fromReaderIOK;
    exports.chainReaderIOKW = exports.flatMapReaderIO;
    exports.chainReaderIOK = exports.flatMapReaderIO;
    exports.chainFirstReaderIOKW = exports.tapReaderIO;
    exports.chainFirstReaderIOK = exports.tapReaderIO;
    exports.fromTaskK = (0, FromTask_1.fromTaskK)(exports.FromTask);
    exports.chainTaskK = exports.flatMapTask;
    exports.chainFirstTaskK = exports.tapTask;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(R.traverseReadonlyNonEmptyArrayWithIndex(f2), R.map(T.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f2) {
      return (0, function_1.flow)(R.traverseReadonlyNonEmptyArrayWithIndex(f2), R.map(T.traverseReadonlyNonEmptyArrayWithIndexSeq(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
    var traverseReadonlyArrayWithIndexSeq = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
    var traverseSeqArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndexSeq)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseSeqArray = traverseSeqArray;
    exports.chain = exports.flatMap;
    exports.chainW = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    exports.sequenceSeqArray = /* @__PURE__ */ (0, exports.traverseSeqArray)(function_1.identity);
    exports.readerTask = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.readerTaskSeq = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apSeq,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.getSemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.ApplySeq);
    exports.getMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.ApplicativeSeq);
    function run(ma, r) {
      return ma(r)();
    }
    exports.run = run;
  }
});

// node_modules/fp-ts/lib/TaskEither.js
var require_TaskEither = __commonJS({
  "node_modules/fp-ts/lib/TaskEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f2, y, t3, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f2 = 1, y && (t3 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t3 = y["return"]) && t3.call(y), 0) : y.next) && !(t3 = t3.call(y, op[1])).done)
              return t3;
            if (y = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t3[1]) {
                  _2.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _2.label < t3[2]) {
                  _2.label = t3[2];
                  _2.ops.push(op);
                  break;
                }
                if (t3[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwError = exports.of = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.flatMap = exports.apW = exports.ap = exports.mapLeft = exports.mapError = exports.bimap = exports.mapBoth = exports.map = exports.fromIOEitherK = exports.chainTaskOptionK = exports.chainTaskOptionKW = exports.fromTaskOptionK = exports.swap = exports.orLeft = exports.orElseFirstTaskK = exports.orElseFirstIOK = exports.tapError = exports.orElseW = exports.orElse = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.toUnion = exports.tryCatchK = exports.tryCatch = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromTaskOption = exports.fromIOEither = exports.fromEither = exports.fromTask = exports.fromIO = exports.leftIO = exports.rightIO = exports.leftTask = exports.rightTask = exports.right = exports.left = void 0;
    exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.flatMapTaskOption = exports.flatMapIOEither = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.Alt = exports.Bifunctor = exports.tapTask = exports.tapIO = exports.tapEither = exports.tap = exports.FromTask = exports.FromIO = exports.FromEither = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.getFilterable = exports.getCompactable = exports.getAltTaskValidation = exports.getApplicativeTaskValidation = exports.URI = void 0;
    exports.getTaskValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.taskEitherSeq = exports.taskEither = exports.orElseFirstW = exports.orElseFirst = exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.bracketW = exports.bracket = exports.taskify = exports.chainIOEitherK = exports.chainIOEitherKW = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var Compactable_1 = require_Compactable();
    var E = __importStar(require_Either());
    var ET = __importStar(require_EitherT());
    var Filterable_1 = require_Filterable();
    var FromEither_1 = require_FromEither();
    var FromIO_1 = require_FromIO();
    var FromTask_1 = require_FromTask();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var T = __importStar(require_Task());
    exports.left = ET.left(T.Pointed);
    exports.right = ET.right(T.Pointed);
    exports.rightTask = ET.rightF(T.Functor);
    exports.leftTask = ET.leftF(T.Functor);
    exports.rightIO = (0, function_1.flow)(T.fromIO, exports.rightTask);
    exports.leftIO = (0, function_1.flow)(T.fromIO, exports.leftTask);
    exports.fromIO = exports.rightIO;
    exports.fromTask = exports.rightTask;
    exports.fromEither = T.of;
    exports.fromIOEither = T.fromIO;
    var fromTaskOption = function(onNone) {
      return T.map(E.fromOption(onNone));
    };
    exports.fromTaskOption = fromTaskOption;
    exports.match = /* @__PURE__ */ ET.match(T.Functor);
    exports.matchW = exports.match;
    exports.matchE = ET.matchE(T.Monad);
    exports.fold = exports.matchE;
    exports.matchEW = exports.matchE;
    exports.foldW = exports.matchEW;
    exports.getOrElse = /* @__PURE__ */ ET.getOrElse(T.Monad);
    exports.getOrElseW = exports.getOrElse;
    var tryCatch = function(f2, onRejected) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var reason_1;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 3]);
                return [4, f2().then(_.right)];
              case 1:
                return [2, _a2.sent()];
              case 2:
                reason_1 = _a2.sent();
                return [2, _.left(onRejected(reason_1))];
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.tryCatch = tryCatch;
    var tryCatchK = function(f2, onRejected) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f2.apply(void 0, a);
        }, onRejected);
      };
    };
    exports.tryCatchK = tryCatchK;
    exports.toUnion = ET.toUnion(T.Functor);
    exports.fromNullable = ET.fromNullable(T.Pointed);
    exports.fromNullableK = ET.fromNullableK(T.Pointed);
    exports.chainNullableK = /* @__PURE__ */ ET.chainNullableK(T.Monad);
    exports.orElse = /* @__PURE__ */ ET.orElse(T.Monad);
    exports.orElseW = exports.orElse;
    exports.tapError = (0, function_1.dual)(2, ET.tapError(T.Monad));
    var orElseFirstIOK = function(onLeft) {
      return (0, exports.tapError)((0, exports.fromIOK)(onLeft));
    };
    exports.orElseFirstIOK = orElseFirstIOK;
    var orElseFirstTaskK = function(onLeft) {
      return (0, exports.tapError)((0, exports.fromTaskK)(onLeft));
    };
    exports.orElseFirstTaskK = orElseFirstTaskK;
    exports.orLeft = /* @__PURE__ */ ET.orLeft(T.Monad);
    exports.swap = ET.swap(T.Functor);
    var fromTaskOptionK = function(onNone) {
      var from = (0, exports.fromTaskOption)(onNone);
      return function(f2) {
        return (0, function_1.flow)(f2, from);
      };
    };
    exports.fromTaskOptionK = fromTaskOptionK;
    var chainTaskOptionKW = function(onNone) {
      return function(f2) {
        return function(ma) {
          return (0, exports.flatMap)(ma, (0, exports.fromTaskOptionK)(onNone)(f2));
        };
      };
    };
    exports.chainTaskOptionKW = chainTaskOptionKW;
    exports.chainTaskOptionK = exports.chainTaskOptionKW;
    var fromIOEitherK = function(f2) {
      return (0, function_1.flow)(f2, exports.fromIOEither);
    };
    exports.fromIOEitherK = fromIOEitherK;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _apPar = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _apSeq = function(fab, fa) {
      return (0, exports.flatMap)(fab, function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    exports.map = ET.map(T.Functor);
    exports.mapBoth = (0, function_1.dual)(3, ET.mapBoth(T.Functor));
    exports.bimap = exports.mapBoth;
    exports.mapError = (0, function_1.dual)(2, ET.mapError(T.Functor));
    exports.mapLeft = exports.mapError;
    exports.ap = /* @__PURE__ */ ET.ap(T.ApplyPar);
    exports.apW = exports.ap;
    exports.flatMap = (0, function_1.dual)(2, ET.flatMap(T.Monad));
    exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.alt = /* @__PURE__ */ ET.alt(T.Monad);
    exports.altW = exports.alt;
    exports.of = exports.right;
    exports.throwError = exports.left;
    exports.URI = "TaskEither";
    function getApplicativeTaskValidation(A, S) {
      var ap = (0, Apply_1.ap)(A, E.getApplicativeValidation(S));
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, ap(fa));
        },
        of: exports.of
      };
    }
    exports.getApplicativeTaskValidation = getApplicativeTaskValidation;
    function getAltTaskValidation(S) {
      var alt = ET.altValidation(T.Monad, S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        alt: function(fa, that) {
          return (0, function_1.pipe)(fa, alt(that));
        }
      };
    }
    exports.getAltTaskValidation = getAltTaskValidation;
    var getCompactable = function(M) {
      var C = E.getCompactable(M);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: (0, Compactable_1.compact)(T.Functor, C),
        separate: (0, Compactable_1.separate)(T.Functor, C, E.Functor)
      };
    };
    exports.getCompactable = getCompactable;
    function getFilterable(M) {
      var F = E.getFilterable(M);
      var C = (0, exports.getCompactable)(M);
      var filter2 = (0, Filterable_1.filter)(T.Functor, F);
      var filterMap = (0, Filterable_1.filterMap)(T.Functor, F);
      var partition = (0, Filterable_1.partition)(T.Functor, F);
      var partitionMap = (0, Filterable_1.partitionMap)(T.Functor, F);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: C.compact,
        separate: C.separate,
        filter: function(fa, predicate) {
          return (0, function_1.pipe)(fa, filter2(predicate));
        },
        filterMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, filterMap(f2));
        },
        partition: function(fa, predicate) {
          return (0, function_1.pipe)(fa, partition(predicate));
        },
        partitionMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, partitionMap(f2));
        }
      };
    }
    exports.getFilterable = getFilterable;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.ApplyPar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
    exports.apSecondW = exports.apSecond;
    exports.ApplicativePar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      of: exports.of
    };
    exports.ApplySeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq
    };
    exports.ApplicativeSeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of,
      fromIO: exports.fromIO
    };
    exports.MonadTask = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.FromTask = {
      URI: exports.URI,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.tapTask = (0, function_1.dual)(2, (0, FromTask_1.tapTask)(exports.FromTask, exports.Chain));
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.chainOptionKW = exports.chainOptionK;
    var _FromEither = {
      fromEither: exports.FromEither.fromEither
    };
    exports.liftNullable = _.liftNullable(_FromEither);
    exports.liftOption = _.liftOption(_FromEither);
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    var _FromIO = {
      fromIO: exports.FromIO.fromIO
    };
    var _FromTask = {
      fromTask: exports.fromTask
    };
    exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
    exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
    exports.flatMapEither = _.flatMapEither(_FromEither, _FlatMap);
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.flatMapTask = _.flatMapTask(_FromTask, _FlatMap);
    exports.flatMapIOEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromIOEitherK)(f2));
    });
    exports.flatMapTaskOption = (0, function_1.dual)(3, function(self, f2, onNone) {
      return (0, exports.flatMap)(self, function(a) {
        return (0, exports.fromTaskOption)(function() {
          return onNone(a);
        })(f2(a));
      });
    });
    exports.chainEitherK = exports.flatMapEither;
    exports.chainEitherKW = exports.flatMapEither;
    exports.chainFirstEitherK = exports.tapEither;
    exports.chainFirstEitherKW = exports.tapEither;
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.fromTaskK = (0, FromTask_1.fromTaskK)(exports.FromTask);
    exports.chainTaskK = exports.flatMapTask;
    exports.chainFirstTaskK = exports.tapTask;
    exports.chainIOEitherKW = exports.flatMapIOEither;
    exports.chainIOEitherK = exports.flatMapIOEither;
    function taskify(f2) {
      return function() {
        var args = Array.prototype.slice.call(arguments);
        return function() {
          return new Promise(function(resolve) {
            var cbResolver = function(e, r) {
              return e != null ? resolve(_.left(e)) : resolve(_.right(r));
            };
            f2.apply(null, args.concat(cbResolver));
          });
        };
      };
    }
    exports.taskify = taskify;
    var bracket = function(acquire, use, release) {
      return (0, exports.bracketW)(acquire, use, release);
    };
    exports.bracket = bracket;
    var bracketW = function(acquire, use, release) {
      return (0, exports.flatMap)(acquire, function(a) {
        return T.flatMap(use(a), function(e) {
          return (0, exports.flatMap)(release(a, e), function() {
            return T.of(e);
          });
        });
      });
    };
    exports.bracketW = bracketW;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(T.traverseReadonlyNonEmptyArrayWithIndex(f2), T.map(E.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f2) {
      return function(as) {
        return function() {
          return _.tail(as).reduce(function(acc, a, i) {
            return acc.then(function(ebs) {
              return _.isLeft(ebs) ? acc : f2(i + 1, a)().then(function(eb) {
                if (_.isLeft(eb)) {
                  return eb;
                }
                ebs.right.push(eb.right);
                return ebs;
              });
            });
          }, f2(0, _.head(as))().then(E.map(_.singleton)));
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
    var traverseReadonlyArrayWithIndexSeq = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
    var traverseSeqArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndexSeq)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseSeqArray = traverseSeqArray;
    exports.sequenceSeqArray = /* @__PURE__ */ (0, exports.traverseSeqArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainW = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    exports.orElseFirst = exports.tapError;
    exports.orElseFirstW = exports.tapError;
    exports.taskEither = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      alt: _alt,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask,
      throwError: exports.throwError
    };
    exports.taskEitherSeq = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError,
      map: _map2,
      of: exports.of,
      ap: _apSeq,
      chain: exports.flatMap,
      alt: _alt,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.ApplySeq);
    exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.ApplicativeSeq);
    var getSemigroup = function(S) {
      return (0, Apply_1.getApplySemigroup)(T.ApplySeq)(E.getSemigroup(S));
    };
    exports.getSemigroup = getSemigroup;
    function getTaskValidation(SE) {
      var applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE);
      var altTaskValidation = getAltTaskValidation(SE);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: applicativeTaskValidation.ap,
        of: exports.of,
        chain: exports.flatMap,
        bimap: exports.mapBoth,
        mapLeft: exports.mapError,
        alt: altTaskValidation.alt,
        fromIO: exports.fromIO,
        fromTask: exports.fromTask,
        throwError: exports.throwError
      };
    }
    exports.getTaskValidation = getTaskValidation;
  }
});

// node_modules/fp-ts/lib/ReaderTaskEither.js
var require_ReaderTaskEither = __commonJS({
  "node_modules/fp-ts/lib/ReaderTaskEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.of = exports.apW = exports.ap = exports.mapLeft = exports.mapError = exports.bimap = exports.mapBoth = exports.map = exports.fromReaderEitherK = exports.fromTaskEitherK = exports.fromIOEitherK = exports.swap = exports.orLeft = exports.tapError = exports.orElseW = exports.orElse = exports.asksReaderTaskEither = exports.asksReaderTaskEitherW = exports.local = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.toUnion = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromReaderEither = exports.fromIOEither = exports.fromTask = exports.fromIO = exports.fromReader = exports.fromEither = exports.leftReaderIO = exports.rightReaderIO = exports.leftIO = exports.rightIO = exports.leftReaderTask = exports.rightReaderTask = exports.leftReader = exports.rightReader = exports.leftTask = exports.rightTask = exports.right = exports.left = exports.fromTaskEither = void 0;
    exports.chainFirstReaderEitherKW = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.Alt = exports.Bifunctor = exports.tapReaderIO = exports.tapReaderTask = exports.tapTaskEither = exports.tapReaderEither = exports.tapReader = exports.tapTask = exports.tapIO = exports.tapEither = exports.tap = exports.FromReader = exports.FromTask = exports.FromIO = exports.FromEither = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.getAltReaderTaskValidation = exports.getApplicativeReaderTaskValidation = exports.getFilterable = exports.getCompactable = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.flatMap = void 0;
    exports.chainIOEitherK = exports.chainIOEitherKW = exports.chainReaderIOK = exports.chainReaderIOKW = exports.chainReaderKW = exports.chainReaderK = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainReaderTaskK = exports.chainReaderTaskKW = exports.chainTaskEitherK = exports.chainTaskEitherKW = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.flatMapReaderEither = exports.flatMapIOEither = exports.flatMapReaderIO = exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapReaderTask = exports.flatMapTaskEither = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.chainFirstReaderIOK = exports.chainFirstReaderIOKW = exports.fromReaderIOK = exports.chainFirstReaderTaskK = exports.chainFirstReaderTaskKW = exports.fromReaderTaskK = exports.chainFirstTaskEitherK = exports.chainFirstTaskEitherKW = exports.chainFirstReaderEitherK = void 0;
    exports.run = exports.getReaderTaskValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.readerTaskEitherSeq = exports.readerTaskEither = exports.orElseFirstW = exports.orElseFirst = exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.bracketW = exports.bracket = exports.chainReaderEitherK = exports.chainReaderEitherKW = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var Compactable_1 = require_Compactable();
    var E = __importStar(require_Either());
    var ET = __importStar(require_EitherT());
    var Filterable_1 = require_Filterable();
    var FromEither_1 = require_FromEither();
    var FromIO_1 = require_FromIO();
    var FromReader_1 = require_FromReader();
    var FromTask_1 = require_FromTask();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var R = __importStar(require_Reader());
    var RT = __importStar(require_ReaderTask());
    var T = __importStar(require_Task());
    var TE = __importStar(require_TaskEither());
    exports.fromTaskEither = R.of;
    exports.left = ET.left(RT.Pointed);
    exports.right = ET.right(RT.Pointed);
    exports.rightTask = (0, function_1.flow)(TE.rightTask, exports.fromTaskEither);
    exports.leftTask = (0, function_1.flow)(TE.leftTask, exports.fromTaskEither);
    var rightReader = function(ma) {
      return (0, function_1.flow)(ma, TE.right);
    };
    exports.rightReader = rightReader;
    var leftReader = function(me) {
      return (0, function_1.flow)(me, TE.left);
    };
    exports.leftReader = leftReader;
    exports.rightReaderTask = /* @__PURE__ */ ET.rightF(RT.Functor);
    exports.leftReaderTask = /* @__PURE__ */ ET.leftF(RT.Functor);
    exports.rightIO = (0, function_1.flow)(TE.rightIO, exports.fromTaskEither);
    exports.leftIO = (0, function_1.flow)(TE.leftIO, exports.fromTaskEither);
    var rightReaderIO = function(ma) {
      return (0, function_1.flow)(ma, TE.rightIO);
    };
    exports.rightReaderIO = rightReaderIO;
    var leftReaderIO = function(me) {
      return (0, function_1.flow)(me, TE.leftIO);
    };
    exports.leftReaderIO = leftReaderIO;
    exports.fromEither = RT.of;
    exports.fromReader = exports.rightReader;
    exports.fromIO = exports.rightIO;
    exports.fromTask = exports.rightTask;
    exports.fromIOEither = (0, function_1.flow)(TE.fromIOEither, exports.fromTaskEither);
    var fromReaderEither = function(ma) {
      return (0, function_1.flow)(ma, TE.fromEither);
    };
    exports.fromReaderEither = fromReaderEither;
    exports.match = ET.match(RT.Functor);
    exports.matchW = exports.match;
    exports.matchE = ET.matchE(RT.Chain);
    exports.fold = exports.matchE;
    exports.matchEW = exports.matchE;
    exports.foldW = exports.matchEW;
    exports.getOrElse = ET.getOrElse(RT.Monad);
    exports.getOrElseW = exports.getOrElse;
    exports.toUnion = ET.toUnion(RT.Functor);
    exports.fromNullable = /* @__PURE__ */ ET.fromNullable(RT.Pointed);
    exports.fromNullableK = ET.fromNullableK(RT.Pointed);
    exports.chainNullableK = ET.chainNullableK(RT.Monad);
    exports.local = R.local;
    exports.asksReaderTaskEitherW = R.asksReaderW;
    exports.asksReaderTaskEither = exports.asksReaderTaskEitherW;
    exports.orElse = ET.orElse(RT.Monad);
    exports.orElseW = exports.orElse;
    exports.tapError = (0, function_1.dual)(2, ET.tapError(RT.Monad));
    exports.orLeft = ET.orLeft(RT.Monad);
    exports.swap = ET.swap(RT.Functor);
    var fromIOEitherK = function(f2) {
      return (0, function_1.flow)(f2, exports.fromIOEither);
    };
    exports.fromIOEitherK = fromIOEitherK;
    var fromTaskEitherK = function(f2) {
      return (0, function_1.flow)(f2, exports.fromTaskEither);
    };
    exports.fromTaskEitherK = fromTaskEitherK;
    var fromReaderEitherK = function(f2) {
      return (0, function_1.flow)(f2, exports.fromReaderEither);
    };
    exports.fromReaderEitherK = fromReaderEitherK;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _apPar = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _apSeq = function(fab, fa) {
      return (0, exports.flatMap)(fab, function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    exports.map = /* @__PURE__ */ ET.map(RT.Functor);
    exports.mapBoth = (0, function_1.dual)(3, ET.mapBoth(RT.Functor));
    exports.bimap = exports.mapBoth;
    exports.mapError = (0, function_1.dual)(2, ET.mapError(RT.Functor));
    exports.mapLeft = exports.mapError;
    exports.ap = ET.ap(RT.ApplyPar);
    exports.apW = exports.ap;
    exports.of = exports.right;
    exports.flatMap = (0, function_1.dual)(2, ET.flatMap(RT.Monad));
    exports.flattenW = (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.alt = ET.alt(RT.Monad);
    exports.altW = exports.alt;
    exports.throwError = exports.left;
    exports.URI = "ReaderTaskEither";
    var getCompactable = function(M) {
      var C = E.getCompactable(M);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: (0, Compactable_1.compact)(RT.Functor, C),
        separate: (0, Compactable_1.separate)(RT.Functor, C, E.Functor)
      };
    };
    exports.getCompactable = getCompactable;
    function getFilterable(M) {
      var F = E.getFilterable(M);
      var C = (0, exports.getCompactable)(M);
      var filter2 = (0, Filterable_1.filter)(RT.Functor, F);
      var filterMap = (0, Filterable_1.filterMap)(RT.Functor, F);
      var partition = (0, Filterable_1.partition)(RT.Functor, F);
      var partitionMap = (0, Filterable_1.partitionMap)(RT.Functor, F);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: C.compact,
        separate: C.separate,
        filter: function(fa, predicate) {
          return (0, function_1.pipe)(fa, filter2(predicate));
        },
        filterMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, filterMap(f2));
        },
        partition: function(fa, predicate) {
          return (0, function_1.pipe)(fa, partition(predicate));
        },
        partitionMap: function(fa, f2) {
          return (0, function_1.pipe)(fa, partitionMap(f2));
        }
      };
    }
    exports.getFilterable = getFilterable;
    function getApplicativeReaderTaskValidation(A, S) {
      var ap = (0, Apply_1.ap)(R.Apply, TE.getApplicativeTaskValidation(A, S));
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, ap(fa));
        },
        of: exports.of
      };
    }
    exports.getApplicativeReaderTaskValidation = getApplicativeReaderTaskValidation;
    function getAltReaderTaskValidation(S) {
      var alt = ET.altValidation(RT.Monad, S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        alt: function(fa, that) {
          return (0, function_1.pipe)(fa, alt(that));
        }
      };
    }
    exports.getAltReaderTaskValidation = getAltReaderTaskValidation;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.ApplyPar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
    exports.apSecondW = exports.apSecond;
    exports.ApplicativePar = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      of: exports.of
    };
    exports.ApplySeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq
    };
    exports.ApplicativeSeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of,
      fromIO: exports.fromIO
    };
    exports.MonadTask = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _apPar,
      chain: exports.flatMap,
      of: exports.of,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.FromTask = {
      URI: exports.URI,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.FromReader = {
      URI: exports.URI,
      fromReader: exports.fromReader
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.tapTask = (0, function_1.dual)(2, (0, FromTask_1.tapTask)(exports.FromTask, exports.Chain));
    exports.tapReader = (0, function_1.dual)(2, (0, FromReader_1.tapReader)(exports.FromReader, exports.Chain));
    exports.tapReaderEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.tap)(self, (0, exports.fromReaderEitherK)(f2));
    });
    exports.tapTaskEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.tap)(self, (0, exports.fromTaskEitherK)(f2));
    });
    exports.tapReaderTask = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.tap)(self, (0, exports.fromReaderTaskK)(f2));
    });
    exports.tapReaderIO = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.tap)(self, (0, exports.fromReaderIOK)(f2));
    });
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.ask = (0, FromReader_1.ask)(exports.FromReader);
    exports.asks = (0, FromReader_1.asks)(exports.FromReader);
    exports.fromReaderK = (0, FromReader_1.fromReaderK)(exports.FromReader);
    exports.chainFirstReaderK = exports.tapReader;
    exports.chainFirstReaderKW = exports.tapReader;
    exports.chainFirstReaderEitherKW = exports.tapReaderEither;
    exports.chainFirstReaderEitherK = exports.tapReaderEither;
    exports.chainFirstTaskEitherKW = exports.tapTaskEither;
    exports.chainFirstTaskEitherK = exports.tapTaskEither;
    var fromReaderTaskK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.rightReaderTask)(f2.apply(void 0, a));
      };
    };
    exports.fromReaderTaskK = fromReaderTaskK;
    exports.chainFirstReaderTaskKW = exports.tapReaderTask;
    exports.chainFirstReaderTaskK = exports.tapReaderTask;
    var fromReaderIOK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.rightReaderIO)(f2.apply(void 0, a));
      };
    };
    exports.fromReaderIOK = fromReaderIOK;
    exports.chainFirstReaderIOKW = exports.tapReaderIO;
    exports.chainFirstReaderIOK = exports.tapReaderIO;
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.fromOptionK = (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = /* @__PURE__ */ (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.chainOptionKW = exports.chainOptionK;
    var _FromEither = {
      fromEither: exports.FromEither.fromEither
    };
    exports.liftNullable = _.liftNullable(_FromEither);
    exports.liftOption = _.liftOption(_FromEither);
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    var _FromIO = {
      fromIO: exports.fromIO
    };
    var _FromTask = {
      fromTask: exports.fromTask
    };
    var _FromReader = {
      fromReader: exports.fromReader
    };
    exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
    exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
    exports.flatMapEither = _.flatMapEither(_FromEither, _FlatMap);
    exports.flatMapTaskEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromTaskEitherK)(f2));
    });
    exports.flatMapReaderTask = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromReaderTaskK)(f2));
    });
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.flatMapTask = _.flatMapTask(_FromTask, _FlatMap);
    exports.flatMapReader = _.flatMapReader(_FromReader, _FlatMap);
    exports.flatMapReaderIO = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromReaderIOK)(f2));
    });
    exports.flatMapIOEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromIOEitherK)(f2));
    });
    exports.flatMapReaderEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromReaderEitherK)(f2));
    });
    exports.chainEitherK = exports.flatMapEither;
    exports.chainEitherKW = exports.flatMapEither;
    exports.chainFirstEitherK = exports.tapEither;
    exports.chainFirstEitherKW = exports.tapEither;
    exports.chainTaskEitherKW = exports.flatMapTaskEither;
    exports.chainTaskEitherK = exports.flatMapTaskEither;
    exports.chainReaderTaskKW = exports.flatMapReaderTask;
    exports.chainReaderTaskK = exports.flatMapReaderTask;
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.fromTaskK = (0, FromTask_1.fromTaskK)(exports.FromTask);
    exports.chainTaskK = exports.flatMapTask;
    exports.chainFirstTaskK = exports.tapTask;
    exports.chainReaderK = exports.flatMapReader;
    exports.chainReaderKW = exports.flatMapReader;
    exports.chainReaderIOKW = exports.flatMapReaderIO;
    exports.chainReaderIOK = exports.flatMapReaderIO;
    exports.chainIOEitherKW = exports.flatMapIOEither;
    exports.chainIOEitherK = exports.flatMapIOEither;
    exports.chainReaderEitherKW = exports.flatMapReaderEither;
    exports.chainReaderEitherK = exports.flatMapReaderEither;
    function bracket(acquire, use, release) {
      return bracketW(acquire, use, release);
    }
    exports.bracket = bracket;
    function bracketW(acquire, use, release) {
      return function(r) {
        return TE.bracketW(acquire(r), function(a) {
          return use(a)(r);
        }, function(a, e) {
          return release(a, e)(r);
        });
      };
    }
    exports.bracketW = bracketW;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(R.traverseReadonlyNonEmptyArrayWithIndex(f2), R.map(TE.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f2) {
      return (0, function_1.flow)(R.traverseReadonlyNonEmptyArrayWithIndex(f2), R.map(TE.traverseReadonlyNonEmptyArrayWithIndexSeq(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
    var traverseReadonlyArrayWithIndexSeq = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = (0, exports.traverseArray)(function_1.identity);
    exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
    var traverseSeqArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndexSeq)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseSeqArray = traverseSeqArray;
    exports.sequenceSeqArray = (0, exports.traverseSeqArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainW = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    exports.orElseFirst = exports.tapError;
    exports.orElseFirstW = exports.tapError;
    exports.readerTaskEither = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apPar,
      chain: exports.flatMap,
      alt: _alt,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask,
      throwError: exports.throwError
    };
    exports.readerTaskEitherSeq = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _apSeq,
      chain: exports.flatMap,
      alt: _alt,
      bimap: exports.mapBoth,
      mapLeft: exports.mapError,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.ApplySeq);
    exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.ApplicativeSeq);
    var getSemigroup = function(S) {
      return (0, Apply_1.getApplySemigroup)(RT.ApplySeq)(E.getSemigroup(S));
    };
    exports.getSemigroup = getSemigroup;
    function getReaderTaskValidation(SE) {
      var applicativeReaderTaskValidation = getApplicativeReaderTaskValidation(T.ApplicativePar, SE);
      var altReaderTaskValidation = getAltReaderTaskValidation(SE);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        of: exports.of,
        chain: exports.flatMap,
        bimap: exports.mapBoth,
        mapLeft: exports.mapError,
        ap: applicativeReaderTaskValidation.ap,
        alt: altReaderTaskValidation.alt,
        fromIO: exports.fromIO,
        fromTask: exports.fromTask,
        throwError: exports.throwError
      };
    }
    exports.getReaderTaskValidation = getReaderTaskValidation;
    function run(ma, r) {
      return ma(r)();
    }
    exports.run = run;
  }
});

// node_modules/fp-ts/lib/string.js
var require_string = __commonJS({
  "node_modules/fp-ts/lib/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endsWith = exports.startsWith = exports.includes = exports.split = exports.size = exports.isEmpty = exports.slice = exports.trimRight = exports.trimLeft = exports.trim = exports.replace = exports.toLowerCase = exports.toUpperCase = exports.isString = exports.Show = exports.Ord = exports.Monoid = exports.empty = exports.Semigroup = exports.Eq = void 0;
    var ReadonlyNonEmptyArray_1 = require_ReadonlyNonEmptyArray();
    exports.Eq = {
      equals: function(first, second) {
        return first === second;
      }
    };
    exports.Semigroup = {
      concat: function(first, second) {
        return first + second;
      }
    };
    exports.empty = "";
    exports.Monoid = {
      concat: exports.Semigroup.concat,
      empty: exports.empty
    };
    exports.Ord = {
      equals: exports.Eq.equals,
      compare: function(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
      }
    };
    exports.Show = {
      show: function(s) {
        return JSON.stringify(s);
      }
    };
    var isString = function(u) {
      return typeof u === "string";
    };
    exports.isString = isString;
    var toUpperCase = function(s) {
      return s.toUpperCase();
    };
    exports.toUpperCase = toUpperCase;
    var toLowerCase = function(s) {
      return s.toLowerCase();
    };
    exports.toLowerCase = toLowerCase;
    var replace = function(searchValue, replaceValue) {
      return function(s) {
        return s.replace(searchValue, replaceValue);
      };
    };
    exports.replace = replace;
    var trim = function(s) {
      return s.trim();
    };
    exports.trim = trim;
    var trimLeft = function(s) {
      return s.trimLeft();
    };
    exports.trimLeft = trimLeft;
    var trimRight = function(s) {
      return s.trimRight();
    };
    exports.trimRight = trimRight;
    var slice = function(start, end) {
      return function(s) {
        return s.slice(start, end);
      };
    };
    exports.slice = slice;
    var isEmpty = function(s) {
      return s.length === 0;
    };
    exports.isEmpty = isEmpty;
    var size = function(s) {
      return s.length;
    };
    exports.size = size;
    var split = function(separator) {
      return function(s) {
        var out = s.split(separator);
        return (0, ReadonlyNonEmptyArray_1.isNonEmpty)(out) ? out : [s];
      };
    };
    exports.split = split;
    var includes = function(searchString, position) {
      return function(s) {
        return s.includes(searchString, position);
      };
    };
    exports.includes = includes;
    var startsWith = function(searchString, position) {
      return function(s) {
        return s.startsWith(searchString, position);
      };
    };
    exports.startsWith = startsWith;
    var endsWith = function(searchString, position) {
      return function(s) {
        return s.endsWith(searchString, position);
      };
    };
    exports.endsWith = endsWith;
  }
});

// node_modules/fp-ts/lib/ReadonlyRecord.js
var require_ReadonlyRecord = __commonJS({
  "node_modules/fp-ts/lib/ReadonlyRecord.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._partition = exports._filterMap = exports._filter = exports._reduceRight = exports._foldMap = exports._reduce = exports._mapWithIndex = exports._map = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromEntries = exports.toEntries = exports.fromFoldableMap = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.empty = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toReadonlyArray = exports.collect = exports.keys = exports.isEmpty = exports.size = exports.toRecord = exports.fromRecord = void 0;
    exports.readonlyRecord = exports.hasOwnProperty = exports.insertAt = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports._sequence = exports._traverse = exports._filterWithIndex = exports._filterMapWithIndex = exports._partitionWithIndex = exports._partitionMapWithIndex = exports._reduceRightWithIndex = exports._foldMapWithIndex = exports._reduceWithIndex = exports._partitionMap = void 0;
    var Eq_1 = require_Eq();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Separated_1 = require_Separated();
    var S = __importStar(require_string());
    var Witherable_1 = require_Witherable();
    var fromRecord = function(r) {
      return Object.assign({}, r);
    };
    exports.fromRecord = fromRecord;
    var toRecord = function(r) {
      return Object.assign({}, r);
    };
    exports.toRecord = toRecord;
    var size = function(r) {
      return Object.keys(r).length;
    };
    exports.size = size;
    var isEmpty = function(r) {
      for (var k in r) {
        if (_.has.call(r, k)) {
          return false;
        }
      }
      return true;
    };
    exports.isEmpty = isEmpty;
    var keys_ = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    exports.keys = keys_(S.Ord);
    function collect(O) {
      if (typeof O === "function") {
        return collect(S.Ord)(O);
      }
      var keysO = keys_(O);
      return function(f2) {
        return function(r) {
          var out = [];
          for (var _i = 0, _a2 = keysO(r); _i < _a2.length; _i++) {
            var key = _a2[_i];
            out.push(f2(key, r[key]));
          }
          return out;
        };
      };
    }
    exports.collect = collect;
    exports.toReadonlyArray = /* @__PURE__ */ collect(S.Ord)(function(k, a) {
      return [k, a];
    });
    function toUnfoldable(U) {
      return function(r) {
        var sas = (0, exports.toReadonlyArray)(r);
        var len = sas.length;
        return U.unfold(0, function(b) {
          return b < len ? _.some([sas[b], b + 1]) : _.none;
        });
      };
    }
    exports.toUnfoldable = toUnfoldable;
    var upsertAt = function(k, a) {
      return function(r) {
        if (_.has.call(r, k) && r[k] === a) {
          return r;
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return out;
      };
    };
    exports.upsertAt = upsertAt;
    var has3 = function(k, r) {
      return _.has.call(r, k);
    };
    exports.has = has3;
    function deleteAt(k) {
      return function(r) {
        if (!_.has.call(r, k)) {
          return r;
        }
        var out = Object.assign({}, r);
        delete out[k];
        return out;
      };
    }
    exports.deleteAt = deleteAt;
    var updateAt = function(k, a) {
      return function(r) {
        if (!(0, exports.has)(k, r)) {
          return _.none;
        }
        if (r[k] === a) {
          return _.some(r);
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return _.some(out);
      };
    };
    exports.updateAt = updateAt;
    var modifyAt = function(k, f2) {
      return function(r) {
        if (!(0, exports.has)(k, r)) {
          return _.none;
        }
        var next = f2(r[k]);
        if (next === r[k]) {
          return _.some(r);
        }
        var out = Object.assign({}, r);
        out[k] = next;
        return _.some(out);
      };
    };
    exports.modifyAt = modifyAt;
    function pop(k) {
      var deleteAtk = deleteAt(k);
      return function(r) {
        var oa = lookup(k, r);
        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);
      };
    }
    exports.pop = pop;
    function isSubrecord(E) {
      return function(me, that) {
        if (that === void 0) {
          var isSubrecordE_1 = isSubrecord(E);
          return function(that2) {
            return isSubrecordE_1(that2, me);
          };
        }
        for (var k in me) {
          if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {
            return false;
          }
        }
        return true;
      };
    }
    exports.isSubrecord = isSubrecord;
    function lookup(k, r) {
      if (r === void 0) {
        return function(r2) {
          return lookup(k, r2);
        };
      }
      return _.has.call(r, k) ? _.some(r[k]) : _.none;
    }
    exports.lookup = lookup;
    exports.empty = {};
    function mapWithIndex(f2) {
      return function(r) {
        var out = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            out[k] = f2(k, r[k]);
          }
        }
        return out;
      };
    }
    exports.mapWithIndex = mapWithIndex;
    function map(f2) {
      return mapWithIndex(function(_2, a) {
        return f2(a);
      });
    }
    exports.map = map;
    function reduceWithIndex() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length === 2) {
        return reduceWithIndex(S.Ord).apply(void 0, args);
      }
      var keysO = keys_(args[0]);
      return function(b, f2) {
        return function(fa) {
          var out = b;
          var ks = keysO(fa);
          var len = ks.length;
          for (var i = 0; i < len; i++) {
            var k = ks[i];
            out = f2(k, out, fa[k]);
          }
          return out;
        };
      };
    }
    exports.reduceWithIndex = reduceWithIndex;
    function foldMapWithIndex(O) {
      if ("compare" in O) {
        var keysO_1 = keys_(O);
        return function(M) {
          return function(f2) {
            return function(fa) {
              var out = M.empty;
              var ks = keysO_1(fa);
              var len = ks.length;
              for (var i = 0; i < len; i++) {
                var k = ks[i];
                out = M.concat(out, f2(k, fa[k]));
              }
              return out;
            };
          };
        };
      }
      return foldMapWithIndex(S.Ord)(O);
    }
    exports.foldMapWithIndex = foldMapWithIndex;
    function reduceRightWithIndex() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length === 2) {
        return reduceRightWithIndex(S.Ord).apply(void 0, args);
      }
      var keysO = keys_(args[0]);
      return function(b, f2) {
        return function(fa) {
          var out = b;
          var ks = keysO(fa);
          var len = ks.length;
          for (var i = len - 1; i >= 0; i--) {
            var k = ks[i];
            out = f2(k, fa[k], out);
          }
          return out;
        };
      };
    }
    exports.reduceRightWithIndex = reduceRightWithIndex;
    var singleton = function(k, a) {
      var _a2;
      return _a2 = {}, _a2[k] = a, _a2;
    };
    exports.singleton = singleton;
    function traverseWithIndex(F) {
      var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);
      return function(f2) {
        return function(ta) {
          return traverseWithIndexOF(ta, f2);
        };
      };
    }
    exports.traverseWithIndex = traverseWithIndex;
    function traverse(F) {
      var traverseOF = (0, exports._traverse)(S.Ord)(F);
      return function(f2) {
        return function(ta) {
          return traverseOF(ta, f2);
        };
      };
    }
    exports.traverse = traverse;
    function sequence(F) {
      return (0, exports._sequence)(S.Ord)(F);
    }
    exports.sequence = sequence;
    var wither = function(F) {
      var traverseF = traverse(F);
      return function(f2) {
        return function(fa) {
          return F.map((0, function_1.pipe)(fa, traverseF(f2)), exports.compact);
        };
      };
    };
    exports.wither = wither;
    var wilt = function(F) {
      var traverseF = traverse(F);
      return function(f2) {
        return function(fa) {
          return F.map((0, function_1.pipe)(fa, traverseF(f2)), exports.separate);
        };
      };
    };
    exports.wilt = wilt;
    function partitionMapWithIndex(f2) {
      return function(r) {
        var left = {};
        var right = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            var e = f2(k, r[k]);
            switch (e._tag) {
              case "Left":
                left[k] = e.left;
                break;
              case "Right":
                right[k] = e.right;
                break;
            }
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.partitionMapWithIndex = partitionMapWithIndex;
    function partitionWithIndex(predicateWithIndex) {
      return function(r) {
        var left = {};
        var right = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            var a = r[k];
            if (predicateWithIndex(k, a)) {
              right[k] = a;
            } else {
              left[k] = a;
            }
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.partitionWithIndex = partitionWithIndex;
    function filterMapWithIndex(f2) {
      return function(r) {
        var out = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            var ob = f2(k, r[k]);
            if (_.isSome(ob)) {
              out[k] = ob.value;
            }
          }
        }
        return out;
      };
    }
    exports.filterMapWithIndex = filterMapWithIndex;
    function filterWithIndex(predicateWithIndex) {
      return function(fa) {
        var out = {};
        var changed = false;
        for (var key in fa) {
          if (_.has.call(fa, key)) {
            var a = fa[key];
            if (predicateWithIndex(key, a)) {
              out[key] = a;
            } else {
              changed = true;
            }
          }
        }
        return changed ? out : fa;
      };
    }
    exports.filterWithIndex = filterWithIndex;
    function fromFoldable(M, F) {
      var fromFoldableMapM = fromFoldableMap(M, F);
      return function(fka) {
        return fromFoldableMapM(fka, function_1.identity);
      };
    }
    exports.fromFoldable = fromFoldable;
    function fromFoldableMap(M, F) {
      return function(ta, f2) {
        return F.reduce(ta, {}, function(r, a) {
          var _a2 = f2(a), k = _a2[0], b = _a2[1];
          r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;
          return r;
        });
      };
    }
    exports.fromFoldableMap = fromFoldableMap;
    exports.toEntries = exports.toReadonlyArray;
    var fromEntries = function(fa) {
      var out = {};
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var a = fa_1[_i];
        out[a[0]] = a[1];
      }
      return out;
    };
    exports.fromEntries = fromEntries;
    function every(predicate) {
      return function(r) {
        for (var k in r) {
          if (!predicate(r[k])) {
            return false;
          }
        }
        return true;
      };
    }
    exports.every = every;
    function some(predicate) {
      return function(r) {
        for (var k in r) {
          if (predicate(r[k])) {
            return true;
          }
        }
        return false;
      };
    }
    exports.some = some;
    function elem(E) {
      return function(a, fa) {
        if (fa === void 0) {
          var elemE_1 = elem(E);
          return function(fa2) {
            return elemE_1(a, fa2);
          };
        }
        for (var k in fa) {
          if (E.equals(fa[k], a)) {
            return true;
          }
        }
        return false;
      };
    }
    exports.elem = elem;
    var union = function(M) {
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return second;
          }
          if ((0, exports.isEmpty)(second)) {
            return first;
          }
          var out = {};
          for (var k in first) {
            if ((0, exports.has)(k, second)) {
              out[k] = M.concat(first[k], second[k]);
            } else {
              out[k] = first[k];
            }
          }
          for (var k in second) {
            if (!(0, exports.has)(k, out)) {
              out[k] = second[k];
            }
          }
          return out;
        };
      };
    };
    exports.union = union;
    var intersection = function(M) {
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
            return exports.empty;
          }
          var out = {};
          for (var k in first) {
            if ((0, exports.has)(k, second)) {
              out[k] = M.concat(first[k], second[k]);
            }
          }
          return out;
        };
      };
    };
    exports.intersection = intersection;
    var difference = function(second) {
      return function(first) {
        if ((0, exports.isEmpty)(first)) {
          return second;
        }
        if ((0, exports.isEmpty)(second)) {
          return first;
        }
        var out = {};
        for (var k in first) {
          if (!(0, exports.has)(k, second)) {
            out[k] = first[k];
          }
        }
        for (var k in second) {
          if (!(0, exports.has)(k, first)) {
            out[k] = second[k];
          }
        }
        return out;
      };
    };
    exports.difference = difference;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, map(f2));
    };
    exports._map = _map2;
    var _mapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, mapWithIndex(f2));
    };
    exports._mapWithIndex = _mapWithIndex;
    var _reduce = function(O) {
      var reduceO = reduce(O);
      return function(fa, b, f2) {
        return (0, function_1.pipe)(fa, reduceO(b, f2));
      };
    };
    exports._reduce = _reduce;
    var _foldMap = function(O) {
      return function(M) {
        var foldMapM = foldMap(O)(M);
        return function(fa, f2) {
          return (0, function_1.pipe)(fa, foldMapM(f2));
        };
      };
    };
    exports._foldMap = _foldMap;
    var _reduceRight = function(O) {
      var reduceRightO = reduceRight(O);
      return function(fa, b, f2) {
        return (0, function_1.pipe)(fa, reduceRightO(b, f2));
      };
    };
    exports._reduceRight = _reduceRight;
    var _filter2 = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
    };
    exports._filter = _filter2;
    var _filterMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMap)(f2));
    };
    exports._filterMap = _filterMap;
    var _partition = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
    };
    exports._partition = _partition;
    var _partitionMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f2));
    };
    exports._partitionMap = _partitionMap;
    var _reduceWithIndex = function(O) {
      var reduceWithIndexO = reduceWithIndex(O);
      return function(fa, b, f2) {
        return (0, function_1.pipe)(fa, reduceWithIndexO(b, f2));
      };
    };
    exports._reduceWithIndex = _reduceWithIndex;
    var _foldMapWithIndex = function(O) {
      var foldMapWithIndexO = foldMapWithIndex(O);
      return function(M) {
        var foldMapWithIndexM = foldMapWithIndexO(M);
        return function(fa, f2) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f2));
        };
      };
    };
    exports._foldMapWithIndex = _foldMapWithIndex;
    var _reduceRightWithIndex = function(O) {
      var reduceRightWithIndexO = reduceRightWithIndex(O);
      return function(fa, b, f2) {
        return (0, function_1.pipe)(fa, reduceRightWithIndexO(b, f2));
      };
    };
    exports._reduceRightWithIndex = _reduceRightWithIndex;
    var _partitionMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, partitionMapWithIndex(f2));
    };
    exports._partitionMapWithIndex = _partitionMapWithIndex;
    var _partitionWithIndex = function(fa, predicateWithIndex) {
      return (0, function_1.pipe)(fa, partitionWithIndex(predicateWithIndex));
    };
    exports._partitionWithIndex = _partitionWithIndex;
    var _filterMapWithIndex = function(fa, f2) {
      return (0, function_1.pipe)(fa, filterMapWithIndex(f2));
    };
    exports._filterMapWithIndex = _filterMapWithIndex;
    var _filterWithIndex = function(fa, predicateWithIndex) {
      return (0, function_1.pipe)(fa, filterWithIndex(predicateWithIndex));
    };
    exports._filterWithIndex = _filterWithIndex;
    var _traverse = function(O) {
      var traverseWithIndexO = _traverseWithIndex(O);
      return function(F) {
        var traverseWithIndexOF = traverseWithIndexO(F);
        return function(ta, f2) {
          return traverseWithIndexOF(ta, (0, function_1.flow)(function_1.SK, f2));
        };
      };
    };
    exports._traverse = _traverse;
    var _sequence = function(O) {
      var traverseO = (0, exports._traverse)(O);
      return function(F) {
        var traverseOF = traverseO(F);
        return function(ta) {
          return traverseOF(ta, function_1.identity);
        };
      };
    };
    exports._sequence = _sequence;
    var _traverseWithIndex = function(O) {
      return function(F) {
        var keysO = keys_(O);
        return function(ta, f2) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of(exports.empty);
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                var _a2;
                return Object.assign({}, r, (_a2 = {}, _a2[key2] = b, _a2));
              };
            }), f2(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    var filter2 = function(predicate) {
      return filterWithIndex(function(_2, a) {
        return predicate(a);
      });
    };
    exports.filter = filter2;
    var filterMap = function(f2) {
      return filterMapWithIndex(function(_2, a) {
        return f2(a);
      });
    };
    exports.filterMap = filterMap;
    var partition = function(predicate) {
      return partitionWithIndex(function(_2, a) {
        return predicate(a);
      });
    };
    exports.partition = partition;
    var partitionMap = function(f2) {
      return partitionMapWithIndex(function(_2, a) {
        return f2(a);
      });
    };
    exports.partitionMap = partitionMap;
    function reduce() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length === 1) {
        var reduceWithIndexO_1 = reduceWithIndex(args[0]);
        return function(b, f2) {
          return reduceWithIndexO_1(b, function(_2, b2, a) {
            return f2(b2, a);
          });
        };
      }
      return reduce(S.Ord).apply(void 0, args);
    }
    exports.reduce = reduce;
    function foldMap(O) {
      if ("compare" in O) {
        var foldMapWithIndexO_1 = foldMapWithIndex(O);
        return function(M) {
          var foldMapWithIndexM = foldMapWithIndexO_1(M);
          return function(f2) {
            return foldMapWithIndexM(function(_2, a) {
              return f2(a);
            });
          };
        };
      }
      return foldMap(S.Ord)(O);
    }
    exports.foldMap = foldMap;
    function reduceRight() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length === 1) {
        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);
        return function(b, f2) {
          return reduceRightWithIndexO_1(b, function(_2, b2, a) {
            return f2(b2, a);
          });
        };
      }
      return reduceRight(S.Ord).apply(void 0, args);
    }
    exports.reduceRight = reduceRight;
    var compact = function(r) {
      var out = {};
      for (var k in r) {
        if (_.has.call(r, k)) {
          var oa = r[k];
          if (_.isSome(oa)) {
            out[k] = oa.value;
          }
        }
      }
      return out;
    };
    exports.compact = compact;
    var separate = function(r) {
      var left = {};
      var right = {};
      for (var k in r) {
        if (_.has.call(r, k)) {
          var e = r[k];
          if (_.isLeft(e)) {
            left[k] = e.left;
          } else {
            right[k] = e.right;
          }
        }
      }
      return (0, Separated_1.separated)(left, right);
    };
    exports.separate = separate;
    exports.URI = "ReadonlyRecord";
    function getShow(O) {
      if ("compare" in O) {
        return function(S2) {
          return {
            show: function(r) {
              var elements = collect(O)(function(k, a) {
                return "".concat(JSON.stringify(k), ": ").concat(S2.show(a));
              })(r).join(", ");
              return elements === "" ? "{}" : "{ ".concat(elements, " }");
            }
          };
        };
      }
      return getShow(S.Ord)(O);
    }
    exports.getShow = getShow;
    function getEq(E) {
      var isSubrecordE = isSubrecord(E);
      return (0, Eq_1.fromEquals)(function(x, y) {
        return isSubrecordE(x)(y) && isSubrecordE(y)(x);
      });
    }
    exports.getEq = getEq;
    function getMonoid(S2) {
      return {
        concat: function(first, second) {
          if ((0, exports.isEmpty)(first)) {
            return second;
          }
          if ((0, exports.isEmpty)(second)) {
            return first;
          }
          var r = Object.assign({}, first);
          for (var k in second) {
            if (_.has.call(second, k)) {
              r[k] = _.has.call(first, k) ? S2.concat(first[k], second[k]) : second[k];
            }
          }
          return r;
        },
        empty: exports.empty
      };
    }
    exports.getMonoid = getMonoid;
    exports.Functor = {
      URI: exports.URI,
      map: exports._map
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.FunctorWithIndex = {
      URI: exports.URI,
      map: exports._map,
      mapWithIndex: exports._mapWithIndex
    };
    var getFoldable = function(O) {
      return {
        URI: exports.URI,
        reduce: (0, exports._reduce)(O),
        foldMap: (0, exports._foldMap)(O),
        reduceRight: (0, exports._reduceRight)(O)
      };
    };
    exports.getFoldable = getFoldable;
    var getFoldableWithIndex = function(O) {
      return {
        URI: exports.URI,
        reduce: (0, exports._reduce)(O),
        foldMap: (0, exports._foldMap)(O),
        reduceRight: (0, exports._reduceRight)(O),
        reduceWithIndex: (0, exports._reduceWithIndex)(O),
        foldMapWithIndex: (0, exports._foldMapWithIndex)(O),
        reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O)
      };
    };
    exports.getFoldableWithIndex = getFoldableWithIndex;
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: exports._map,
      compact: exports.compact,
      separate: exports.separate,
      filter: exports._filter,
      filterMap: exports._filterMap,
      partition: exports._partition,
      partitionMap: exports._partitionMap
    };
    exports.FilterableWithIndex = {
      URI: exports.URI,
      map: exports._map,
      mapWithIndex: exports._mapWithIndex,
      compact: exports.compact,
      separate: exports.separate,
      filter: exports._filter,
      filterMap: exports._filterMap,
      partition: exports._partition,
      partitionMap: exports._partitionMap,
      filterMapWithIndex: exports._filterMapWithIndex,
      filterWithIndex: exports._filterWithIndex,
      partitionMapWithIndex: exports._partitionMapWithIndex,
      partitionWithIndex: exports._partitionWithIndex
    };
    var getTraversable = function(O) {
      return {
        URI: exports.URI,
        map: exports._map,
        reduce: (0, exports._reduce)(O),
        foldMap: (0, exports._foldMap)(O),
        reduceRight: (0, exports._reduceRight)(O),
        traverse: (0, exports._traverse)(O),
        sequence: (0, exports._sequence)(O)
      };
    };
    exports.getTraversable = getTraversable;
    var getTraversableWithIndex = function(O) {
      return {
        URI: exports.URI,
        map: exports._map,
        mapWithIndex: exports._mapWithIndex,
        reduce: (0, exports._reduce)(O),
        foldMap: (0, exports._foldMap)(O),
        reduceRight: (0, exports._reduceRight)(O),
        reduceWithIndex: (0, exports._reduceWithIndex)(O),
        foldMapWithIndex: (0, exports._foldMapWithIndex)(O),
        reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O),
        traverse: (0, exports._traverse)(O),
        sequence: (0, exports._sequence)(O),
        traverseWithIndex: _traverseWithIndex(O)
      };
    };
    exports.getTraversableWithIndex = getTraversableWithIndex;
    var getWitherable = function(O) {
      var T = (0, exports.getTraversable)(O);
      return {
        URI: exports.URI,
        map: exports._map,
        reduce: (0, exports._reduce)(O),
        foldMap: (0, exports._foldMap)(O),
        reduceRight: (0, exports._reduceRight)(O),
        traverse: T.traverse,
        sequence: T.sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap,
        wither: (0, Witherable_1.witherDefault)(T, exports.Compactable),
        wilt: (0, Witherable_1.wiltDefault)(T, exports.Compactable)
      };
    };
    exports.getWitherable = getWitherable;
    var getUnionSemigroup = function(S2) {
      var unionS = (0, exports.union)(S2);
      return {
        concat: function(first, second) {
          return unionS(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(S2) {
      return {
        concat: (0, exports.getUnionSemigroup)(S2).concat,
        empty: exports.empty
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(S2) {
      var intersectionS = (0, exports.intersection)(S2);
      return {
        concat: function(first, second) {
          return intersectionS(second)(first);
        }
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function() {
      return {
        concat: function(first, second) {
          return (0, exports.difference)(second)(first);
        }
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    exports.Foldable = {
      URI: exports.URI,
      reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
      foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
      reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord)
    };
    exports.FoldableWithIndex = {
      URI: exports.URI,
      reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
      foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
      reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
      reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
      foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
      reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord)
    };
    exports.Traversable = {
      URI: exports.URI,
      map: exports._map,
      reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
      foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
      reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
      traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
      sequence
    };
    exports.TraversableWithIndex = {
      URI: exports.URI,
      map: exports._map,
      mapWithIndex: exports._mapWithIndex,
      reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
      foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
      reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
      reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
      foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
      reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord),
      traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
      sequence,
      traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord)
    };
    var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
    var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
    exports.Witherable = {
      URI: exports.URI,
      map: exports._map,
      reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
      foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
      reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
      traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
      sequence,
      compact: exports.compact,
      separate: exports.separate,
      filter: exports._filter,
      filterMap: exports._filterMap,
      partition: exports._partition,
      partitionMap: exports._partitionMap,
      wither: _wither,
      wilt: _wilt
    };
    exports.insertAt = exports.upsertAt;
    function hasOwnProperty(k, r) {
      return _.has.call(r === void 0 ? this : r, k);
    }
    exports.hasOwnProperty = hasOwnProperty;
    exports.readonlyRecord = {
      URI: exports.URI,
      map: exports._map,
      reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
      foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
      reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
      traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
      sequence,
      compact: exports.compact,
      separate: exports.separate,
      filter: exports._filter,
      filterMap: exports._filterMap,
      partition: exports._partition,
      partitionMap: exports._partitionMap,
      mapWithIndex: exports._mapWithIndex,
      reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
      foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
      reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord),
      filterMapWithIndex: exports._filterMapWithIndex,
      filterWithIndex: exports._filterWithIndex,
      partitionMapWithIndex: exports._partitionMapWithIndex,
      partitionWithIndex: exports._partitionWithIndex,
      traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord),
      wither: _wither,
      wilt: _wilt
    };
  }
});

// node_modules/fp-ts/lib/ReadonlySet.js
var require_ReadonlySet = __commonJS({
  "node_modules/fp-ts/lib/ReadonlySet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromArray = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getEq = exports.getShow = exports.URI = exports.toReadonlyArray = exports.elem = exports.isSubset = exports.every = exports.some = exports.size = exports.isEmpty = exports.empty = exports.filterMap = exports.separate = exports.compact = exports.toggle = exports.remove = exports.insert = exports.reduceRight = exports.foldMap = exports.reduce = exports.difference = exports.partitionMap = exports.intersection = exports.union = exports.partition = exports.filter = exports.chain = exports.map = exports.toSet = exports.fromReadonlyArray = exports.singleton = exports.fromSet = void 0;
    var Eq_1 = require_Eq();
    var function_1 = require_function();
    var Predicate_1 = require_Predicate();
    var Separated_1 = require_Separated();
    var fromSet = function(s) {
      return new Set(s);
    };
    exports.fromSet = fromSet;
    var singleton = function(a) {
      return /* @__PURE__ */ new Set([a]);
    };
    exports.singleton = singleton;
    var fromReadonlyArray = function(E) {
      return function(as) {
        var len = as.length;
        var out = /* @__PURE__ */ new Set();
        var has3 = elem(E);
        for (var i = 0; i < len; i++) {
          var a = as[i];
          if (!has3(a, out)) {
            out.add(a);
          }
        }
        return out;
      };
    };
    exports.fromReadonlyArray = fromReadonlyArray;
    function toSet(s) {
      return new Set(s);
    }
    exports.toSet = toSet;
    function map(E) {
      var elemE = elem(E);
      return function(f2) {
        return function(set) {
          var r = /* @__PURE__ */ new Set();
          set.forEach(function(e) {
            var v = f2(e);
            if (!elemE(v, r)) {
              r.add(v);
            }
          });
          return r;
        };
      };
    }
    exports.map = map;
    function chain(E) {
      var elemE = elem(E);
      return function(f2) {
        return function(set) {
          var r = /* @__PURE__ */ new Set();
          set.forEach(function(e) {
            f2(e).forEach(function(e2) {
              if (!elemE(e2, r)) {
                r.add(e2);
              }
            });
          });
          return r;
        };
      };
    }
    exports.chain = chain;
    function filter2(predicate) {
      return function(set) {
        var values = set.values();
        var e;
        var r = /* @__PURE__ */ new Set();
        while (!(e = values.next()).done) {
          var a = e.value;
          if (predicate(a)) {
            r.add(a);
          }
        }
        return r;
      };
    }
    exports.filter = filter2;
    function partition(predicate) {
      return function(set) {
        var values = set.values();
        var e;
        var right = /* @__PURE__ */ new Set();
        var left = /* @__PURE__ */ new Set();
        while (!(e = values.next()).done) {
          var a = e.value;
          if (predicate(a)) {
            right.add(a);
          } else {
            left.add(a);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.partition = partition;
    function union(E) {
      var elemE = elem(E);
      return function(me, that) {
        if (that === void 0) {
          var unionE_1 = union(E);
          return function(that2) {
            return unionE_1(me, that2);
          };
        }
        if ((0, exports.isEmpty)(me)) {
          return that;
        }
        if ((0, exports.isEmpty)(that)) {
          return me;
        }
        var r = new Set(me);
        that.forEach(function(e) {
          if (!elemE(e, r)) {
            r.add(e);
          }
        });
        return r;
      };
    }
    exports.union = union;
    function intersection(E) {
      var elemE = elem(E);
      return function(me, that) {
        if (that === void 0) {
          var intersectionE_1 = intersection(E);
          return function(that2) {
            return intersectionE_1(that2, me);
          };
        }
        if ((0, exports.isEmpty)(me) || (0, exports.isEmpty)(that)) {
          return exports.empty;
        }
        var r = /* @__PURE__ */ new Set();
        me.forEach(function(e) {
          if (elemE(e, that)) {
            r.add(e);
          }
        });
        return r;
      };
    }
    exports.intersection = intersection;
    function partitionMap(EB, EC) {
      return function(f2) {
        return function(set) {
          var values = set.values();
          var e;
          var left = /* @__PURE__ */ new Set();
          var right = /* @__PURE__ */ new Set();
          var hasB = elem(EB);
          var hasC = elem(EC);
          while (!(e = values.next()).done) {
            var v = f2(e.value);
            switch (v._tag) {
              case "Left":
                if (!hasB(v.left, left)) {
                  left.add(v.left);
                }
                break;
              case "Right":
                if (!hasC(v.right, right)) {
                  right.add(v.right);
                }
                break;
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
    }
    exports.partitionMap = partitionMap;
    function difference(E) {
      var elemE = elem(E);
      return function(me, that) {
        if (that === void 0) {
          var differenceE_1 = difference(E);
          return function(that2) {
            return differenceE_1(that2, me);
          };
        }
        return filter2(function(a) {
          return !elemE(a, that);
        })(me);
      };
    }
    exports.difference = difference;
    function reduce(O) {
      var toReadonlyArrayO = (0, exports.toReadonlyArray)(O);
      return function(b, f2) {
        return function(fa) {
          return toReadonlyArrayO(fa).reduce(f2, b);
        };
      };
    }
    exports.reduce = reduce;
    function foldMap(O, M) {
      var toReadonlyArrayO = (0, exports.toReadonlyArray)(O);
      return function(f2) {
        return function(fa) {
          return toReadonlyArrayO(fa).reduce(function(b, a) {
            return M.concat(b, f2(a));
          }, M.empty);
        };
      };
    }
    exports.foldMap = foldMap;
    var reduceRight = function(O) {
      var toReadonlyArrayO = (0, exports.toReadonlyArray)(O);
      return function(b, f2) {
        return function(fa) {
          return toReadonlyArrayO(fa).reduceRight(function(b2, a) {
            return f2(a, b2);
          }, b);
        };
      };
    };
    exports.reduceRight = reduceRight;
    function insert(E) {
      var elemE = elem(E);
      return function(a) {
        return function(set) {
          if (!elemE(a)(set)) {
            var r = new Set(set);
            r.add(a);
            return r;
          } else {
            return set;
          }
        };
      };
    }
    exports.insert = insert;
    var remove = function(E) {
      return function(a) {
        return function(set) {
          return filter2(function(ax) {
            return !E.equals(a, ax);
          })(set);
        };
      };
    };
    exports.remove = remove;
    var toggle = function(E) {
      var elemE = elem(E);
      var removeE = (0, exports.remove)(E);
      var insertE = insert(E);
      return function(a) {
        return function(set) {
          return (elemE(a, set) ? removeE : insertE)(a)(set);
        };
      };
    };
    exports.toggle = toggle;
    var compact = function(E) {
      return filterMap(E)(function_1.identity);
    };
    exports.compact = compact;
    function separate(EE, EA) {
      return function(fa) {
        var elemEE = elem(EE);
        var elemEA = elem(EA);
        var left = /* @__PURE__ */ new Set();
        var right = /* @__PURE__ */ new Set();
        fa.forEach(function(e) {
          switch (e._tag) {
            case "Left":
              if (!elemEE(e.left, left)) {
                left.add(e.left);
              }
              break;
            case "Right":
              if (!elemEA(e.right, right)) {
                right.add(e.right);
              }
              break;
          }
        });
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.separate = separate;
    function filterMap(E) {
      var elemE = elem(E);
      return function(f2) {
        return function(fa) {
          var r = /* @__PURE__ */ new Set();
          fa.forEach(function(a) {
            var ob = f2(a);
            if (ob._tag === "Some" && !elemE(ob.value, r)) {
              r.add(ob.value);
            }
          });
          return r;
        };
      };
    }
    exports.filterMap = filterMap;
    exports.empty = /* @__PURE__ */ new Set();
    var isEmpty = function(set) {
      return set.size === 0;
    };
    exports.isEmpty = isEmpty;
    var size = function(set) {
      return set.size;
    };
    exports.size = size;
    var some = function(predicate) {
      return function(set) {
        var values = set.values();
        var e;
        var found = false;
        while (!found && !(e = values.next()).done) {
          found = predicate(e.value);
        }
        return found;
      };
    };
    exports.some = some;
    function every(predicate) {
      return (0, Predicate_1.not)((0, exports.some)((0, Predicate_1.not)(predicate)));
    }
    exports.every = every;
    function isSubset(E) {
      var elemE = elem(E);
      return function(me, that) {
        if (that === void 0) {
          var isSubsetE_1 = isSubset(E);
          return function(that2) {
            return isSubsetE_1(that2, me);
          };
        }
        return every(function(a) {
          return elemE(a, that);
        })(me);
      };
    }
    exports.isSubset = isSubset;
    function elem(E) {
      return function(a, set) {
        if (set === void 0) {
          var elemE_1 = elem(E);
          return function(set2) {
            return elemE_1(a, set2);
          };
        }
        var values = set.values();
        var e;
        var found = false;
        while (!found && !(e = values.next()).done) {
          found = E.equals(a, e.value);
        }
        return found;
      };
    }
    exports.elem = elem;
    var toReadonlyArray = function(O) {
      return function(set) {
        var out = [];
        set.forEach(function(e) {
          return out.push(e);
        });
        return out.sort(O.compare);
      };
    };
    exports.toReadonlyArray = toReadonlyArray;
    exports.URI = "ReadonlySet";
    function getShow(S) {
      return {
        show: function(s) {
          var entries = [];
          s.forEach(function(a) {
            entries.push(S.show(a));
          });
          return "new Set([".concat(entries.sort().join(", "), "])");
        }
      };
    }
    exports.getShow = getShow;
    function getEq(E) {
      var subsetE = isSubset(E);
      return (0, Eq_1.fromEquals)(function(x, y) {
        return subsetE(x, y) && subsetE(y, x);
      });
    }
    exports.getEq = getEq;
    var getUnionSemigroup = function(E) {
      return {
        concat: union(E)
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(E) {
      return {
        concat: (0, exports.getUnionSemigroup)(E).concat,
        empty: exports.empty
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(E) {
      return {
        concat: intersection(E)
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function(E) {
      return {
        concat: difference(E)
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    exports.fromArray = exports.fromReadonlyArray;
  }
});

// node_modules/fp-ts/lib/ReadonlyTuple.js
var require_ReadonlyTuple = __commonJS({
  "node_modules/fp-ts/lib/ReadonlyTuple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readonlyTuple = exports.Traversable = exports.Foldable = exports.Comonad = exports.Semigroupoid = exports.Bifunctor = exports.mapLeft = exports.map = exports.flap = exports.Functor = exports.URI = exports.sequence = exports.traverse = exports.reduceRight = exports.foldMap = exports.reduce = exports.duplicate = exports.extract = exports.extend = exports.compose = exports.mapSnd = exports.mapFst = exports.bimap = exports.getChainRec = exports.getMonad = exports.getChain = exports.getApplicative = exports.getApply = exports.swap = exports.snd = exports.fst = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function fst(ea) {
      return ea[0];
    }
    exports.fst = fst;
    function snd(ea) {
      return ea[1];
    }
    exports.snd = snd;
    var swap = function(ea) {
      return [snd(ea), fst(ea)];
    };
    exports.swap = swap;
    function getApply(S) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return [fst(fab)(fst(fa)), S.concat(snd(fab), snd(fa))];
        }
      };
    }
    exports.getApply = getApply;
    var of = function(M) {
      return function(a) {
        return [a, M.empty];
      };
    };
    function getApplicative(M) {
      var A = getApply(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        of: of(M)
      };
    }
    exports.getApplicative = getApplicative;
    function getChain(S) {
      var A = getApply(S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        chain: function(ma, f2) {
          var _a2 = f2(fst(ma)), b = _a2[0], s = _a2[1];
          return [b, S.concat(snd(ma), s)];
        }
      };
    }
    exports.getChain = getChain;
    function getMonad(M) {
      var C = getChain(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: C.ap,
        chain: C.chain,
        of: of(M)
      };
    }
    exports.getMonad = getMonad;
    function getChainRec(M) {
      var chainRec = function(a, f2) {
        var result = f2(a);
        var acc = M.empty;
        var s = fst(result);
        while (s._tag === "Left") {
          acc = M.concat(acc, snd(result));
          result = f2(s.left);
          s = fst(result);
        }
        return [s.right, M.concat(acc, snd(result))];
      };
      var C = getChain(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: C.ap,
        chain: C.chain,
        chainRec
      };
    }
    exports.getChainRec = getChainRec;
    var _compose = function(bc, ab) {
      return (0, function_1.pipe)(bc, (0, exports.compose)(ab));
    };
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapFst)(f2));
    };
    var _bimap = function(fa, f2, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f2, g));
    };
    var _mapLeft = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapSnd)(f2));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var bimap = function(f2, g) {
      return function(fa) {
        return [g(fst(fa)), f2(snd(fa))];
      };
    };
    exports.bimap = bimap;
    var mapFst = function(f2) {
      return function(fa) {
        return [f2(fst(fa)), snd(fa)];
      };
    };
    exports.mapFst = mapFst;
    var mapSnd = function(f2) {
      return function(fa) {
        return [fst(fa), f2(snd(fa))];
      };
    };
    exports.mapSnd = mapSnd;
    var compose2 = function(ab) {
      return function(bc) {
        return [fst(bc), snd(ab)];
      };
    };
    exports.compose = compose2;
    var extend = function(f2) {
      return function(wa) {
        return [f2(wa), snd(wa)];
      };
    };
    exports.extend = extend;
    exports.extract = fst;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    var reduce = function(b, f2) {
      return function(fa) {
        return f2(b, fst(fa));
      };
    };
    exports.reduce = reduce;
    var foldMap = function() {
      return function(f2) {
        return function(fa) {
          return f2(fst(fa));
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f2) {
      return function(fa) {
        return f2(fst(fa), b);
      };
    };
    exports.reduceRight = reduceRight;
    var traverse = function(F) {
      return function(f2) {
        return function(ta) {
          return F.map(f2(fst(ta)), function(b) {
            return [b, snd(ta)];
          });
        };
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(fas) {
        return F.map(fst(fas), function(a) {
          return [a, snd(fas)];
        });
      };
    };
    exports.sequence = sequence;
    exports.URI = "ReadonlyTuple";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.map = exports.mapFst;
    exports.mapLeft = exports.mapSnd;
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    exports.Semigroupoid = {
      URI: exports.URI,
      compose: _compose
    };
    exports.Comonad = {
      URI: exports.URI,
      map: _map2,
      extend: _extend,
      extract: exports.extract
    };
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.readonlyTuple = {
      URI: exports.URI,
      compose: _compose,
      map: _map2,
      bimap: _bimap,
      mapLeft: _mapLeft,
      extract: exports.extract,
      extend: _extend,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
  }
});

// node_modules/fp-ts/lib/Record.js
var require_Record = __commonJS({
  "node_modules/fp-ts/lib/Record.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t3[p] = s[p];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromFoldableMap = exports.fromEntries = exports.toEntries = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toArray = exports.collect = exports.keys = exports.isEmpty = exports.size = void 0;
    exports.record = exports.hasOwnProperty = exports.insertAt = exports.empty = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = void 0;
    var A = __importStar(require_Array());
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var RR = __importStar(require_ReadonlyRecord());
    var Se = __importStar(require_Semigroup());
    var S = __importStar(require_string());
    var Witherable_1 = require_Witherable();
    exports.size = RR.size;
    exports.isEmpty = RR.isEmpty;
    var keys_ = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    exports.keys = keys_(S.Ord);
    function collect(O) {
      if (typeof O === "function") {
        return collect(S.Ord)(O);
      }
      var keysO = keys_(O);
      return function(f2) {
        return function(r) {
          var out = [];
          for (var _i = 0, _a2 = keysO(r); _i < _a2.length; _i++) {
            var key = _a2[_i];
            out.push(f2(key, r[key]));
          }
          return out;
        };
      };
    }
    exports.collect = collect;
    exports.toArray = collect(S.Ord)(function(k, a) {
      return [
        k,
        a
      ];
    });
    function toUnfoldable(U) {
      return function(r) {
        var sas = (0, exports.toArray)(r);
        var len = sas.length;
        return U.unfold(0, function(b) {
          return b < len ? _.some([sas[b], b + 1]) : _.none;
        });
      };
    }
    exports.toUnfoldable = toUnfoldable;
    exports.upsertAt = RR.upsertAt;
    exports.has = RR.has;
    function deleteAt(k) {
      return function(r) {
        if (!_.has.call(r, k)) {
          return r;
        }
        var out = Object.assign({}, r);
        delete out[k];
        return out;
      };
    }
    exports.deleteAt = deleteAt;
    var updateAt = function(k, a) {
      return (0, exports.modifyAt)(k, function() {
        return a;
      });
    };
    exports.updateAt = updateAt;
    var modifyAt = function(k, f2) {
      return function(r) {
        if (!(0, exports.has)(k, r)) {
          return _.none;
        }
        var out = Object.assign({}, r);
        out[k] = f2(r[k]);
        return _.some(out);
      };
    };
    exports.modifyAt = modifyAt;
    function pop(k) {
      var deleteAtk = deleteAt(k);
      return function(r) {
        var oa = (0, exports.lookup)(k, r);
        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);
      };
    }
    exports.pop = pop;
    exports.isSubrecord = RR.isSubrecord;
    exports.lookup = RR.lookup;
    exports.mapWithIndex = RR.mapWithIndex;
    exports.map = RR.map;
    function reduceWithIndex() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);
    }
    exports.reduceWithIndex = reduceWithIndex;
    function foldMapWithIndex(O) {
      return "compare" in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);
    }
    exports.foldMapWithIndex = foldMapWithIndex;
    function reduceRightWithIndex() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);
    }
    exports.reduceRightWithIndex = reduceRightWithIndex;
    exports.singleton = RR.singleton;
    function traverseWithIndex(F) {
      return RR.traverseWithIndex(F);
    }
    exports.traverseWithIndex = traverseWithIndex;
    function traverse(F) {
      return RR.traverse(F);
    }
    exports.traverse = traverse;
    function sequence(F) {
      return RR.sequence(F);
    }
    exports.sequence = sequence;
    var wither = function(F) {
      var traverseF = traverse(F);
      return function(f2) {
        return function(fa) {
          return F.map((0, function_1.pipe)(fa, traverseF(f2)), exports.compact);
        };
      };
    };
    exports.wither = wither;
    var wilt = function(F) {
      var traverseF = traverse(F);
      return function(f2) {
        return function(fa) {
          return F.map((0, function_1.pipe)(fa, traverseF(f2)), exports.separate);
        };
      };
    };
    exports.wilt = wilt;
    exports.partitionMapWithIndex = RR.partitionMapWithIndex;
    function partitionWithIndex(predicateWithIndex) {
      return RR.partitionWithIndex(predicateWithIndex);
    }
    exports.partitionWithIndex = partitionWithIndex;
    exports.filterMapWithIndex = RR.filterMapWithIndex;
    function filterWithIndex(predicateWithIndex) {
      return RR.filterWithIndex(predicateWithIndex);
    }
    exports.filterWithIndex = filterWithIndex;
    function fromFoldable(M, F) {
      return RR.fromFoldable(M, F);
    }
    exports.fromFoldable = fromFoldable;
    exports.toEntries = exports.toArray;
    var fromEntries = function(fa) {
      return fromFoldable(Se.last(), A.Foldable)(fa);
    };
    exports.fromEntries = fromEntries;
    function fromFoldableMap(M, F) {
      return RR.fromFoldableMap(M, F);
    }
    exports.fromFoldableMap = fromFoldableMap;
    exports.every = RR.every;
    exports.some = RR.some;
    exports.elem = RR.elem;
    var union = function(M) {
      var unionM = RR.union(M);
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return __assign({}, second);
          }
          if ((0, exports.isEmpty)(second)) {
            return __assign({}, first);
          }
          return unionM(second)(first);
        };
      };
    };
    exports.union = union;
    var intersection = function(M) {
      return function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
            return {};
          }
          return RR.intersection(M)(second)(first);
        };
      };
    };
    exports.intersection = intersection;
    var difference = function(second) {
      return function(first) {
        if ((0, exports.isEmpty)(first)) {
          return __assign({}, second);
        }
        if ((0, exports.isEmpty)(second)) {
          return __assign({}, first);
        }
        return RR.difference(second)(first);
      };
    };
    exports.difference = difference;
    var _map2 = RR._map;
    var _mapWithIndex = RR._mapWithIndex;
    var _reduce = RR._reduce;
    var _foldMap = RR._foldMap;
    var _reduceRight = RR._reduceRight;
    var _filter2 = RR._filter;
    var _filterMap = RR._filterMap;
    var _partition = RR._partition;
    var _partitionMap = RR._partitionMap;
    var _reduceWithIndex = RR._reduceWithIndex;
    var _foldMapWithIndex = RR._foldMapWithIndex;
    var _reduceRightWithIndex = RR._reduceRightWithIndex;
    var _partitionMapWithIndex = RR._partitionMapWithIndex;
    var _partitionWithIndex = RR._partitionWithIndex;
    var _filterMapWithIndex = RR._filterMapWithIndex;
    var _filterWithIndex = RR._filterWithIndex;
    var _traverse = RR._traverse;
    var _sequence = RR._sequence;
    var _traverseWithIndex = function(O) {
      return function(F) {
        var keysO = keys_(O);
        return function(ta, f2) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of({});
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                r[key2] = b;
                return r;
              };
            }), f2(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    exports.filter = RR.filter;
    exports.filterMap = RR.filterMap;
    exports.partition = RR.partition;
    exports.partitionMap = RR.partitionMap;
    function reduce() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);
    }
    exports.reduce = reduce;
    function foldMap(O) {
      return "compare" in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);
    }
    exports.foldMap = foldMap;
    function reduceRight() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);
    }
    exports.reduceRight = reduceRight;
    exports.compact = RR.compact;
    exports.separate = RR.separate;
    exports.URI = "Record";
    function getShow(O) {
      return "compare" in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);
    }
    exports.getShow = getShow;
    exports.getEq = RR.getEq;
    exports.getMonoid = RR.getMonoid;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.FunctorWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex
    };
    var getFoldable = function(O) {
      return {
        URI: exports.URI,
        reduce: _reduce(O),
        foldMap: _foldMap(O),
        reduceRight: _reduceRight(O)
      };
    };
    exports.getFoldable = getFoldable;
    var getFoldableWithIndex = function(O) {
      return {
        URI: exports.URI,
        reduce: _reduce(O),
        foldMap: _foldMap(O),
        reduceRight: _reduceRight(O),
        reduceWithIndex: _reduceWithIndex(O),
        foldMapWithIndex: _foldMapWithIndex(O),
        reduceRightWithIndex: _reduceRightWithIndex(O)
      };
    };
    exports.getFoldableWithIndex = getFoldableWithIndex;
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    exports.FilterableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex
    };
    var getTraversable = function(O) {
      return {
        URI: exports.URI,
        map: _map2,
        reduce: _reduce(O),
        foldMap: _foldMap(O),
        reduceRight: _reduceRight(O),
        traverse: _traverse(O),
        sequence: _sequence(O)
      };
    };
    exports.getTraversable = getTraversable;
    var getTraversableWithIndex = function(O) {
      return {
        URI: exports.URI,
        map: _map2,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce(O),
        foldMap: _foldMap(O),
        reduceRight: _reduceRight(O),
        reduceWithIndex: _reduceWithIndex(O),
        foldMapWithIndex: _foldMapWithIndex(O),
        reduceRightWithIndex: _reduceRightWithIndex(O),
        traverse: _traverse(O),
        sequence: _sequence(O),
        traverseWithIndex: _traverseWithIndex(O)
      };
    };
    exports.getTraversableWithIndex = getTraversableWithIndex;
    var getWitherable = function(O) {
      var T = (0, exports.getTraversable)(O);
      return {
        URI: exports.URI,
        map: _map2,
        reduce: _reduce(O),
        foldMap: _foldMap(O),
        reduceRight: _reduceRight(O),
        traverse: T.traverse,
        sequence: T.sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter2,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: (0, Witherable_1.witherDefault)(T, exports.Compactable),
        wilt: (0, Witherable_1.wiltDefault)(T, exports.Compactable)
      };
    };
    exports.getWitherable = getWitherable;
    var getUnionSemigroup = function(S2) {
      var unionS = (0, exports.union)(S2);
      return {
        concat: function(first, second) {
          return unionS(second)(first);
        }
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(S2) {
      return {
        concat: (0, exports.getUnionSemigroup)(S2).concat,
        empty: {}
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(S2) {
      var intersectionS = (0, exports.intersection)(S2);
      return {
        concat: function(first, second) {
          return intersectionS(second)(first);
        }
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function() {
      return {
        concat: function(first, second) {
          return (0, exports.difference)(second)(first);
        }
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    exports.Foldable = {
      URI: exports.URI,
      reduce: /* @__PURE__ */ _reduce(S.Ord),
      foldMap: /* @__PURE__ */ _foldMap(S.Ord),
      reduceRight: /* @__PURE__ */ _reduceRight(S.Ord)
    };
    exports.FoldableWithIndex = {
      URI: exports.URI,
      reduce: /* @__PURE__ */ _reduce(S.Ord),
      foldMap: /* @__PURE__ */ _foldMap(S.Ord),
      reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
      reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
      foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
      reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord)
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: /* @__PURE__ */ _reduce(S.Ord),
      foldMap: /* @__PURE__ */ _foldMap(S.Ord),
      reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
      traverse: /* @__PURE__ */ _traverse(S.Ord),
      sequence
    };
    exports.TraversableWithIndex = {
      URI: exports.URI,
      map: _map2,
      mapWithIndex: _mapWithIndex,
      reduce: /* @__PURE__ */ _reduce(S.Ord),
      foldMap: /* @__PURE__ */ _foldMap(S.Ord),
      reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
      reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
      foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
      reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord),
      traverse: /* @__PURE__ */ _traverse(S.Ord),
      sequence,
      traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord)
    };
    var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
    var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
    exports.Witherable = {
      URI: exports.URI,
      map: _map2,
      reduce: /* @__PURE__ */ _reduce(S.Ord),
      foldMap: /* @__PURE__ */ _foldMap(S.Ord),
      reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
      traverse: /* @__PURE__ */ _traverse(S.Ord),
      sequence,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      wither: _wither,
      wilt: _wilt
    };
    exports.empty = {};
    exports.insertAt = exports.upsertAt;
    exports.hasOwnProperty = RR.hasOwnProperty;
    exports.record = {
      URI: exports.URI,
      map: _map2,
      reduce: /* @__PURE__ */ _reduce(S.Ord),
      foldMap: /* @__PURE__ */ _foldMap(S.Ord),
      reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
      traverse: /* @__PURE__ */ _traverse(S.Ord),
      sequence,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      mapWithIndex: _mapWithIndex,
      reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
      foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
      reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord),
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord),
      wither: _wither,
      wilt: _wilt
    };
  }
});

// node_modules/fp-ts/lib/Refinement.js
var require_Refinement = __commonJS({
  "node_modules/fp-ts/lib/Refinement.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compose = exports.zero = exports.and = exports.or = exports.not = exports.id = exports.fromEitherK = exports.fromOptionK = void 0;
    var _ = __importStar(require_internal());
    var fromOptionK = function(getOption) {
      return function(a) {
        return _.isSome(getOption(a));
      };
    };
    exports.fromOptionK = fromOptionK;
    var fromEitherK = function(getEither) {
      return function(a) {
        return _.isRight(getEither(a));
      };
    };
    exports.fromEitherK = fromEitherK;
    var id = function() {
      return function(_2) {
        return true;
      };
    };
    exports.id = id;
    var not = function(refinement) {
      return function(a) {
        return !refinement(a);
      };
    };
    exports.not = not;
    var or = function(second) {
      return function(first) {
        return function(a) {
          return first(a) || second(a);
        };
      };
    };
    exports.or = or;
    var and = function(second) {
      return function(first) {
        return function(a) {
          return first(a) && second(a);
        };
      };
    };
    exports.and = and;
    var zero = function() {
      return function(_2) {
        return false;
      };
    };
    exports.zero = zero;
    var compose2 = function(bc) {
      return function(ab) {
        return function(i) {
          return ab(i) && bc(i);
        };
      };
    };
    exports.compose = compose2;
  }
});

// node_modules/fp-ts/lib/Ring.js
var require_Ring = __commonJS({
  "node_modules/fp-ts/lib/Ring.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionRing = exports.getTupleRing = exports.negate = exports.tuple = void 0;
    var function_1 = require_function();
    var tuple = function() {
      var rings = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        rings[_i] = arguments[_i];
      }
      return {
        add: function(x, y) {
          return rings.map(function(R, i) {
            return R.add(x[i], y[i]);
          });
        },
        zero: rings.map(function(R) {
          return R.zero;
        }),
        mul: function(x, y) {
          return rings.map(function(R, i) {
            return R.mul(x[i], y[i]);
          });
        },
        one: rings.map(function(R) {
          return R.one;
        }),
        sub: function(x, y) {
          return rings.map(function(R, i) {
            return R.sub(x[i], y[i]);
          });
        }
      };
    };
    exports.tuple = tuple;
    var negate = function(R) {
      return function(a) {
        return R.sub(R.zero, a);
      };
    };
    exports.negate = negate;
    exports.getTupleRing = exports.tuple;
    exports.getFunctionRing = function_1.getRing;
  }
});

// node_modules/fp-ts/lib/Semigroupoid.js
var require_Semigroupoid = __commonJS({
  "node_modules/fp-ts/lib/Semigroupoid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Semiring.js
var require_Semiring = __commonJS({
  "node_modules/fp-ts/lib/Semiring.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionSemiring = void 0;
    var function_1 = require_function();
    exports.getFunctionSemiring = function_1.getSemiring;
  }
});

// node_modules/fp-ts/lib/Set.js
var require_Set = __commonJS({
  "node_modules/fp-ts/lib/Set.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subset = exports.toArray = exports.elem = exports.isSubset = exports.every = exports.some = exports.size = exports.isEmpty = exports.empty = exports.filterMap = exports.separate = exports.compact = exports.fromArray = exports.toggle = exports.remove = exports.insert = exports.singleton = exports.reduceRight = exports.foldMap = exports.reduce = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.difference = exports.partitionMap = exports.intersection = exports.union = exports.partition = exports.filter = exports.chain = exports.map = exports.getEq = exports.getShow = void 0;
    var function_1 = require_function();
    var RS = __importStar(require_ReadonlySet());
    var Separated_1 = require_Separated();
    exports.getShow = RS.getShow;
    exports.getEq = RS.getEq;
    function map(E) {
      var elemE = (0, exports.elem)(E);
      return function(f2) {
        return function(set) {
          var r = /* @__PURE__ */ new Set();
          set.forEach(function(e) {
            var v = f2(e);
            if (!elemE(v, r)) {
              r.add(v);
            }
          });
          return r;
        };
      };
    }
    exports.map = map;
    function chain(E) {
      var elemE = (0, exports.elem)(E);
      return function(f2) {
        return function(set) {
          var r = /* @__PURE__ */ new Set();
          set.forEach(function(e) {
            f2(e).forEach(function(e2) {
              if (!elemE(e2, r)) {
                r.add(e2);
              }
            });
          });
          return r;
        };
      };
    }
    exports.chain = chain;
    function filter2(predicate) {
      return function(set) {
        var values = set.values();
        var e;
        var r = /* @__PURE__ */ new Set();
        while (!(e = values.next()).done) {
          var a = e.value;
          if (predicate(a)) {
            r.add(a);
          }
        }
        return r;
      };
    }
    exports.filter = filter2;
    function partition(predicate) {
      return function(set) {
        var values = set.values();
        var e;
        var right = /* @__PURE__ */ new Set();
        var left = /* @__PURE__ */ new Set();
        while (!(e = values.next()).done) {
          var a = e.value;
          if (predicate(a)) {
            right.add(a);
          } else {
            left.add(a);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.partition = partition;
    function union(E) {
      var elemE = (0, exports.elem)(E);
      return function(me, that) {
        if (that === void 0) {
          var unionE_1 = union(E);
          return function(that2) {
            return unionE_1(me, that2);
          };
        }
        if ((0, exports.isEmpty)(me)) {
          return that;
        }
        if ((0, exports.isEmpty)(that)) {
          return me;
        }
        var r = new Set(me);
        that.forEach(function(e) {
          if (!elemE(e, r)) {
            r.add(e);
          }
        });
        return r;
      };
    }
    exports.union = union;
    function intersection(E) {
      var elemE = (0, exports.elem)(E);
      return function(me, that) {
        if (that === void 0) {
          var intersectionE_1 = intersection(E);
          return function(that2) {
            return intersectionE_1(that2, me);
          };
        }
        if ((0, exports.isEmpty)(me) || (0, exports.isEmpty)(that)) {
          return /* @__PURE__ */ new Set();
        }
        var r = /* @__PURE__ */ new Set();
        me.forEach(function(e) {
          if (elemE(e, that)) {
            r.add(e);
          }
        });
        return r;
      };
    }
    exports.intersection = intersection;
    function partitionMap(EB, EC) {
      return function(f2) {
        return function(set) {
          var values = set.values();
          var e;
          var left = /* @__PURE__ */ new Set();
          var right = /* @__PURE__ */ new Set();
          var hasB = (0, exports.elem)(EB);
          var hasC = (0, exports.elem)(EC);
          while (!(e = values.next()).done) {
            var v = f2(e.value);
            switch (v._tag) {
              case "Left":
                if (!hasB(v.left, left)) {
                  left.add(v.left);
                }
                break;
              case "Right":
                if (!hasC(v.right, right)) {
                  right.add(v.right);
                }
                break;
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
    }
    exports.partitionMap = partitionMap;
    function difference(E) {
      var elemE = (0, exports.elem)(E);
      return function(me, that) {
        if (that === void 0) {
          var differenceE_1 = difference(E);
          return function(that2) {
            return differenceE_1(that2, me);
          };
        }
        return filter2(function(a) {
          return !elemE(a, that);
        })(me);
      };
    }
    exports.difference = difference;
    var getUnionSemigroup = function(E) {
      return {
        concat: union(E)
      };
    };
    exports.getUnionSemigroup = getUnionSemigroup;
    var getUnionMonoid = function(E) {
      return {
        concat: (0, exports.getUnionSemigroup)(E).concat,
        empty: /* @__PURE__ */ new Set()
      };
    };
    exports.getUnionMonoid = getUnionMonoid;
    var getIntersectionSemigroup = function(E) {
      return {
        concat: intersection(E)
      };
    };
    exports.getIntersectionSemigroup = getIntersectionSemigroup;
    var getDifferenceMagma = function(E) {
      return {
        concat: difference(E)
      };
    };
    exports.getDifferenceMagma = getDifferenceMagma;
    exports.reduce = RS.reduce;
    exports.foldMap = RS.foldMap;
    exports.reduceRight = RS.reduceRight;
    var singleton = function(a) {
      return /* @__PURE__ */ new Set([a]);
    };
    exports.singleton = singleton;
    function insert(E) {
      var elemE = (0, exports.elem)(E);
      return function(a) {
        return function(set) {
          if (!elemE(a)(set)) {
            var r = new Set(set);
            r.add(a);
            return r;
          } else {
            return set;
          }
        };
      };
    }
    exports.insert = insert;
    var remove = function(E) {
      return function(a) {
        return function(set) {
          return filter2(function(ax) {
            return !E.equals(a, ax);
          })(set);
        };
      };
    };
    exports.remove = remove;
    var toggle = function(E) {
      var elemE = (0, exports.elem)(E);
      var removeE = (0, exports.remove)(E);
      var insertE = insert(E);
      return function(a) {
        return function(set) {
          return (elemE(a, set) ? removeE : insertE)(a)(set);
        };
      };
    };
    exports.toggle = toggle;
    var fromArray = function(E) {
      return function(as) {
        var len = as.length;
        var out = /* @__PURE__ */ new Set();
        var has3 = (0, exports.elem)(E);
        for (var i = 0; i < len; i++) {
          var a = as[i];
          if (!has3(a, out)) {
            out.add(a);
          }
        }
        return out;
      };
    };
    exports.fromArray = fromArray;
    var compact = function(E) {
      return filterMap(E)(function_1.identity);
    };
    exports.compact = compact;
    function separate(EE, EA) {
      return function(fa) {
        var elemEE = (0, exports.elem)(EE);
        var elemEA = (0, exports.elem)(EA);
        var left = /* @__PURE__ */ new Set();
        var right = /* @__PURE__ */ new Set();
        fa.forEach(function(e) {
          switch (e._tag) {
            case "Left":
              if (!elemEE(e.left, left)) {
                left.add(e.left);
              }
              break;
            case "Right":
              if (!elemEA(e.right, right)) {
                right.add(e.right);
              }
              break;
          }
        });
        return (0, Separated_1.separated)(left, right);
      };
    }
    exports.separate = separate;
    function filterMap(E) {
      var elemE = (0, exports.elem)(E);
      return function(f2) {
        return function(fa) {
          var r = /* @__PURE__ */ new Set();
          fa.forEach(function(a) {
            var ob = f2(a);
            if (ob._tag === "Some" && !elemE(ob.value, r)) {
              r.add(ob.value);
            }
          });
          return r;
        };
      };
    }
    exports.filterMap = filterMap;
    exports.empty = /* @__PURE__ */ new Set();
    var isEmpty = function(set) {
      return set.size === 0;
    };
    exports.isEmpty = isEmpty;
    var size = function(set) {
      return set.size;
    };
    exports.size = size;
    exports.some = RS.some;
    exports.every = RS.every;
    exports.isSubset = RS.isSubset;
    exports.elem = RS.elem;
    var toArray = function(O) {
      return function(set) {
        var out = [];
        set.forEach(function(e) {
          return out.push(e);
        });
        return out.sort(O.compare);
      };
    };
    exports.toArray = toArray;
    exports.subset = RS.isSubset;
  }
});

// node_modules/fp-ts/lib/Show.js
var require_Show = __commonJS({
  "node_modules/fp-ts/lib/Show.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.showNumber = exports.showString = exports.showBoolean = exports.getStructShow = exports.getTupleShow = exports.tuple = exports.struct = void 0;
    var _ = __importStar(require_internal());
    var struct = function(shows) {
      return {
        show: function(a) {
          var s = "{";
          for (var k in shows) {
            if (_.has.call(shows, k)) {
              s += " ".concat(k, ": ").concat(shows[k].show(a[k]), ",");
            }
          }
          if (s.length > 1) {
            s = s.slice(0, -1) + " ";
          }
          s += "}";
          return s;
        }
      };
    };
    exports.struct = struct;
    var tuple = function() {
      var shows = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        shows[_i] = arguments[_i];
      }
      return {
        show: function(t3) {
          return "[".concat(t3.map(function(a, i) {
            return shows[i].show(a);
          }).join(", "), "]");
        }
      };
    };
    exports.tuple = tuple;
    exports.getTupleShow = exports.tuple;
    exports.getStructShow = exports.struct;
    exports.showBoolean = {
      show: function(a) {
        return JSON.stringify(a);
      }
    };
    exports.showString = {
      show: function(a) {
        return JSON.stringify(a);
      }
    };
    exports.showNumber = {
      show: function(a) {
        return JSON.stringify(a);
      }
    };
  }
});

// node_modules/fp-ts/lib/StateT.js
var require_StateT = __commonJS({
  "node_modules/fp-ts/lib/StateT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStateM = exports.execute = exports.evaluate = exports.fromF = exports.fromState = exports.flatMap = exports.chain = exports.ap = exports.map = exports.of = void 0;
    var function_1 = require_function();
    var ReadonlyTuple_1 = require_ReadonlyTuple();
    function of(F) {
      return function(a) {
        return function(s) {
          return F.of([a, s]);
        };
      };
    }
    exports.of = of;
    function map(F) {
      return function(f2) {
        return function(fa) {
          return function(s) {
            return F.map(fa(s), function(_a2) {
              var a = _a2[0], s1 = _a2[1];
              return [f2(a), s1];
            });
          };
        };
      };
    }
    exports.map = map;
    function ap(M) {
      return function(fa) {
        return function(fab) {
          return function(s) {
            return M.chain(fab(s), function(_a2) {
              var f2 = _a2[0], s2 = _a2[1];
              return M.map(fa(s2), function(_a3) {
                var a = _a3[0], s3 = _a3[1];
                return [f2(a), s3];
              });
            });
          };
        };
      };
    }
    exports.ap = ap;
    function chain(M) {
      var flatMapM = flatMap(M);
      return function(f2) {
        return function(ma) {
          return flatMapM(ma, f2);
        };
      };
    }
    exports.chain = chain;
    function flatMap(M) {
      return function(ma, f2) {
        return function(s) {
          return M.chain(ma(s), function(_a2) {
            var a = _a2[0], s1 = _a2[1];
            return f2(a)(s1);
          });
        };
      };
    }
    exports.flatMap = flatMap;
    function fromState(F) {
      return function(sa) {
        return function(s) {
          return F.of(sa(s));
        };
      };
    }
    exports.fromState = fromState;
    function fromF(F) {
      return function(ma) {
        return function(s) {
          return F.map(ma, function(a) {
            return [a, s];
          });
        };
      };
    }
    exports.fromF = fromF;
    function evaluate(F) {
      return function(s) {
        return function(ma) {
          return F.map(ma(s), function(_a2) {
            var a = _a2[0];
            return a;
          });
        };
      };
    }
    exports.evaluate = evaluate;
    function execute(F) {
      return function(s) {
        return function(ma) {
          return F.map(ma(s), ReadonlyTuple_1.snd);
        };
      };
    }
    exports.execute = execute;
    function getStateM(M) {
      var _ap = ap(M);
      var _map2 = map(M);
      var _chain = chain(M);
      var _evaluate = evaluate(M);
      var _execute = execute(M);
      return {
        map: function(fa, f2) {
          return (0, function_1.pipe)(fa, _map2(f2));
        },
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, _ap(fa));
        },
        of: of(M),
        chain: function(ma, f2) {
          return (0, function_1.pipe)(ma, _chain(f2));
        },
        get: function() {
          return function(s) {
            return M.of([s, s]);
          };
        },
        put: function(s) {
          return function() {
            return M.of([void 0, s]);
          };
        },
        modify: function(f2) {
          return function(s) {
            return M.of([void 0, f2(s)]);
          };
        },
        gets: function(f2) {
          return function(s) {
            return M.of([f2(s), s]);
          };
        },
        fromState: fromState(M),
        fromM: fromF(M),
        evalState: function(fa, s) {
          return (0, function_1.pipe)(fa, _evaluate(s));
        },
        execState: function(fa, s) {
          return (0, function_1.pipe)(fa, _execute(s));
        }
      };
    }
    exports.getStateM = getStateM;
  }
});

// node_modules/fp-ts/lib/StateReaderTaskEither.js
var require_StateReaderTaskEither = __commonJS({
  "node_modules/fp-ts/lib/StateReaderTaskEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Functor = exports.URI = exports.throwError = exports.alt = exports.altW = exports.flatten = exports.flattenW = exports.flatMapState = exports.flatMapReaderTaskEither = exports.flatMapOption = exports.flatMapEither = exports.flatMapIOEither = exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapTaskEither = exports.flatMap = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.chainReaderTaskEitherK = exports.chainReaderTaskEitherKW = exports.fromReaderTaskEitherK = exports.fromTaskEitherK = exports.fromIOEitherK = exports.asksStateReaderTaskEither = exports.asksStateReaderTaskEitherW = exports.local = exports.fromReaderTaskEither = exports.fromReaderEither = exports.fromIOEither = exports.fromTaskEither = exports.fromState = exports.fromTask = exports.fromIO = exports.fromReader = exports.fromEither = exports.leftState = exports.rightState = exports.leftIO = exports.rightIO = exports.leftReader = exports.rightReader = exports.leftTask = exports.rightTask = exports.right = exports.left = void 0;
    exports.filterOrElse = exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.Alt = exports.Bifunctor = exports.tapReader = exports.tapTask = exports.tapIO = exports.tapEither = exports.tap = exports.FromReader = exports.FromTask = exports.FromIO = exports.FromEither = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.chainStateK = exports.fromStateK = exports.gets = exports.modify = exports.put = exports.get = exports.FromState = exports.Chain = exports.Applicative = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.asUnit = exports.as = void 0;
    exports.run = exports.execState = exports.evalState = exports.stateReaderTaskEitherSeq = exports.stateReaderTaskEither = exports.chainFirstW = exports.chainFirst = exports.chainW = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.execute = exports.evaluate = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.chainIOEitherK = exports.chainIOEitherKW = exports.chainTaskEitherK = exports.chainTaskEitherKW = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.fromEitherK = exports.filterOrElseW = void 0;
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var E = __importStar(require_Either());
    var FromEither_1 = require_FromEither();
    var FromIO_1 = require_FromIO();
    var FromReader_1 = require_FromReader();
    var FromState_1 = require_FromState();
    var FromTask_1 = require_FromTask();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var R = __importStar(require_Reader());
    var RTE = __importStar(require_ReaderTaskEither());
    var ST = __importStar(require_StateT());
    var left = function(e) {
      return function() {
        return RTE.left(e);
      };
    };
    exports.left = left;
    exports.right = ST.of(RTE.Pointed);
    function rightTask(ma) {
      return (0, exports.fromReaderTaskEither)(RTE.rightTask(ma));
    }
    exports.rightTask = rightTask;
    function leftTask(me) {
      return (0, exports.fromReaderTaskEither)(RTE.leftTask(me));
    }
    exports.leftTask = leftTask;
    function rightReader(ma) {
      return (0, exports.fromReaderTaskEither)(RTE.rightReader(ma));
    }
    exports.rightReader = rightReader;
    function leftReader(me) {
      return (0, exports.fromReaderTaskEither)(RTE.leftReader(me));
    }
    exports.leftReader = leftReader;
    function rightIO(ma) {
      return (0, exports.fromReaderTaskEither)(RTE.rightIO(ma));
    }
    exports.rightIO = rightIO;
    function leftIO(me) {
      return (0, exports.fromReaderTaskEither)(RTE.leftIO(me));
    }
    exports.leftIO = leftIO;
    var rightState = function(sa) {
      return (0, function_1.flow)(sa, RTE.right);
    };
    exports.rightState = rightState;
    var leftState = function(me) {
      return function(s) {
        return RTE.left(me(s)[0]);
      };
    };
    exports.leftState = leftState;
    exports.fromEither = /* @__PURE__ */ E.match(function(e) {
      return (0, exports.left)(e);
    }, exports.right);
    exports.fromReader = rightReader;
    exports.fromIO = rightIO;
    exports.fromTask = rightTask;
    exports.fromState = /* @__PURE__ */ ST.fromState(RTE.Pointed);
    var fromTaskEither = function(ma) {
      return (0, exports.fromReaderTaskEither)(RTE.fromTaskEither(ma));
    };
    exports.fromTaskEither = fromTaskEither;
    var fromIOEither = function(ma) {
      return (0, exports.fromReaderTaskEither)(RTE.fromIOEither(ma));
    };
    exports.fromIOEither = fromIOEither;
    var fromReaderEither = function(ma) {
      return (0, exports.fromReaderTaskEither)(RTE.fromReaderEither(ma));
    };
    exports.fromReaderEither = fromReaderEither;
    exports.fromReaderTaskEither = /* @__PURE__ */ ST.fromF(RTE.Functor);
    var local = function(f2) {
      return function(ma) {
        return (0, function_1.flow)(ma, R.local(f2));
      };
    };
    exports.local = local;
    var asksStateReaderTaskEitherW = function(f2) {
      return function(s) {
        return function(r) {
          return f2(r)(s)(r);
        };
      };
    };
    exports.asksStateReaderTaskEitherW = asksStateReaderTaskEitherW;
    exports.asksStateReaderTaskEither = exports.asksStateReaderTaskEitherW;
    var fromIOEitherK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.fromIOEither)(f2.apply(void 0, a));
      };
    };
    exports.fromIOEitherK = fromIOEitherK;
    var fromTaskEitherK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.fromTaskEither)(f2.apply(void 0, a));
      };
    };
    exports.fromTaskEitherK = fromTaskEitherK;
    var fromReaderTaskEitherK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.fromReaderTaskEither)(f2.apply(void 0, a));
      };
    };
    exports.fromReaderTaskEitherK = fromReaderTaskEitherK;
    var chainReaderTaskEitherKW = function(f2) {
      return function(ma) {
        return (0, exports.flatMap)(ma, (0, exports.fromReaderTaskEitherK)(f2));
      };
    };
    exports.chainReaderTaskEitherKW = chainReaderTaskEitherKW;
    exports.chainReaderTaskEitherK = exports.chainReaderTaskEitherKW;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _alt = function(fa, that) {
      return function(s) {
        return (0, function_1.pipe)(fa(s), RTE.alt(function() {
          return that()(s);
        }));
      };
    };
    var _bimap = function(fea, f2, g) {
      return function(s) {
        return (0, function_1.pipe)(fea(s), RTE.bimap(f2, function(_a2) {
          var a = _a2[0], s2 = _a2[1];
          return [g(a), s2];
        }));
      };
    };
    var _mapLeft = function(fea, f2) {
      return function(s) {
        return (0, function_1.pipe)(fea(s), RTE.mapLeft(f2));
      };
    };
    exports.map = ST.map(RTE.Functor);
    var bimap = function(f2, g) {
      return function(fa) {
        return _bimap(fa, f2, g);
      };
    };
    exports.bimap = bimap;
    var mapLeft = function(f2) {
      return function(fa) {
        return _mapLeft(fa, f2);
      };
    };
    exports.mapLeft = mapLeft;
    exports.ap = ST.ap(RTE.Chain);
    exports.apW = exports.ap;
    exports.of = exports.right;
    var _FromIO = {
      fromIO: exports.fromIO
    };
    var _FromTask = {
      fromTask: exports.fromTask
    };
    var _FromReader = {
      fromReader: exports.fromReader
    };
    var _FromEither = {
      fromEither: exports.fromEither
    };
    exports.flatMap = (0, function_1.dual)(2, ST.flatMap(RTE.Monad));
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    exports.flatMapTaskEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, function(a) {
        return (0, exports.fromTaskEitherK)(f2)(a);
      });
    });
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.flatMapTask = _.flatMapTask(_FromTask, _FlatMap);
    exports.flatMapReader = _.flatMapReader(_FromReader, _FlatMap);
    exports.flatMapIOEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, function(a) {
        return (0, exports.fromIOEitherK)(f2)(a);
      });
    });
    exports.flatMapEither = (0, function_1.dual)(2, _.flatMapEither(_FromEither, _FlatMap));
    exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
    exports.flatMapReaderTaskEither = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, function(a) {
        return (0, exports.fromReaderTaskEitherK)(f2)(a);
      });
    });
    exports.flatMapState = (0, function_1.dual)(2, function(self, f2) {
      return (0, exports.flatMap)(self, (0, exports.fromStateK)(f2));
    });
    exports.flattenW = (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    var altW = function(that) {
      return function(fa) {
        return function(r) {
          return (0, function_1.pipe)(fa(r), RTE.altW(function() {
            return that()(r);
          }));
        };
      };
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    exports.throwError = exports.left;
    exports.URI = "StateReaderTaskEither";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.FromState = {
      URI: exports.URI,
      fromState: exports.fromState
    };
    exports.get = (0, FromState_1.get)(exports.FromState);
    exports.put = (0, FromState_1.put)(exports.FromState);
    exports.modify = /* @__PURE__ */ (0, FromState_1.modify)(exports.FromState);
    exports.gets = /* @__PURE__ */ (0, FromState_1.gets)(exports.FromState);
    exports.fromStateK = (0, FromState_1.fromStateK)(exports.FromState);
    exports.chainStateK = (0, FromState_1.chainStateK)(exports.FromState, exports.Chain);
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.MonadTask = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.FromTask = {
      URI: exports.URI,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.FromReader = {
      URI: exports.URI,
      fromReader: exports.fromReader
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.tapTask = (0, function_1.dual)(2, (0, FromTask_1.tapTask)(exports.FromTask, exports.Chain));
    exports.tapReader = (0, function_1.dual)(2, (0, FromReader_1.tapReader)(exports.FromReader, exports.Chain));
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.ask = (0, FromReader_1.ask)(exports.FromReader);
    exports.asks = /* @__PURE__ */ (0, FromReader_1.asks)(exports.FromReader);
    exports.fromReaderK = (0, FromReader_1.fromReaderK)(exports.FromReader);
    exports.chainReaderK = exports.flatMapReader;
    exports.chainReaderKW = exports.flatMapReader;
    exports.chainFirstReaderK = exports.tapReader;
    exports.chainFirstReaderKW = exports.tapReader;
    exports.fromOption = (0, FromEither_1.fromOption)(exports.FromEither);
    exports.fromOptionK = (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.chainOptionKW = exports.chainOptionK;
    exports.chainEitherK = exports.flatMapEither;
    exports.chainEitherKW = exports.flatMapEither;
    exports.chainFirstEitherK = exports.tapEither;
    exports.chainFirstEitherKW = exports.tapEither;
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.chainTaskEitherKW = exports.flatMapTaskEither;
    exports.chainTaskEitherK = exports.flatMapTaskEither;
    exports.chainIOEitherKW = exports.flatMapIOEither;
    exports.chainIOEitherK = exports.flatMapIOEither;
    exports.fromTaskK = (0, FromTask_1.fromTaskK)(exports.FromTask);
    exports.chainTaskK = exports.flatMapTask;
    exports.chainFirstTaskK = exports.tapTask;
    exports.evaluate = /* @__PURE__ */ ST.evaluate(RTE.Functor);
    exports.execute = /* @__PURE__ */ ST.execute(RTE.Functor);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return function(as) {
        return function(s) {
          return function(r) {
            return function() {
              return _.tail(as).reduce(function(acc, a, i) {
                return acc.then(function(ebs) {
                  return _.isLeft(ebs) ? acc : f2(i + 1, a)(ebs.right[1])(r)().then(function(eb) {
                    if (_.isLeft(eb)) {
                      return eb;
                    }
                    var _a2 = eb.right, b = _a2[0], s2 = _a2[1];
                    ebs.right[0].push(b);
                    ebs.right[1] = s2;
                    return ebs;
                  });
                });
              }, f2(0, _.head(as))(s)(r)().then(E.map(function(_a2) {
                var b = _a2[0], s2 = _a2[1];
                return [[b], s2];
              })));
            };
          };
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : (0, exports.of)(_.emptyReadonlyArray);
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = (0, exports.traverseArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainW = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    exports.stateReaderTaskEither = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      bimap: _bimap,
      mapLeft: _mapLeft,
      alt: _alt,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask,
      throwError: exports.throwError
    };
    exports.stateReaderTaskEitherSeq = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      bimap: _bimap,
      mapLeft: _mapLeft,
      alt: _alt,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask,
      throwError: exports.throwError
    };
    var evalState = function(fsa, s) {
      return (0, function_1.pipe)(fsa(s), RTE.map(function(_a2) {
        var a = _a2[0];
        return a;
      }));
    };
    exports.evalState = evalState;
    var execState = function(fsa, s) {
      return (0, function_1.pipe)(fsa(s), RTE.map(function(_a2) {
        var _2 = _a2[0], s2 = _a2[1];
        return s2;
      }));
    };
    exports.execState = execState;
    function run(ma, s, r) {
      return ma(s)(r)();
    }
    exports.run = run;
  }
});

// node_modules/fp-ts/lib/Store.js
var require_Store = __commonJS({
  "node_modules/fp-ts/lib/Store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.store = exports.Comonad = exports.flap = exports.Functor = exports.URI = exports.map = exports.duplicate = exports.extract = exports.extend = exports.experiment = exports.peeks = exports.seeks = exports.seek = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function seek(s) {
      return function(wa) {
        return { peek: wa.peek, pos: s };
      };
    }
    exports.seek = seek;
    function seeks(f2) {
      return function(wa) {
        return { peek: wa.peek, pos: f2(wa.pos) };
      };
    }
    exports.seeks = seeks;
    function peeks(f2) {
      return function(wa) {
        return wa.peek(f2(wa.pos));
      };
    }
    exports.peeks = peeks;
    function experiment(F) {
      return function(f2) {
        return function(wa) {
          return F.map(f2(wa.pos), function(s) {
            return wa.peek(s);
          });
        };
      };
    }
    exports.experiment = experiment;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var extend = function(f2) {
      return function(wa) {
        return {
          peek: function(s) {
            return f2({ peek: wa.peek, pos: s });
          },
          pos: wa.pos
        };
      };
    };
    exports.extend = extend;
    var extract = function(wa) {
      return wa.peek(wa.pos);
    };
    exports.extract = extract;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    var map = function(f2) {
      return function(fa) {
        return {
          peek: function(s) {
            return f2(fa.peek(s));
          },
          pos: fa.pos
        };
      };
    };
    exports.map = map;
    exports.URI = "Store";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Comonad = {
      URI: exports.URI,
      map: _map2,
      extend: _extend,
      extract: exports.extract
    };
    exports.store = exports.Comonad;
  }
});

// node_modules/fp-ts/lib/Strong.js
var require_Strong = __commonJS({
  "node_modules/fp-ts/lib/Strong.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fanout = exports.splitStrong = exports.fanOut = exports.split = void 0;
    var function_1 = require_function();
    function split(S, C) {
      return function(pab, pcd) {
        return C.compose(S.second(pcd), S.first(pab));
      };
    }
    exports.split = split;
    function fanOut(S, C) {
      var splitSC = split(S, C);
      return function(pab, pac) {
        return C.compose(splitSC(pab, pac), S.promap(C.id(), function_1.identity, function(a) {
          return [a, a];
        }));
      };
    }
    exports.fanOut = fanOut;
    function splitStrong(F) {
      return split(F, F);
    }
    exports.splitStrong = splitStrong;
    function fanout(F) {
      return fanOut(F, F);
    }
    exports.fanout = fanout;
  }
});

// node_modules/fp-ts/lib/struct.js
var require_struct = __commonJS({
  "node_modules/fp-ts/lib/struct.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evolve = exports.getAssignSemigroup = void 0;
    var _ = __importStar(require_internal());
    var getAssignSemigroup = function() {
      return {
        concat: function(first, second) {
          return Object.assign({}, first, second);
        }
      };
    };
    exports.getAssignSemigroup = getAssignSemigroup;
    var evolve = function(transformations) {
      return function(a) {
        var out = {};
        for (var k in a) {
          if (_.has.call(a, k)) {
            out[k] = transformations[k](a[k]);
          }
        }
        return out;
      };
    };
    exports.evolve = evolve;
  }
});

// node_modules/fp-ts/lib/TaskOption.js
var require_TaskOption = __commonJS({
  "node_modules/fp-ts/lib/TaskOption.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f2, y, t3, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f2 = 1, y && (t3 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t3 = y["return"]) && t3.call(y), 0) : y.next) && !(t3 = t3.call(y, op[1])).done)
              return t3;
            if (y = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t3[1]) {
                  _2.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _2.label < t3[2]) {
                  _2.label = t3[2];
                  _2.ops.push(op);
                  break;
                }
                if (t3[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApplySeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.asUnit = exports.as = exports.Functor = exports.URI = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.separate = exports.compact = exports.none = exports.zero = exports.altW = exports.alt = exports.flatten = exports.flatMapTask = exports.flatMapIO = exports.flatMap = exports.of = exports.ap = exports.map = exports.chainOptionK = exports.fromOptionK = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromTaskEither = exports.fromTask = exports.fromIO = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.some = void 0;
    exports.chainFirst = exports.chain = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.Filterable = exports.Compactable = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.tapTask = exports.tapIO = exports.tapEither = exports.tap = exports.FromTask = exports.FromIO = exports.FromEither = exports.Chain = exports.ApplicativeSeq = void 0;
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var Compactable_1 = require_Compactable();
    var Filterable_1 = require_Filterable();
    var FromEither_1 = require_FromEither();
    var FromIO_1 = require_FromIO();
    var FromTask_1 = require_FromTask();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var O = __importStar(require_Option());
    var OT = __importStar(require_OptionT());
    var T = __importStar(require_Task());
    var Zero_1 = require_Zero();
    exports.some = OT.some(T.Pointed);
    exports.fromPredicate = OT.fromPredicate(T.Pointed);
    exports.fromOption = T.of;
    exports.fromEither = OT.fromEither(T.Pointed);
    var fromIO = function(ma) {
      return (0, exports.fromTask)(T.fromIO(ma));
    };
    exports.fromIO = fromIO;
    exports.fromTask = OT.fromF(T.Functor);
    exports.fromTaskEither = T.map(O.fromEither);
    exports.match = /* @__PURE__ */ OT.match(T.Functor);
    exports.matchW = exports.match;
    exports.matchE = /* @__PURE__ */ OT.matchE(T.Chain);
    exports.fold = exports.matchE;
    exports.matchEW = exports.matchE;
    exports.foldW = exports.matchEW;
    exports.getOrElse = OT.getOrElse(T.Monad);
    exports.getOrElseW = exports.getOrElse;
    exports.fromNullable = OT.fromNullable(T.Pointed);
    var tryCatch = function(f2) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var reason_1;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 3]);
                return [4, f2().then(_.some)];
              case 1:
                return [2, _a2.sent()];
              case 2:
                reason_1 = _a2.sent();
                return [2, _.none];
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.tryCatch = tryCatch;
    var tryCatchK = function(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f2.apply(void 0, a);
        });
      };
    };
    exports.tryCatchK = tryCatchK;
    exports.fromNullableK = OT.fromNullableK(T.Pointed);
    exports.chainNullableK = OT.chainNullableK(T.Monad);
    exports.fromOptionK = OT.fromOptionK(T.Pointed);
    exports.chainOptionK = /* @__PURE__ */ OT.chainOptionK(T.Monad);
    exports.map = OT.map(T.Functor);
    exports.ap = OT.ap(T.ApplyPar);
    exports.of = exports.some;
    var _FromIO = {
      fromIO: exports.fromIO
    };
    var _FromTask = {
      fromTask: exports.fromTask
    };
    exports.flatMap = (0, function_1.dual)(2, OT.flatMap(T.Monad));
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    exports.flatMapIO = _.flatMapIO(_FromIO, _FlatMap);
    exports.flatMapTask = _.flatMapTask(_FromTask, _FlatMap);
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    exports.alt = OT.alt(T.Monad);
    exports.altW = exports.alt;
    exports.zero = OT.zero(T.Pointed);
    exports.none = (0, exports.zero)();
    exports.compact = (0, Compactable_1.compact)(T.Functor, O.Compactable);
    exports.separate = (0, Compactable_1.separate)(T.Functor, O.Compactable, O.Functor);
    exports.filter = (0, Filterable_1.filter)(T.Functor, O.Filterable);
    exports.filterMap = /* @__PURE__ */ (0, Filterable_1.filterMap)(T.Functor, O.Filterable);
    exports.partition = (0, Filterable_1.partition)(T.Functor, O.Filterable);
    exports.partitionMap = (0, Filterable_1.partitionMap)(T.Functor, O.Filterable);
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _filter2 = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
    };
    var _filterMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.filterMap)(f2));
    };
    var _partition = function(fa, predicate) {
      return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
    };
    var _partitionMap = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f2));
    };
    exports.URI = "TaskOption";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.ApplyPar = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.ApplyPar);
    exports.apSecond = (0, Apply_1.apSecond)(exports.ApplyPar);
    exports.ApplicativePar = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    var _apSeq = function(fab, fa) {
      return (0, exports.flatMap)(fab, function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    exports.ApplySeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq
    };
    exports.ApplicativeSeq = {
      URI: exports.URI,
      map: _map2,
      ap: _apSeq,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.FromTask = {
      URI: exports.URI,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));
    exports.tapIO = (0, function_1.dual)(2, (0, FromIO_1.tapIO)(exports.FromIO, exports.Chain));
    exports.tapTask = (0, function_1.dual)(2, (0, FromTask_1.tapTask)(exports.FromTask, exports.Chain));
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    exports.Zero = {
      URI: exports.URI,
      zero: exports.zero
    };
    exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
    exports.Alternative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      alt: _alt,
      zero: exports.zero
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.MonadIO = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      fromIO: exports.fromIO
    };
    exports.MonadTask = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.Compactable = {
      URI: exports.URI,
      compact: exports.compact,
      separate: exports.separate
    };
    exports.Filterable = {
      URI: exports.URI,
      map: _map2,
      compact: exports.compact,
      separate: exports.separate,
      filter: _filter2,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap
    };
    exports.fromIOK = /* @__PURE__ */ (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.chainIOK = exports.flatMapIO;
    exports.chainFirstIOK = exports.tapIO;
    exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
    exports.chainEitherK = /* @__PURE__ */ (0, FromEither_1.chainEitherK)(exports.FromEither, exports.Chain);
    exports.chainFirstEitherK = exports.tapEither;
    exports.fromTaskK = /* @__PURE__ */ (0, FromTask_1.fromTaskK)(exports.FromTask);
    exports.chainTaskK = exports.flatMapTask;
    exports.chainFirstTaskK = exports.tapTask;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = chainable.bind(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.ApplyPar);
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f2) {
      return (0, function_1.flow)(T.traverseReadonlyNonEmptyArrayWithIndex(f2), T.map(O.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f2) {
      return function(as) {
        return function() {
          return _.tail(as).reduce(function(acc, a, i) {
            return acc.then(function(obs) {
              return _.isNone(obs) ? acc : f2(i + 1, a)().then(function(ob) {
                if (_.isNone(ob)) {
                  return ob;
                }
                obs.value.push(ob.value);
                return obs;
              });
            });
          }, f2(0, _.head(as))().then(O.map(_.singleton)));
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
    var traverseReadonlyArrayWithIndexSeq = function(f2) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(f2);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.traverseSeqArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq;
    var traverseSeqArray = function(f2) {
      return (0, exports.traverseReadonlyArrayWithIndexSeq)(function(_2, a) {
        return f2(a);
      });
    };
    exports.traverseSeqArray = traverseSeqArray;
    exports.sequenceSeqArray = /* @__PURE__ */ (0, exports.traverseSeqArray)(function_1.identity);
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
  }
});

// node_modules/fp-ts/lib/These.js
var require_These = __commonJS({
  "node_modules/fp-ts/lib/These.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTuple = exports.toTuple2 = exports.exists = exports.elem = exports.fromOptionK = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.Traversable = exports.Foldable = exports.FromThese = exports.Bifunctor = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.of = exports.sequence = exports.traverse = exports.reduceRight = exports.foldMap = exports.reduce = exports.map = exports.mapLeft = exports.bimap = exports.fromOptions = exports.getRightOnly = exports.getLeftOnly = exports.rightOrBoth = exports.leftOrBoth = exports.getRight = exports.getLeft = exports.getMonad = exports.getChain = exports.getApplicative = exports.getApply = exports.getSemigroup = exports.getEq = exports.getShow = exports.swap = exports.fold = exports.match = exports.foldW = exports.matchW = exports.both = exports.right = exports.left = exports.isBoth = exports.isRight = exports.isLeft = void 0;
    exports.these = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = void 0;
    var Eq_1 = require_Eq();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var isLeft = function(fa) {
      return fa._tag === "Left";
    };
    exports.isLeft = isLeft;
    var isRight = function(fa) {
      return fa._tag === "Right";
    };
    exports.isRight = isRight;
    function isBoth(fa) {
      return fa._tag === "Both";
    }
    exports.isBoth = isBoth;
    function left(left2) {
      return { _tag: "Left", left: left2 };
    }
    exports.left = left;
    function right(right2) {
      return { _tag: "Right", right: right2 };
    }
    exports.right = right;
    function both(left2, right2) {
      return { _tag: "Both", left: left2, right: right2 };
    }
    exports.both = both;
    var matchW = function(onLeft, onRight, onBoth) {
      return function(fa) {
        switch (fa._tag) {
          case "Left":
            return onLeft(fa.left);
          case "Right":
            return onRight(fa.right);
          case "Both":
            return onBoth(fa.left, fa.right);
        }
      };
    };
    exports.matchW = matchW;
    exports.foldW = exports.matchW;
    exports.match = exports.matchW;
    exports.fold = exports.match;
    exports.swap = (0, exports.match)(right, left, function(e, a) {
      return both(a, e);
    });
    function getShow(SE, SA) {
      return {
        show: (0, exports.match)(function(l) {
          return "left(".concat(SE.show(l), ")");
        }, function(a) {
          return "right(".concat(SA.show(a), ")");
        }, function(l, a) {
          return "both(".concat(SE.show(l), ", ").concat(SA.show(a), ")");
        })
      };
    }
    exports.getShow = getShow;
    function getEq(EE, EA) {
      return (0, Eq_1.fromEquals)(function(x, y) {
        return (0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EE.equals(x.left, y.left) : (0, exports.isRight)(x) ? (0, exports.isRight)(y) && EA.equals(x.right, y.right) : isBoth(y) && EE.equals(x.left, y.left) && EA.equals(x.right, y.right);
      });
    }
    exports.getEq = getEq;
    function getSemigroup(SE, SA) {
      return {
        concat: function(x, y) {
          return (0, exports.isLeft)(x) ? (0, exports.isLeft)(y) ? left(SE.concat(x.left, y.left)) : (0, exports.isRight)(y) ? both(x.left, y.right) : both(SE.concat(x.left, y.left), y.right) : (0, exports.isRight)(x) ? (0, exports.isLeft)(y) ? both(y.left, x.right) : (0, exports.isRight)(y) ? right(SA.concat(x.right, y.right)) : both(y.left, SA.concat(x.right, y.right)) : (0, exports.isLeft)(y) ? both(SE.concat(x.left, y.left), x.right) : (0, exports.isRight)(y) ? both(x.left, SA.concat(x.right, y.right)) : both(SE.concat(x.left, y.left), SA.concat(x.right, y.right));
        }
      };
    }
    exports.getSemigroup = getSemigroup;
    var getApply = function(S) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? left(S.concat(fab.left, fa.left)) : (0, exports.isRight)(fa) ? left(fab.left) : left(S.concat(fab.left, fa.left)) : (0, exports.isRight)(fab) ? (0, exports.isLeft)(fa) ? left(fa.left) : (0, exports.isRight)(fa) ? right(fab.right(fa.right)) : both(fa.left, fab.right(fa.right)) : (0, exports.isLeft)(fa) ? left(S.concat(fab.left, fa.left)) : (0, exports.isRight)(fa) ? both(fab.left, fab.right(fa.right)) : both(S.concat(fab.left, fa.left), fab.right(fa.right));
        }
      };
    };
    exports.getApply = getApply;
    function getApplicative(S) {
      var A = (0, exports.getApply)(S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        of: exports.of
      };
    }
    exports.getApplicative = getApplicative;
    function getChain(S) {
      var A = (0, exports.getApply)(S);
      var chain = function(ma, f2) {
        if ((0, exports.isLeft)(ma)) {
          return ma;
        }
        if ((0, exports.isRight)(ma)) {
          return f2(ma.right);
        }
        var fb = f2(ma.right);
        return (0, exports.isLeft)(fb) ? left(S.concat(ma.left, fb.left)) : (0, exports.isRight)(fb) ? both(ma.left, fb.right) : both(S.concat(ma.left, fb.left), fb.right);
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        chain
      };
    }
    exports.getChain = getChain;
    function getMonad(S) {
      var C = getChain(S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        of: exports.of,
        ap: C.ap,
        chain: C.chain,
        throwError: left
      };
    }
    exports.getMonad = getMonad;
    function getLeft(fa) {
      return (0, exports.isLeft)(fa) ? _.some(fa.left) : (0, exports.isRight)(fa) ? _.none : _.some(fa.left);
    }
    exports.getLeft = getLeft;
    function getRight(fa) {
      return (0, exports.isLeft)(fa) ? _.none : (0, exports.isRight)(fa) ? _.some(fa.right) : _.some(fa.right);
    }
    exports.getRight = getRight;
    function leftOrBoth(e) {
      return function(ma) {
        return _.isNone(ma) ? left(e) : both(e, ma.value);
      };
    }
    exports.leftOrBoth = leftOrBoth;
    function rightOrBoth(a) {
      return function(me) {
        return _.isNone(me) ? right(a) : both(me.value, a);
      };
    }
    exports.rightOrBoth = rightOrBoth;
    function getLeftOnly(fa) {
      return (0, exports.isLeft)(fa) ? _.some(fa.left) : _.none;
    }
    exports.getLeftOnly = getLeftOnly;
    function getRightOnly(fa) {
      return (0, exports.isRight)(fa) ? _.some(fa.right) : _.none;
    }
    exports.getRightOnly = getRightOnly;
    var fromOptions = function(fe, fa) {
      return _.isNone(fe) ? _.isNone(fa) ? _.none : _.some(right(fa.value)) : _.isNone(fa) ? _.some(left(fe.value)) : _.some(both(fe.value, fa.value));
    };
    exports.fromOptions = fromOptions;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _bimap = function(fa, f2, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f2, g));
    };
    var _mapLeft = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f2));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var bimap = function(f2, g) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? left(f2(fa.left)) : (0, exports.isRight)(fa) ? right(g(fa.right)) : both(f2(fa.left), g(fa.right));
      };
    };
    exports.bimap = bimap;
    var mapLeft = function(f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? left(f2(fa.left)) : isBoth(fa) ? both(f2(fa.left), fa.right) : fa;
      };
    };
    exports.mapLeft = mapLeft;
    var map = function(f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? fa : (0, exports.isRight)(fa) ? right(f2(fa.right)) : both(fa.left, f2(fa.right));
      };
    };
    exports.map = map;
    var reduce = function(b, f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f2(b, fa.right);
      };
    };
    exports.reduce = reduce;
    var foldMap = function(M) {
      return function(f2) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? M.empty : f2(fa.right);
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f2) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f2(fa.right, b);
      };
    };
    exports.reduceRight = reduceRight;
    var traverse = function(F) {
      return function(f2) {
        return function(ta) {
          return (0, exports.isLeft)(ta) ? F.of(ta) : (0, exports.isRight)(ta) ? F.map(f2(ta.right), right) : F.map(f2(ta.right), function(b) {
            return both(ta.left, b);
          });
        };
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(ta) {
        return (0, exports.isLeft)(ta) ? F.of(ta) : (0, exports.isRight)(ta) ? F.map(ta.right, right) : F.map(ta.right, function(b) {
          return both(ta.left, b);
        });
      };
    };
    exports.sequence = sequence;
    exports.of = right;
    exports.URI = "These";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    exports.FromThese = {
      URI: exports.URI,
      fromThese: function_1.identity
    };
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: function_1.identity
    };
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
    var elem = function(E) {
      return function(a) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
        };
      };
    };
    exports.elem = elem;
    var exists = function(predicate) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
      };
    };
    exports.exists = exists;
    var toTuple2 = function(e, a) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? [fa.left, a()] : (0, exports.isRight)(fa) ? [e(), fa.right] : [fa.left, fa.right];
      };
    };
    exports.toTuple2 = toTuple2;
    var toTuple = function(e, a) {
      return (0, exports.toTuple2)(function() {
        return e;
      }, function() {
        return a;
      });
    };
    exports.toTuple = toTuple;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(S) {
      return function(f2) {
        return function(as) {
          var e = _.none;
          var t3 = f2(0, _.head(as));
          if ((0, exports.isLeft)(t3)) {
            return t3;
          }
          if (isBoth(t3)) {
            e = _.some(t3.left);
          }
          var out = [t3.right];
          for (var i = 1; i < as.length; i++) {
            var t_1 = f2(i, as[i]);
            if ((0, exports.isLeft)(t_1)) {
              return t_1;
            }
            if (isBoth(t_1)) {
              e = _.isNone(e) ? _.some(t_1.left) : _.some(S.concat(e.value, t_1.left));
            }
            out.push(t_1.right);
          }
          return _.isNone(e) ? right(out) : both(e.value, out);
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(S) {
      return function(f2) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(S)(f2);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.these = {
      URI: exports.URI,
      map: _map2,
      bimap: _bimap,
      mapLeft: _mapLeft,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
  }
});

// node_modules/fp-ts/lib/TheseT.js
var require_TheseT = __commonJS({
  "node_modules/fp-ts/lib/TheseT.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTheseM = exports.toTuple2 = exports.swap = exports.matchE = exports.match = exports.mapLeft = exports.bimap = exports.chain = exports.ap = exports.map = exports.leftF = exports.rightF = exports.both = exports.left = exports.right = void 0;
    var Apply_1 = require_Apply();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var T = __importStar(require_These());
    function right(F) {
      return (0, function_1.flow)(T.right, F.of);
    }
    exports.right = right;
    function left(F) {
      return (0, function_1.flow)(T.left, F.of);
    }
    exports.left = left;
    function both(F) {
      return (0, function_1.flow)(T.both, F.of);
    }
    exports.both = both;
    function rightF(F) {
      return function(fa) {
        return F.map(fa, T.right);
      };
    }
    exports.rightF = rightF;
    function leftF(F) {
      return function(fe) {
        return F.map(fe, T.left);
      };
    }
    exports.leftF = leftF;
    function map(F) {
      return (0, Functor_1.map)(F, T.Functor);
    }
    exports.map = map;
    function ap(F, S) {
      return (0, Apply_1.ap)(F, T.getApply(S));
    }
    exports.ap = ap;
    function chain(M, S) {
      var _left = left(M);
      return function(f2) {
        return function(ma) {
          return M.chain(ma, T.match(_left, f2, function(e1, a) {
            return M.map(f2(a), T.match(function(e2) {
              return T.left(S.concat(e1, e2));
            }, function(b) {
              return T.both(e1, b);
            }, function(e2, b) {
              return T.both(S.concat(e1, e2), b);
            }));
          }));
        };
      };
    }
    exports.chain = chain;
    function bimap(F) {
      return function(f2, g) {
        return function(fea) {
          return F.map(fea, T.bimap(f2, g));
        };
      };
    }
    exports.bimap = bimap;
    function mapLeft(F) {
      return function(f2) {
        return function(fea) {
          return F.map(fea, T.mapLeft(f2));
        };
      };
    }
    exports.mapLeft = mapLeft;
    function match(F) {
      return function(onLeft, onRight, onBoth) {
        return function(ma) {
          return F.map(ma, T.match(onLeft, onRight, onBoth));
        };
      };
    }
    exports.match = match;
    function matchE(M) {
      return function(onLeft, onRight, onBoth) {
        return function(ma) {
          return M.chain(ma, T.match(onLeft, onRight, onBoth));
        };
      };
    }
    exports.matchE = matchE;
    function swap(F) {
      return function(ma) {
        return F.map(ma, T.swap);
      };
    }
    exports.swap = swap;
    function toTuple2(F) {
      return function(e, a) {
        return function(fa) {
          return F.map(fa, T.toTuple2(e, a));
        };
      };
    }
    exports.toTuple2 = toTuple2;
    function getTheseM(M) {
      var _map2 = map(M);
      var _bimap = bimap(M);
      var _mapLeft = mapLeft(M);
      var _fold = matchE(M);
      var _toTuple2 = toTuple2(M);
      var of = right(M);
      var mapT = function(fa, f2) {
        return (0, function_1.pipe)(fa, _map2(f2));
      };
      return {
        map: mapT,
        bimap: function(fea, f2, g) {
          return (0, function_1.pipe)(fea, _bimap(f2, g));
        },
        mapLeft: function(fea, f2) {
          return (0, function_1.pipe)(fea, _mapLeft(f2));
        },
        fold: function(fa, onLeft, onRight, onBoth) {
          return (0, function_1.pipe)(fa, _fold(onLeft, onRight, onBoth));
        },
        swap: swap(M),
        rightM: rightF(M),
        leftM: leftF(M),
        left: left(M),
        right: right(M),
        both: both(M),
        toTuple: function(fa, e, a) {
          return (0, function_1.pipe)(fa, _toTuple2(function() {
            return e;
          }, function() {
            return a;
          }));
        },
        getMonad: function(S) {
          var _ap = ap(M, S);
          var _chain = chain(M, S);
          return {
            _E: void 0,
            map: mapT,
            of,
            ap: function(fab, fa) {
              return (0, function_1.pipe)(fab, _ap(fa));
            },
            chain: function(ma, f2) {
              return (0, function_1.pipe)(ma, _chain(f2));
            }
          };
        }
      };
    }
    exports.getTheseM = getTheseM;
  }
});

// node_modules/fp-ts/lib/TaskThese.js
var require_TaskThese = __commonJS({
  "node_modules/fp-ts/lib/TaskThese.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bifunctorTaskThese = exports.functorTaskThese = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.toTuple2 = exports.fromTaskK = exports.FromTask = exports.fromIOK = exports.FromIO = exports.fromTheseK = exports.FromThese = exports.fromPredicate = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.Bifunctor = exports.Pointed = exports.flap = exports.Functor = exports.getMonad = exports.getChain = exports.getApplicative = exports.getApply = exports.URI = exports.of = exports.mapLeft = exports.bimap = exports.map = exports.swap = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromTask = exports.fromIOEither = exports.fromIO = exports.fromThese = exports.fromEither = exports.leftIO = exports.rightIO = exports.leftTask = exports.rightTask = exports.both = exports.right = exports.left = void 0;
    exports.getSemigroup = exports.taskThese = exports.toTuple = void 0;
    var Apply_1 = require_Apply();
    var FromEither_1 = require_FromEither();
    var FromIO_1 = require_FromIO();
    var FromTask_1 = require_FromTask();
    var FromThese_1 = require_FromThese();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var T = __importStar(require_Task());
    var TH = __importStar(require_These());
    var TT = __importStar(require_TheseT());
    exports.left = TT.left(T.Pointed);
    exports.right = TT.right(T.Pointed);
    exports.both = TT.both(T.Pointed);
    exports.rightTask = TT.rightF(T.Functor);
    exports.leftTask = TT.leftF(T.Functor);
    exports.rightIO = (0, function_1.flow)(T.fromIO, exports.rightTask);
    exports.leftIO = (0, function_1.flow)(T.fromIO, exports.leftTask);
    exports.fromEither = T.of;
    exports.fromThese = T.of;
    exports.fromIO = exports.rightIO;
    exports.fromIOEither = T.fromIO;
    exports.fromTask = exports.rightTask;
    exports.match = TT.match(T.Functor);
    exports.matchW = exports.match;
    exports.matchE = TT.matchE(T.Monad);
    exports.fold = exports.matchE;
    exports.matchEW = exports.fold;
    exports.foldW = exports.matchEW;
    exports.swap = TT.swap(T.Functor);
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _bimap = function(fa, f2, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f2, g));
    };
    var _mapLeft = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f2));
    };
    exports.map = TT.map(T.Functor);
    exports.bimap = /* @__PURE__ */ TT.bimap(T.Functor);
    exports.mapLeft = TT.mapLeft(T.Functor);
    exports.of = exports.right;
    exports.URI = "TaskThese";
    var getApply = function(A, S) {
      var ap = TT.ap(A, S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, function_1.pipe)(fab, ap(fa));
        }
      };
    };
    exports.getApply = getApply;
    function getApplicative(A, S) {
      var ap = (0, exports.getApply)(A, S).ap;
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap,
        of: exports.of
      };
    }
    exports.getApplicative = getApplicative;
    function getChain(S) {
      var A = (0, exports.getApply)(T.ApplicativePar, S);
      var chain = TT.chain(T.Monad, S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        chain: function(ma, f2) {
          return (0, function_1.pipe)(ma, chain(f2));
        }
      };
    }
    exports.getChain = getChain;
    function getMonad(S) {
      var A = getApplicative(T.ApplicativePar, S);
      var C = getChain(S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        of: exports.of,
        chain: C.chain,
        fromIO: exports.fromIO,
        fromTask: exports.fromTask
      };
    }
    exports.getMonad = getMonad;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: exports.fromEither
    };
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.FromThese = {
      URI: exports.URI,
      fromThese: exports.fromThese
    };
    exports.fromTheseK = (0, FromThese_1.fromTheseK)(exports.FromThese);
    exports.FromIO = {
      URI: exports.URI,
      fromIO: exports.fromIO
    };
    exports.fromIOK = (0, FromIO_1.fromIOK)(exports.FromIO);
    exports.FromTask = {
      URI: exports.URI,
      fromIO: exports.fromIO,
      fromTask: exports.fromTask
    };
    exports.fromTaskK = (0, FromTask_1.fromTaskK)(exports.FromTask);
    exports.toTuple2 = /* @__PURE__ */ TT.toTuple2(T.Functor);
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(S) {
      var g = TH.traverseReadonlyNonEmptyArrayWithIndex(S);
      return function(f2) {
        return (0, function_1.flow)(T.traverseReadonlyNonEmptyArrayWithIndex(f2), T.map(g(function_1.SK)));
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(S) {
      return function(f2) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(S)(f2);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function(S) {
      return function(f2) {
        return function(as) {
          return function() {
            return _.tail(as).reduce(function(acc, a, i) {
              return acc.then(function(ebs) {
                return TH.isLeft(ebs) ? acc : f2(i + 1, a)().then(function(eb) {
                  if (TH.isLeft(eb)) {
                    return eb;
                  }
                  if (TH.isBoth(eb)) {
                    var right_1 = ebs.right;
                    right_1.push(eb.right);
                    return TH.isBoth(ebs) ? TH.both(S.concat(ebs.left, eb.left), right_1) : TH.both(eb.left, right_1);
                  }
                  ebs.right.push(eb.right);
                  return ebs;
                });
              });
            }, f2(0, _.head(as))().then(TH.map(_.singleton)));
          };
        };
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndexSeq = traverseReadonlyNonEmptyArrayWithIndexSeq;
    var traverseReadonlyArrayWithIndexSeq = function(S) {
      return function(f2) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndexSeq)(S)(f2);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
    };
    exports.traverseReadonlyArrayWithIndexSeq = traverseReadonlyArrayWithIndexSeq;
    exports.functorTaskThese = {
      URI: exports.URI,
      map: _map2
    };
    exports.bifunctorTaskThese = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    var toTuple = function(e, a) {
      return (0, exports.toTuple2)(function() {
        return e;
      }, function() {
        return a;
      });
    };
    exports.toTuple = toTuple;
    exports.taskThese = {
      URI: exports.URI,
      map: _map2,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    var getSemigroup = function(SE, SA) {
      return (0, Apply_1.getApplySemigroup)(T.ApplySeq)(TH.getSemigroup(SE, SA));
    };
    exports.getSemigroup = getSemigroup;
  }
});

// node_modules/fp-ts/lib/Traced.js
var require_Traced = __commonJS({
  "node_modules/fp-ts/lib/Traced.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.traced = exports.flap = exports.Functor = exports.URI = exports.map = exports.getComonad = exports.censor = exports.listens = exports.listen = exports.tracks = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function tracks(M, f2) {
      return function(wa) {
        return wa(f2(wa(M.empty)));
      };
    }
    exports.tracks = tracks;
    function listen(wa) {
      return function(e) {
        return [wa(e), e];
      };
    }
    exports.listen = listen;
    function listens(f2) {
      return function(wa) {
        return function(e) {
          return [wa(e), f2(e)];
        };
      };
    }
    exports.listens = listens;
    function censor(f2) {
      return function(wa) {
        return function(e) {
          return wa(f2(e));
        };
      };
    }
    exports.censor = censor;
    function getComonad(monoid) {
      function extend(wa, f2) {
        return function(p1) {
          return f2(function(p2) {
            return wa(monoid.concat(p1, p2));
          });
        };
      }
      function extract(wa) {
        return wa(monoid.empty);
      }
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        extend,
        extract
      };
    }
    exports.getComonad = getComonad;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var map = function(f2) {
      return function(fa) {
        return function(p) {
          return f2(fa(p));
        };
      };
    };
    exports.map = map;
    exports.URI = "Traced";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.traced = exports.Functor;
  }
});

// node_modules/fp-ts/lib/Traversable.js
var require_Traversable = __commonJS({
  "node_modules/fp-ts/lib/Traversable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTraversableComposition = exports.sequence = exports.traverse = void 0;
    var Foldable_1 = require_Foldable();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function traverse(T, G) {
      return function(F) {
        var traverseT = T.traverse(F);
        var traverseG = G.traverse(F);
        return function(f2) {
          return function(fga) {
            return traverseT(fga, function(ga) {
              return traverseG(ga, f2);
            });
          };
        };
      };
    }
    exports.traverse = traverse;
    function sequence(T, G) {
      return function(F) {
        var sequenceT = T.sequence(F);
        var sequenceG = G.sequence(F);
        return function(fgha) {
          return sequenceT(T.map(fgha, sequenceG));
        };
      };
    }
    exports.sequence = sequence;
    function getTraversableComposition(F, G) {
      var map = (0, Functor_1.getFunctorComposition)(F, G).map;
      var FC = (0, Foldable_1.getFoldableComposition)(F, G);
      var _traverse = traverse(F, G);
      var _sequence = sequence(F, G);
      return {
        map,
        reduce: FC.reduce,
        foldMap: FC.foldMap,
        reduceRight: FC.reduceRight,
        traverse: function(H) {
          var traverseH = _traverse(H);
          return function(fga, f2) {
            return (0, function_1.pipe)(fga, traverseH(f2));
          };
        },
        sequence: function(H) {
          var sequenceH = _sequence(H);
          return function(fgha) {
            return (0, function_1.pipe)(fgha, sequenceH);
          };
        }
      };
    }
    exports.getTraversableComposition = getTraversableComposition;
  }
});

// node_modules/fp-ts/lib/TraversableWithIndex.js
var require_TraversableWithIndex = __commonJS({
  "node_modules/fp-ts/lib/TraversableWithIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/Tree.js
var require_Tree = __commonJS({
  "node_modules/fp-ts/lib/Tree.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tree = exports.chain = exports.exists = exports.elem = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Traversable = exports.Foldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.of = exports.sequence = exports.traverse = exports.extract = exports.reduceRight = exports.foldMap = exports.reduce = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.flatMap = exports.ap = exports.fold = exports.unfoldForestM = exports.unfoldTreeM = exports.unfoldForest = exports.unfoldTree = exports.drawTree = exports.drawForest = exports.getEq = exports.getShow = exports.make = void 0;
    var Apply_1 = require_Apply();
    var A = __importStar(require_Array());
    var Chain_1 = require_Chain();
    var Eq_1 = require_Eq();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    function make(value, forest) {
      if (forest === void 0) {
        forest = [];
      }
      return {
        value,
        forest
      };
    }
    exports.make = make;
    function getShow(S) {
      var show = function(t3) {
        return A.isEmpty(t3.forest) ? "make(".concat(S.show(t3.value), ")") : "make(".concat(S.show(t3.value), ", [").concat(t3.forest.map(show).join(", "), "])");
      };
      return {
        show
      };
    }
    exports.getShow = getShow;
    function getEq(E) {
      var SA;
      var R = (0, Eq_1.fromEquals)(function(x, y) {
        return E.equals(x.value, y.value) && SA.equals(x.forest, y.forest);
      });
      SA = A.getEq(R);
      return R;
    }
    exports.getEq = getEq;
    var draw = function(indentation, forest) {
      var r = "";
      var len = forest.length;
      var tree;
      for (var i = 0; i < len; i++) {
        tree = forest[i];
        var isLast = i === len - 1;
        r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
        r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
      }
      return r;
    };
    function drawForest(forest) {
      return draw("\n", forest);
    }
    exports.drawForest = drawForest;
    function drawTree(tree) {
      return tree.value + drawForest(tree.forest);
    }
    exports.drawTree = drawTree;
    function unfoldTree(b, f2) {
      var _a2 = f2(b), a = _a2[0], bs = _a2[1];
      return { value: a, forest: unfoldForest(bs, f2) };
    }
    exports.unfoldTree = unfoldTree;
    function unfoldForest(bs, f2) {
      return bs.map(function(b) {
        return unfoldTree(b, f2);
      });
    }
    exports.unfoldForest = unfoldForest;
    function unfoldTreeM(M) {
      var unfoldForestMM = unfoldForestM(M);
      return function(b, f2) {
        return M.chain(f2(b), function(_a2) {
          var a = _a2[0], bs = _a2[1];
          return M.map(unfoldForestMM(bs, f2), function(ts) {
            return { value: a, forest: ts };
          });
        });
      };
    }
    exports.unfoldTreeM = unfoldTreeM;
    function unfoldForestM(M) {
      var traverseM = A.traverse(M);
      return function(bs, f2) {
        return (0, function_1.pipe)(bs, traverseM(function(b) {
          return unfoldTreeM(M)(b, f2);
        }));
      };
    }
    exports.unfoldForestM = unfoldForestM;
    function fold(f2) {
      var go = function(tree) {
        return f2(tree.value, tree.forest.map(go));
      };
      return go;
    }
    exports.fold = fold;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var _ap = function(fab, fa) {
      return (0, exports.flatMap)(fab, function(f2) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f2));
      });
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    };
    var ap = function(fa) {
      return function(fab) {
        return _ap(fab, fa);
      };
    };
    exports.ap = ap;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f2) {
      var _a2 = f2(ma.value), value = _a2.value, forest = _a2.forest;
      var concat = A.getMonoid().concat;
      return {
        value,
        forest: concat(forest, ma.forest.map((0, exports.flatMap)(f2)))
      };
    });
    var extend = function(f2) {
      return function(wa) {
        return {
          value: f2(wa),
          forest: wa.forest.map((0, exports.extend)(f2))
        };
      };
    };
    exports.extend = extend;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.flatten = (0, exports.flatMap)(function_1.identity);
    var map = function(f2) {
      return function(fa) {
        return {
          value: f2(fa.value),
          forest: fa.forest.map((0, exports.map)(f2))
        };
      };
    };
    exports.map = map;
    var reduce = function(b, f2) {
      return function(fa) {
        var r = f2(b, fa.value);
        var len = fa.forest.length;
        for (var i = 0; i < len; i++) {
          r = (0, function_1.pipe)(fa.forest[i], (0, exports.reduce)(r, f2));
        }
        return r;
      };
    };
    exports.reduce = reduce;
    var foldMap = function(M) {
      return function(f2) {
        return (0, exports.reduce)(M.empty, function(acc, a) {
          return M.concat(acc, f2(a));
        });
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f2) {
      return function(fa) {
        var r = b;
        var len = fa.forest.length;
        for (var i = len - 1; i >= 0; i--) {
          r = (0, function_1.pipe)(fa.forest[i], (0, exports.reduceRight)(r, f2));
        }
        return f2(fa.value, r);
      };
    };
    exports.reduceRight = reduceRight;
    var extract = function(wa) {
      return wa.value;
    };
    exports.extract = extract;
    var traverse = function(F) {
      var traverseF = A.traverse(F);
      var out = function(f2) {
        return function(ta) {
          return F.ap(F.map(f2(ta.value), function(value) {
            return function(forest) {
              return {
                value,
                forest
              };
            };
          }), (0, function_1.pipe)(ta.forest, traverseF(out(f2))));
        };
      };
      return out;
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return (0, exports.traverse)(F)(function_1.identity);
    };
    exports.sequence = sequence;
    var of = function(a) {
      return make(a);
    };
    exports.of = of;
    exports.URI = "Tree";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap
    };
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap,
      of: exports.of,
      chain: exports.flatMap
    };
    exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.Comonad = {
      URI: exports.URI,
      map: _map2,
      extend: _extend,
      extract: exports.extract
    };
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_;
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    function elem(E) {
      var go = function(a, fa) {
        return E.equals(a, fa.value) || fa.forest.some(function(tree) {
          return go(a, tree);
        });
      };
      return go;
    }
    exports.elem = elem;
    var exists = function(predicate) {
      return function(ma) {
        return predicate(ma.value) || ma.forest.some((0, exports.exists)(predicate));
      };
    };
    exports.exists = exists;
    exports.chain = exports.flatMap;
    exports.tree = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap,
      chain: exports.flatMap,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      extract: exports.extract,
      extend: _extend
    };
  }
});

// node_modules/fp-ts/lib/Tuple.js
var require_Tuple = __commonJS({
  "node_modules/fp-ts/lib/Tuple.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tuple = exports.mapLeft = exports.map = exports.Traversable = exports.Foldable = exports.Comonad = exports.Semigroupoid = exports.Bifunctor = exports.flap = exports.Functor = exports.URI = exports.sequence = exports.traverse = exports.reduceRight = exports.reduce = exports.foldMap = exports.extract = exports.duplicate = exports.extend = exports.compose = exports.mapSnd = exports.mapFst = exports.bimap = exports.getChainRec = exports.getMonad = exports.getChain = exports.getApplicative = exports.getApply = exports.swap = exports.snd = exports.fst = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var RT = __importStar(require_ReadonlyTuple());
    exports.fst = RT.fst;
    exports.snd = RT.snd;
    var swap = function(ea) {
      return [(0, exports.snd)(ea), (0, exports.fst)(ea)];
    };
    exports.swap = swap;
    function getApply(S) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return [(0, exports.fst)(fab)((0, exports.fst)(fa)), S.concat((0, exports.snd)(fab), (0, exports.snd)(fa))];
        }
      };
    }
    exports.getApply = getApply;
    var of = function(M) {
      return function(a) {
        return [a, M.empty];
      };
    };
    function getApplicative(M) {
      var A = getApply(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: A.map,
        ap: A.ap,
        of: of(M)
      };
    }
    exports.getApplicative = getApplicative;
    function getChain(S) {
      var A = getApply(S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: A.map,
        ap: A.ap,
        chain: function(ma, f2) {
          var _a2 = f2((0, exports.fst)(ma)), b = _a2[0], s = _a2[1];
          return [b, S.concat((0, exports.snd)(ma), s)];
        }
      };
    }
    exports.getChain = getChain;
    function getMonad(M) {
      var C = getChain(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: C.map,
        ap: C.ap,
        chain: C.chain,
        of: of(M)
      };
    }
    exports.getMonad = getMonad;
    function getChainRec(M) {
      var chainRec = function(a, f2) {
        var result = f2(a);
        var acc = M.empty;
        var s = (0, exports.fst)(result);
        while (s._tag === "Left") {
          acc = M.concat(acc, (0, exports.snd)(result));
          result = f2(s.left);
          s = (0, exports.fst)(result);
        }
        return [s.right, M.concat(acc, (0, exports.snd)(result))];
      };
      var C = getChain(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: C.map,
        ap: C.ap,
        chain: C.chain,
        chainRec
      };
    }
    exports.getChainRec = getChainRec;
    var _compose = function(bc, ab) {
      return (0, function_1.pipe)(bc, (0, exports.compose)(ab));
    };
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapFst)(f2));
    };
    var _bimap = function(fa, f2, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f2, g));
    };
    var _mapLeft = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.mapSnd)(f2));
    };
    var _extend = function(wa, f2) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f2));
    };
    var _reduce = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f2));
    };
    var _foldMap = function(M) {
      var foldMapM = (0, exports.foldMap)(M);
      return function(fa, f2) {
        return (0, function_1.pipe)(fa, foldMapM(f2));
      };
    };
    var _reduceRight = function(fa, b, f2) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f2));
    };
    function _traverse(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f2) {
        return (0, function_1.pipe)(ta, traverseF(f2));
      };
    }
    var bimap = function(f2, g) {
      return function(fa) {
        return [g((0, exports.fst)(fa)), f2((0, exports.snd)(fa))];
      };
    };
    exports.bimap = bimap;
    var mapFst = function(f2) {
      return function(fa) {
        return [f2((0, exports.fst)(fa)), (0, exports.snd)(fa)];
      };
    };
    exports.mapFst = mapFst;
    var mapSnd = function(f2) {
      return function(fa) {
        return [(0, exports.fst)(fa), f2((0, exports.snd)(fa))];
      };
    };
    exports.mapSnd = mapSnd;
    var compose2 = function(ab) {
      return function(bc) {
        return [(0, exports.fst)(bc), (0, exports.snd)(ab)];
      };
    };
    exports.compose = compose2;
    var extend = function(f2) {
      return function(wa) {
        return [f2(wa), (0, exports.snd)(wa)];
      };
    };
    exports.extend = extend;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.extract = RT.extract;
    exports.foldMap = RT.foldMap;
    exports.reduce = RT.reduce;
    exports.reduceRight = RT.reduceRight;
    var traverse = function(F) {
      return function(f2) {
        return function(ta) {
          return F.map(f2((0, exports.fst)(ta)), function(b) {
            return [b, (0, exports.snd)(ta)];
          });
        };
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(fas) {
        return F.map((0, exports.fst)(fas), function(a) {
          return [a, (0, exports.snd)(fas)];
        });
      };
    };
    exports.sequence = sequence;
    exports.URI = "Tuple";
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    exports.Semigroupoid = {
      URI: exports.URI,
      compose: _compose
    };
    exports.Comonad = {
      URI: exports.URI,
      map: _map2,
      extend: _extend,
      extract: exports.extract
    };
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    exports.map = exports.mapFst;
    exports.mapLeft = exports.mapSnd;
    exports.tuple = {
      URI: exports.URI,
      compose: _compose,
      map: _map2,
      bimap: _bimap,
      mapLeft: _mapLeft,
      extract: exports.extract,
      extend: _extend,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
  }
});

// node_modules/fp-ts/lib/Unfoldable.js
var require_Unfoldable = __commonJS({
  "node_modules/fp-ts/lib/Unfoldable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fp-ts/lib/ValidationT.js
var require_ValidationT = __commonJS({
  "node_modules/fp-ts/lib/ValidationT.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getValidationM = void 0;
    var Applicative_1 = require_Applicative();
    var E = __importStar(require_Either());
    var _ = __importStar(require_internal());
    function getValidationM(S, M) {
      var A = (0, Applicative_1.getApplicativeComposition)(M, E.getApplicativeValidation(S));
      return {
        map: A.map,
        ap: A.ap,
        of: A.of,
        chain: function(ma, f2) {
          return M.chain(ma, function(e) {
            return _.isLeft(e) ? M.of(_.left(e.left)) : f2(e.right);
          });
        },
        alt: function(me, that) {
          return M.chain(me, function(e1) {
            return _.isRight(e1) ? M.of(e1) : M.map(that(), function(e2) {
              return _.isLeft(e2) ? _.left(S.concat(e1.left, e2.left)) : e2;
            });
          });
        }
      };
    }
    exports.getValidationM = getValidationM;
  }
});

// node_modules/fp-ts/lib/void.js
var require_void = __commonJS({
  "node_modules/fp-ts/lib/void.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Monoid = exports.Semigroup = void 0;
    var Se = __importStar(require_Semigroup());
    exports.Semigroup = Se.constant(void 0);
    exports.Monoid = {
      concat: exports.Semigroup.concat,
      empty: void 0
    };
  }
});

// node_modules/fp-ts/lib/Writer.js
var require_Writer = __commonJS({
  "node_modules/fp-ts/lib/Writer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writer = exports.execWriter = exports.evalWriter = exports.execute = exports.evaluate = exports.flap = exports.Functor = exports.getMonad = exports.getChain = exports.getApplicative = exports.getApply = exports.getPointed = exports.URI = exports.map = exports.censor = exports.listens = exports.pass = exports.listen = exports.tell = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var tell = function(w) {
      return function() {
        return [void 0, w];
      };
    };
    exports.tell = tell;
    var listen = function(fa) {
      return function() {
        var _a2 = fa(), a = _a2[0], w = _a2[1];
        return [[a, w], w];
      };
    };
    exports.listen = listen;
    var pass = function(fa) {
      return function() {
        var _a2 = fa(), _b = _a2[0], a = _b[0], f2 = _b[1], w = _a2[1];
        return [a, f2(w)];
      };
    };
    exports.pass = pass;
    var listens = function(f2) {
      return function(fa) {
        return function() {
          var _a2 = fa(), a = _a2[0], w = _a2[1];
          return [[a, f2(w)], w];
        };
      };
    };
    exports.listens = listens;
    var censor = function(f2) {
      return function(fa) {
        return function() {
          var _a2 = fa(), a = _a2[0], w = _a2[1];
          return [a, f2(w)];
        };
      };
    };
    exports.censor = censor;
    var _map2 = function(fa, f2) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f2));
    };
    var map = function(f2) {
      return function(fa) {
        return function() {
          var _a2 = fa(), a = _a2[0], w = _a2[1];
          return [f2(a), w];
        };
      };
    };
    exports.map = map;
    exports.URI = "Writer";
    var getPointed = function(M) {
      return {
        URI: exports.URI,
        _E: void 0,
        of: function(a) {
          return function() {
            return [a, M.empty];
          };
        }
      };
    };
    exports.getPointed = getPointed;
    var getApply = function(S) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return function() {
            var _a2 = fab(), f2 = _a2[0], w1 = _a2[1];
            var _b = fa(), a = _b[0], w2 = _b[1];
            return [f2(a), S.concat(w1, w2)];
          };
        }
      };
    };
    exports.getApply = getApply;
    var getApplicative = function(M) {
      var A = (0, exports.getApply)(M);
      var P = (0, exports.getPointed)(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        of: P.of
      };
    };
    exports.getApplicative = getApplicative;
    function getChain(S) {
      var A = (0, exports.getApply)(S);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        chain: function(fa, f2) {
          return function() {
            var _a2 = fa(), a = _a2[0], w1 = _a2[1];
            var _b = f2(a)(), b = _b[0], w2 = _b[1];
            return [b, S.concat(w1, w2)];
          };
        }
      };
    }
    exports.getChain = getChain;
    function getMonad(M) {
      var A = (0, exports.getApplicative)(M);
      var C = getChain(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: A.ap,
        of: A.of,
        chain: C.chain
      };
    }
    exports.getMonad = getMonad;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    var evaluate = function(fa) {
      return fa()[0];
    };
    exports.evaluate = evaluate;
    var execute = function(fa) {
      return fa()[1];
    };
    exports.execute = execute;
    var evalWriter = function(fa) {
      return fa()[0];
    };
    exports.evalWriter = evalWriter;
    var execWriter = function(fa) {
      return fa()[1];
    };
    exports.execWriter = execWriter;
    exports.writer = exports.Functor;
  }
});

// node_modules/fp-ts/lib/WriterT.js
var require_WriterT = __commonJS({
  "node_modules/fp-ts/lib/WriterT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWriterM = void 0;
    function getWriterM(M) {
      var map = function(fa, f2) {
        return function() {
          return M.map(fa(), function(_a2) {
            var a = _a2[0], w = _a2[1];
            return [f2(a), w];
          });
        };
      };
      return {
        map,
        evalWriter: function(fa) {
          return M.map(fa(), function(_a2) {
            var a = _a2[0];
            return a;
          });
        },
        execWriter: function(fa) {
          return M.map(fa(), function(_a2) {
            var _ = _a2[0], w = _a2[1];
            return w;
          });
        },
        tell: function(w) {
          return function() {
            return M.of([void 0, w]);
          };
        },
        listen: function(fa) {
          return function() {
            return M.map(fa(), function(_a2) {
              var a = _a2[0], w = _a2[1];
              return [[a, w], w];
            });
          };
        },
        pass: function(fa) {
          return function() {
            return M.map(fa(), function(_a2) {
              var _b = _a2[0], a = _b[0], f2 = _b[1], w = _a2[1];
              return [a, f2(w)];
            });
          };
        },
        listens: function(fa, f2) {
          return function() {
            return M.map(fa(), function(_a2) {
              var a = _a2[0], w = _a2[1];
              return [[a, f2(w)], w];
            });
          };
        },
        censor: function(fa, f2) {
          return function() {
            return M.map(fa(), function(_a2) {
              var a = _a2[0], w = _a2[1];
              return [a, f2(w)];
            });
          };
        },
        getMonad: function(W) {
          return {
            _E: void 0,
            map,
            of: function(a) {
              return function() {
                return M.of([a, W.empty]);
              };
            },
            ap: function(mab, ma) {
              return function() {
                return M.chain(mab(), function(_a2) {
                  var f2 = _a2[0], w1 = _a2[1];
                  return M.map(ma(), function(_a3) {
                    var a = _a3[0], w2 = _a3[1];
                    return [f2(a), W.concat(w1, w2)];
                  });
                });
              };
            },
            chain: function(ma, f2) {
              return function() {
                return M.chain(ma(), function(_a2) {
                  var a = _a2[0], w1 = _a2[1];
                  return M.map(f2(a)(), function(_a3) {
                    var b = _a3[0], w2 = _a3[1];
                    return [b, W.concat(w1, w2)];
                  });
                });
              };
            }
          };
        }
      };
    }
    exports.getWriterM = getWriterM;
  }
});

// node_modules/fp-ts/lib/index.js
var require_lib = __commonJS({
  "node_modules/fp-ts/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ioOption = exports.ioEither = exports.io = exports.invariant = exports.identity = exports.hkt = exports.heytingAlgebra = exports.group = exports.functorWithIndex = exports.functor = exports.function = exports.fromThese = exports.fromTask = exports.fromState = exports.fromReader = exports.fromIO = exports.fromEither = exports.foldableWithIndex = exports.foldable = exports.filterableWithIndex = exports.filterable = exports.field = exports.extend = exports.endomorphism = exports.eitherT = exports.either = exports.distributiveLattice = exports.date = exports.contravariant = exports.const = exports.console = exports.compactable = exports.comonad = exports.choice = exports.chainRec = exports.chain = exports.category = exports.boundedMeetSemilattice = exports.boundedLattice = exports.boundedJoinSemilattice = exports.boundedDistributiveLattice = exports.bounded = exports.booleanAlgebra = exports.boolean = exports.bifunctor = exports.array = exports.apply = exports.applicative = exports.alternative = exports.alt = void 0;
    exports.store = exports.stateT = exports.stateReaderTaskEither = exports.state = exports.show = exports.eq = exports.set = exports.separated = exports.semiring = exports.semigroupoid = exports.semigroup = exports.ring = exports.refinement = exports.record = exports.readerTask = exports.readonlyTuple = exports.readonlySet = exports.readonlyRecord = exports.readonlyNonEmptyArray = exports.readonlyMap = exports.readonlyArray = exports.readerTaskEither = exports.readerT = exports.readerIO = exports.readerEither = exports.reader = exports.random = exports.profunctor = exports.predicate = exports.pointed = exports.pipeable = exports.ordering = exports.ord = exports.optionT = exports.option = exports.number = exports.nonEmptyArray = exports.naturalTransformation = exports.monoid = exports.monadThrow = exports.monadTask = exports.monadIO = exports.monad = exports.meetSemilattice = exports.map = exports.magma = exports.lattice = exports.json = exports.joinSemilattice = exports.ioRef = void 0;
    exports.zero = exports.writerT = exports.writer = exports.witherable = exports.void = exports.validationT = exports.unfoldable = exports.tuple = exports.tree = exports.traversableWithIndex = exports.traversable = exports.traced = exports.theseT = exports.these = exports.taskThese = exports.taskOption = exports.taskEither = exports.task = exports.struct = exports.strong = exports.string = void 0;
    var alt = __importStar(require_Alt());
    exports.alt = alt;
    var alternative = __importStar(require_Alternative());
    exports.alternative = alternative;
    var applicative = __importStar(require_Applicative());
    exports.applicative = applicative;
    var apply = __importStar(require_Apply());
    exports.apply = apply;
    var array2 = __importStar(require_Array());
    exports.array = array2;
    var bifunctor = __importStar(require_Bifunctor());
    exports.bifunctor = bifunctor;
    var boolean = __importStar(require_boolean());
    exports.boolean = boolean;
    var booleanAlgebra = __importStar(require_BooleanAlgebra());
    exports.booleanAlgebra = booleanAlgebra;
    var bounded = __importStar(require_Bounded());
    exports.bounded = bounded;
    var boundedDistributiveLattice = __importStar(require_BoundedDistributiveLattice());
    exports.boundedDistributiveLattice = boundedDistributiveLattice;
    var boundedJoinSemilattice = __importStar(require_BoundedJoinSemilattice());
    exports.boundedJoinSemilattice = boundedJoinSemilattice;
    var boundedLattice = __importStar(require_BoundedLattice());
    exports.boundedLattice = boundedLattice;
    var boundedMeetSemilattice = __importStar(require_BoundedMeetSemilattice());
    exports.boundedMeetSemilattice = boundedMeetSemilattice;
    var category = __importStar(require_Category());
    exports.category = category;
    var chain = __importStar(require_Chain());
    exports.chain = chain;
    var chainRec = __importStar(require_ChainRec());
    exports.chainRec = chainRec;
    var choice = __importStar(require_Choice());
    exports.choice = choice;
    var comonad = __importStar(require_Comonad());
    exports.comonad = comonad;
    var compactable = __importStar(require_Compactable());
    exports.compactable = compactable;
    var console2 = __importStar(require_Console());
    exports.console = console2;
    var const_ = __importStar(require_Const());
    exports.const = const_;
    var contravariant = __importStar(require_Contravariant());
    exports.contravariant = contravariant;
    var date = __importStar(require_Date());
    exports.date = date;
    var distributiveLattice = __importStar(require_DistributiveLattice());
    exports.distributiveLattice = distributiveLattice;
    var either = __importStar(require_Either());
    exports.either = either;
    var eitherT = __importStar(require_EitherT());
    exports.eitherT = eitherT;
    var endomorphism = __importStar(require_Endomorphism());
    exports.endomorphism = endomorphism;
    var eq = __importStar(require_Eq());
    exports.eq = eq;
    var extend = __importStar(require_Extend());
    exports.extend = extend;
    var field = __importStar(require_Field());
    exports.field = field;
    var filterable = __importStar(require_Filterable());
    exports.filterable = filterable;
    var filterableWithIndex = __importStar(require_FilterableWithIndex());
    exports.filterableWithIndex = filterableWithIndex;
    var foldable = __importStar(require_Foldable());
    exports.foldable = foldable;
    var foldableWithIndex = __importStar(require_FoldableWithIndex());
    exports.foldableWithIndex = foldableWithIndex;
    var fromEither = __importStar(require_FromEither());
    exports.fromEither = fromEither;
    var fromIO = __importStar(require_FromIO());
    exports.fromIO = fromIO;
    var fromReader = __importStar(require_FromReader());
    exports.fromReader = fromReader;
    var fromState = __importStar(require_FromState());
    exports.fromState = fromState;
    var fromTask = __importStar(require_FromTask());
    exports.fromTask = fromTask;
    var fromThese = __importStar(require_FromThese());
    exports.fromThese = fromThese;
    var function_ = __importStar(require_function());
    exports.function = function_;
    var functor = __importStar(require_Functor());
    exports.functor = functor;
    var functorWithIndex = __importStar(require_FunctorWithIndex());
    exports.functorWithIndex = functorWithIndex;
    var group = __importStar(require_Group());
    exports.group = group;
    var heytingAlgebra = __importStar(require_HeytingAlgebra());
    exports.heytingAlgebra = heytingAlgebra;
    var hkt = __importStar(require_HKT());
    exports.hkt = hkt;
    var identity = __importStar(require_Identity());
    exports.identity = identity;
    var invariant = __importStar(require_Invariant());
    exports.invariant = invariant;
    var io = __importStar(require_IO());
    exports.io = io;
    var ioEither = __importStar(require_IOEither());
    exports.ioEither = ioEither;
    var ioOption = __importStar(require_IOOption());
    exports.ioOption = ioOption;
    var ioRef = __importStar(require_IORef());
    exports.ioRef = ioRef;
    var joinSemilattice = __importStar(require_JoinSemilattice());
    exports.joinSemilattice = joinSemilattice;
    var json = __importStar(require_Json());
    exports.json = json;
    var lattice = __importStar(require_Lattice());
    exports.lattice = lattice;
    var magma = __importStar(require_Magma());
    exports.magma = magma;
    var map = __importStar(require_Map());
    exports.map = map;
    var meetSemilattice = __importStar(require_MeetSemilattice());
    exports.meetSemilattice = meetSemilattice;
    var monad = __importStar(require_Monad());
    exports.monad = monad;
    var monadIO = __importStar(require_MonadIO());
    exports.monadIO = monadIO;
    var monadTask = __importStar(require_MonadTask());
    exports.monadTask = monadTask;
    var monadThrow = __importStar(require_MonadThrow());
    exports.monadThrow = monadThrow;
    var monoid = __importStar(require_Monoid());
    exports.monoid = monoid;
    var naturalTransformation = __importStar(require_NaturalTransformation());
    exports.naturalTransformation = naturalTransformation;
    var nonEmptyArray = __importStar(require_NonEmptyArray());
    exports.nonEmptyArray = nonEmptyArray;
    var number2 = __importStar(require_number());
    exports.number = number2;
    var option = __importStar(require_Option());
    exports.option = option;
    var optionT = __importStar(require_OptionT());
    exports.optionT = optionT;
    var ord = __importStar(require_Ord());
    exports.ord = ord;
    var ordering = __importStar(require_Ordering());
    exports.ordering = ordering;
    var pipeable = __importStar(require_pipeable());
    exports.pipeable = pipeable;
    var pointed = __importStar(require_Pointed());
    exports.pointed = pointed;
    var predicate = __importStar(require_Predicate());
    exports.predicate = predicate;
    var profunctor = __importStar(require_Profunctor());
    exports.profunctor = profunctor;
    var random = __importStar(require_Random());
    exports.random = random;
    var reader = __importStar(require_Reader());
    exports.reader = reader;
    var readerEither = __importStar(require_ReaderEither());
    exports.readerEither = readerEither;
    var readerIO = __importStar(require_ReaderIO());
    exports.readerIO = readerIO;
    var readerT = __importStar(require_ReaderT());
    exports.readerT = readerT;
    var readerTask = __importStar(require_ReaderTask());
    exports.readerTask = readerTask;
    var readerTaskEither = __importStar(require_ReaderTaskEither());
    exports.readerTaskEither = readerTaskEither;
    var readonlyArray = __importStar(require_ReadonlyArray());
    exports.readonlyArray = readonlyArray;
    var readonlyMap = __importStar(require_ReadonlyMap());
    exports.readonlyMap = readonlyMap;
    var readonlyNonEmptyArray = __importStar(require_ReadonlyNonEmptyArray());
    exports.readonlyNonEmptyArray = readonlyNonEmptyArray;
    var readonlyRecord = __importStar(require_ReadonlyRecord());
    exports.readonlyRecord = readonlyRecord;
    var readonlySet = __importStar(require_ReadonlySet());
    exports.readonlySet = readonlySet;
    var readonlyTuple = __importStar(require_ReadonlyTuple());
    exports.readonlyTuple = readonlyTuple;
    var record = __importStar(require_Record());
    exports.record = record;
    var refinement = __importStar(require_Refinement());
    exports.refinement = refinement;
    var ring = __importStar(require_Ring());
    exports.ring = ring;
    var semigroup = __importStar(require_Semigroup());
    exports.semigroup = semigroup;
    var semigroupoid = __importStar(require_Semigroupoid());
    exports.semigroupoid = semigroupoid;
    var semiring = __importStar(require_Semiring());
    exports.semiring = semiring;
    var separated = __importStar(require_Separated());
    exports.separated = separated;
    var set = __importStar(require_Set());
    exports.set = set;
    var show = __importStar(require_Show());
    exports.show = show;
    var state = __importStar(require_State());
    exports.state = state;
    var stateReaderTaskEither = __importStar(require_StateReaderTaskEither());
    exports.stateReaderTaskEither = stateReaderTaskEither;
    var stateT = __importStar(require_StateT());
    exports.stateT = stateT;
    var store = __importStar(require_Store());
    exports.store = store;
    var string3 = __importStar(require_string());
    exports.string = string3;
    var strong = __importStar(require_Strong());
    exports.strong = strong;
    var struct = __importStar(require_struct());
    exports.struct = struct;
    var task = __importStar(require_Task());
    exports.task = task;
    var taskEither = __importStar(require_TaskEither());
    exports.taskEither = taskEither;
    var taskOption = __importStar(require_TaskOption());
    exports.taskOption = taskOption;
    var taskThese = __importStar(require_TaskThese());
    exports.taskThese = taskThese;
    var these = __importStar(require_These());
    exports.these = these;
    var theseT = __importStar(require_TheseT());
    exports.theseT = theseT;
    var traced = __importStar(require_Traced());
    exports.traced = traced;
    var traversable = __importStar(require_Traversable());
    exports.traversable = traversable;
    var traversableWithIndex = __importStar(require_TraversableWithIndex());
    exports.traversableWithIndex = traversableWithIndex;
    var tree = __importStar(require_Tree());
    exports.tree = tree;
    var tuple = __importStar(require_Tuple());
    exports.tuple = tuple;
    var unfoldable = __importStar(require_Unfoldable());
    exports.unfoldable = unfoldable;
    var validationT = __importStar(require_ValidationT());
    exports.validationT = validationT;
    var void_ = __importStar(require_void());
    exports.void = void_;
    var witherable = __importStar(require_Witherable());
    exports.witherable = witherable;
    var writer = __importStar(require_Writer());
    exports.writer = writer;
    var writerT = __importStar(require_WriterT());
    exports.writerT = writerT;
    var zero = __importStar(require_Zero());
    exports.zero = zero;
  }
});

// node_modules/io-ts/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/io-ts/lib/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t3[p] = s[p];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partial = exports.PartialType = exports.type = exports.InterfaceType = exports.array = exports.ArrayType = exports.recursion = exports.RecursiveType = exports.Int = exports.brand = exports.RefinementType = exports.keyof = exports.KeyofType = exports.literal = exports.LiteralType = exports.void = exports.undefined = exports.null = exports.UnknownRecord = exports.AnyDictionaryType = exports.UnknownArray = exports.AnyArrayType = exports.boolean = exports.BooleanType = exports.bigint = exports.BigIntType = exports.number = exports.NumberType = exports.string = exports.StringType = exports.unknown = exports.UnknownType = exports.voidType = exports.VoidType = exports.UndefinedType = exports.nullType = exports.NullType = exports.getIndex = exports.getTags = exports.emptyTags = exports.mergeAll = exports.getDomainKeys = exports.appendContext = exports.getContextEntry = exports.getFunctionName = exports.identity = exports.Type = exports.success = exports.failure = exports.failures = void 0;
    exports.alias = exports.clean = exports.StrictType = exports.dictionary = exports.object = exports.ObjectType = exports.Dictionary = exports.getDefaultContext = exports.getValidationError = exports.interface = exports.Array = exports.taggedUnion = exports.TaggedUnionType = exports.Integer = exports.refinement = exports.any = exports.AnyType = exports.never = exports.NeverType = exports.Function = exports.FunctionType = exports.exact = exports.ExactType = exports.strict = exports.readonlyArray = exports.ReadonlyArrayType = exports.readonly = exports.ReadonlyType = exports.tuple = exports.TupleType = exports.intersection = exports.IntersectionType = exports.union = exports.UnionType = exports.record = exports.DictionaryType = void 0;
    var Either_1 = require_Either();
    exports.failures = Either_1.left;
    var failure = function(value, context, message) {
      return (0, exports.failures)([{ value, context, message }]);
    };
    exports.failure = failure;
    exports.success = Either_1.right;
    var Type = (
      /** @class */
      function() {
        function Type2(name, is, validate, encode) {
          this.name = name;
          this.is = is;
          this.validate = validate;
          this.encode = encode;
          this.decode = this.decode.bind(this);
        }
        Type2.prototype.pipe = function(ab, name) {
          var _this = this;
          if (name === void 0) {
            name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
          }
          return new Type2(name, ab.is, function(i, c) {
            var e = _this.validate(i, c);
            if ((0, Either_1.isLeft)(e)) {
              return e;
            }
            return ab.validate(e.right, c);
          }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : function(b) {
            return _this.encode(ab.encode(b));
          });
        };
        Type2.prototype.asDecoder = function() {
          return this;
        };
        Type2.prototype.asEncoder = function() {
          return this;
        };
        Type2.prototype.decode = function(i) {
          return this.validate(i, [{ key: "", type: this, actual: i }]);
        };
        return Type2;
      }()
    );
    exports.Type = Type;
    var identity = function(a) {
      return a;
    };
    exports.identity = identity;
    function getFunctionName(f2) {
      return f2.displayName || f2.name || "<function".concat(f2.length, ">");
    }
    exports.getFunctionName = getFunctionName;
    function getContextEntry(key, decoder) {
      return { key, type: decoder };
    }
    exports.getContextEntry = getContextEntry;
    function appendContext(c, key, decoder, actual) {
      var len = c.length;
      var r = Array(len + 1);
      for (var i = 0; i < len; i++) {
        r[i] = c[i];
      }
      r[len] = { key, type: decoder, actual };
      return r;
    }
    exports.appendContext = appendContext;
    function pushAll(xs, ys) {
      var l = ys.length;
      for (var i = 0; i < l; i++) {
        xs.push(ys[i]);
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function getNameFromProps(props) {
      return Object.keys(props).map(function(k) {
        return "".concat(k, ": ").concat(props[k].name);
      }).join(", ");
    }
    function useIdentity(codecs) {
      for (var i = 0; i < codecs.length; i++) {
        if (codecs[i].encode !== exports.identity) {
          return false;
        }
      }
      return true;
    }
    function getInterfaceTypeName(props) {
      return "{ ".concat(getNameFromProps(props), " }");
    }
    function getPartialTypeName(inner) {
      return "Partial<".concat(inner, ">");
    }
    function enumerableRecord(keys4, domain, codomain, name) {
      if (name === void 0) {
        name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
      }
      var len = keys4.length;
      return new DictionaryType(name, function(u) {
        return exports.UnknownRecord.is(u) && keys4.every(function(k) {
          return codomain.is(u[k]);
        });
      }, function(u, c) {
        var e = exports.UnknownRecord.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var o = e.right;
        var a = {};
        var errors = [];
        var changed = false;
        for (var i = 0; i < len; i++) {
          var k = keys4[i];
          var ok = o[k];
          var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
          if ((0, Either_1.isLeft)(codomainResult)) {
            pushAll(errors, codomainResult.left);
          } else {
            var vok = codomainResult.right;
            changed = changed || vok !== ok;
            a[k] = vok;
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed || Object.keys(o).length !== len ? a : o);
      }, codomain.encode === exports.identity ? exports.identity : function(a) {
        var s = {};
        for (var i = 0; i < len; i++) {
          var k = keys4[i];
          s[k] = codomain.encode(a[k]);
        }
        return s;
      }, domain, codomain);
    }
    function getDomainKeys(domain) {
      var _a2;
      if (isLiteralC(domain)) {
        var literal_1 = domain.value;
        if (exports.string.is(literal_1)) {
          return _a2 = {}, _a2[literal_1] = null, _a2;
        }
      } else if (isKeyofC(domain)) {
        return domain.keys;
      } else if (isUnionC(domain)) {
        var keys4 = domain.types.map(function(type4) {
          return getDomainKeys(type4);
        });
        return keys4.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray([{}], keys4, false));
      }
      return void 0;
    }
    exports.getDomainKeys = getDomainKeys;
    function nonEnumerableRecord(domain, codomain, name) {
      if (name === void 0) {
        name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
      }
      return new DictionaryType(name, function(u) {
        if (exports.UnknownRecord.is(u)) {
          return Object.keys(u).every(function(k) {
            return domain.is(k) && codomain.is(u[k]);
          });
        }
        return isAnyC(codomain) && Array.isArray(u);
      }, function(u, c) {
        if (exports.UnknownRecord.is(u)) {
          var a = {};
          var errors = [];
          var keys4 = Object.keys(u);
          var len = keys4.length;
          var changed = false;
          for (var i = 0; i < len; i++) {
            var k = keys4[i];
            var ok = u[k];
            var domainResult = domain.validate(k, appendContext(c, k, domain, k));
            if ((0, Either_1.isLeft)(domainResult)) {
              pushAll(errors, domainResult.left);
            } else {
              var vk = domainResult.right;
              changed = changed || vk !== k;
              k = vk;
              var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
              if ((0, Either_1.isLeft)(codomainResult)) {
                pushAll(errors, codomainResult.left);
              } else {
                var vok = codomainResult.right;
                changed = changed || vok !== ok;
                a[k] = vok;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed ? a : u);
        }
        if (isAnyC(codomain) && Array.isArray(u)) {
          return (0, exports.success)(u);
        }
        return (0, exports.failure)(u, c);
      }, domain.encode === exports.identity && codomain.encode === exports.identity ? exports.identity : function(a) {
        var s = {};
        var keys4 = Object.keys(a);
        var len = keys4.length;
        for (var i = 0; i < len; i++) {
          var k = keys4[i];
          s[String(domain.encode(k))] = codomain.encode(a[k]);
        }
        return s;
      }, domain, codomain);
    }
    function getUnionName(codecs) {
      return "(" + codecs.map(function(type4) {
        return type4.name;
      }).join(" | ") + ")";
    }
    function mergeAll(base, us) {
      var equal = true;
      var primitive = true;
      var baseIsNotADictionary = !exports.UnknownRecord.is(base);
      for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
        var u = us_1[_i];
        if (u !== base) {
          equal = false;
        }
        if (exports.UnknownRecord.is(u)) {
          primitive = false;
        }
      }
      if (equal) {
        return base;
      } else if (primitive) {
        return us[us.length - 1];
      }
      var r = {};
      for (var _a2 = 0, us_2 = us; _a2 < us_2.length; _a2++) {
        var u = us_2[_a2];
        for (var k in u) {
          if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
            r[k] = u[k];
          }
        }
      }
      return r;
    }
    exports.mergeAll = mergeAll;
    function getProps(codec) {
      switch (codec._tag) {
        case "RefinementType":
        case "ReadonlyType":
          return getProps(codec.type);
        case "InterfaceType":
        case "StrictType":
        case "PartialType":
          return codec.props;
        case "IntersectionType":
          return codec.types.reduce(function(props, type4) {
            return Object.assign(props, getProps(type4));
          }, {});
      }
    }
    function stripKeys(o, props) {
      var keys4 = Object.getOwnPropertyNames(o);
      var shouldStrip = false;
      var r = {};
      for (var i = 0; i < keys4.length; i++) {
        var key = keys4[i];
        if (!hasOwnProperty.call(props, key)) {
          shouldStrip = true;
        } else {
          r[key] = o[key];
        }
      }
      return shouldStrip ? r : o;
    }
    function getExactTypeName(codec) {
      if (isTypeC(codec)) {
        return "{| ".concat(getNameFromProps(codec.props), " |}");
      } else if (isPartialC(codec)) {
        return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
      }
      return "Exact<".concat(codec.name, ">");
    }
    function isNonEmpty(as) {
      return as.length > 0;
    }
    exports.emptyTags = {};
    function intersect(a, b) {
      var r = [];
      for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var v = a_1[_i];
        if (b.indexOf(v) !== -1) {
          r.push(v);
        }
      }
      return r;
    }
    function mergeTags(a, b) {
      if (a === exports.emptyTags) {
        return b;
      }
      if (b === exports.emptyTags) {
        return a;
      }
      var r = Object.assign({}, a);
      for (var k in b) {
        if (hasOwnProperty.call(a, k)) {
          var intersection_1 = intersect(a[k], b[k]);
          if (isNonEmpty(intersection_1)) {
            r[k] = intersection_1;
          } else {
            r = exports.emptyTags;
            break;
          }
        } else {
          r[k] = b[k];
        }
      }
      return r;
    }
    function intersectTags(a, b) {
      if (a === exports.emptyTags || b === exports.emptyTags) {
        return exports.emptyTags;
      }
      var r = exports.emptyTags;
      for (var k in a) {
        if (hasOwnProperty.call(b, k)) {
          var intersection_2 = intersect(a[k], b[k]);
          if (intersection_2.length === 0) {
            if (r === exports.emptyTags) {
              r = {};
            }
            r[k] = a[k].concat(b[k]);
          }
        }
      }
      return r;
    }
    function isAnyC(codec) {
      return codec._tag === "AnyType";
    }
    function isLiteralC(codec) {
      return codec._tag === "LiteralType";
    }
    function isKeyofC(codec) {
      return codec._tag === "KeyofType";
    }
    function isTypeC(codec) {
      return codec._tag === "InterfaceType";
    }
    function isPartialC(codec) {
      return codec._tag === "PartialType";
    }
    function isStrictC(codec) {
      return codec._tag === "StrictType";
    }
    function isExactC(codec) {
      return codec._tag === "ExactType";
    }
    function isRefinementC(codec) {
      return codec._tag === "RefinementType";
    }
    function isIntersectionC(codec) {
      return codec._tag === "IntersectionType";
    }
    function isUnionC(codec) {
      return codec._tag === "UnionType";
    }
    function isRecursiveC(codec) {
      return codec._tag === "RecursiveType";
    }
    var lazyCodecs = [];
    function getTags(codec) {
      if (lazyCodecs.indexOf(codec) !== -1) {
        return exports.emptyTags;
      }
      if (isTypeC(codec) || isStrictC(codec)) {
        var index = exports.emptyTags;
        for (var k in codec.props) {
          var prop = codec.props[k];
          if (isLiteralC(prop)) {
            if (index === exports.emptyTags) {
              index = {};
            }
            index[k] = [prop.value];
          }
        }
        return index;
      } else if (isExactC(codec) || isRefinementC(codec)) {
        return getTags(codec.type);
      } else if (isIntersectionC(codec)) {
        return codec.types.reduce(function(tags2, codec2) {
          return mergeTags(tags2, getTags(codec2));
        }, exports.emptyTags);
      } else if (isUnionC(codec)) {
        return codec.types.slice(1).reduce(function(tags2, codec2) {
          return intersectTags(tags2, getTags(codec2));
        }, getTags(codec.types[0]));
      } else if (isRecursiveC(codec)) {
        lazyCodecs.push(codec);
        var tags = getTags(codec.type);
        lazyCodecs.pop();
        return tags;
      }
      return exports.emptyTags;
    }
    exports.getTags = getTags;
    function getIndex(codecs) {
      var tags = getTags(codecs[0]);
      var keys4 = Object.keys(tags);
      var len = codecs.length;
      var _loop_1 = function(k2) {
        var all = tags[k2].slice();
        var index = [tags[k2]];
        for (var i = 1; i < len; i++) {
          var codec = codecs[i];
          var ctags = getTags(codec);
          var values = ctags[k2];
          if (values === void 0) {
            return "continue-keys";
          } else {
            if (values.some(function(v) {
              return all.indexOf(v) !== -1;
            })) {
              return "continue-keys";
            } else {
              all.push.apply(all, values);
              index.push(values);
            }
          }
        }
        return { value: [k2, index] };
      };
      keys:
        for (var _i = 0, keys_1 = keys4; _i < keys_1.length; _i++) {
          var k = keys_1[_i];
          var state_1 = _loop_1(k);
          if (typeof state_1 === "object")
            return state_1.value;
          switch (state_1) {
            case "continue-keys":
              continue keys;
          }
        }
      return void 0;
    }
    exports.getIndex = getIndex;
    var NullType = (
      /** @class */
      function(_super) {
        __extends(NullType2, _super);
        function NullType2() {
          var _this = _super.call(this, "null", function(u) {
            return u === null;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NullType";
          return _this;
        }
        return NullType2;
      }(Type)
    );
    exports.NullType = NullType;
    exports.nullType = new NullType();
    exports.null = exports.nullType;
    var UndefinedType = (
      /** @class */
      function(_super) {
        __extends(UndefinedType2, _super);
        function UndefinedType2() {
          var _this = _super.call(this, "undefined", function(u) {
            return u === void 0;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "UndefinedType";
          return _this;
        }
        return UndefinedType2;
      }(Type)
    );
    exports.UndefinedType = UndefinedType;
    var undefinedType = new UndefinedType();
    exports.undefined = undefinedType;
    var VoidType = (
      /** @class */
      function(_super) {
        __extends(VoidType2, _super);
        function VoidType2() {
          var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, exports.identity) || this;
          _this._tag = "VoidType";
          return _this;
        }
        return VoidType2;
      }(Type)
    );
    exports.VoidType = VoidType;
    exports.voidType = new VoidType();
    exports.void = exports.voidType;
    var UnknownType = (
      /** @class */
      function(_super) {
        __extends(UnknownType2, _super);
        function UnknownType2() {
          var _this = _super.call(this, "unknown", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "UnknownType";
          return _this;
        }
        return UnknownType2;
      }(Type)
    );
    exports.UnknownType = UnknownType;
    exports.unknown = new UnknownType();
    var StringType = (
      /** @class */
      function(_super) {
        __extends(StringType2, _super);
        function StringType2() {
          var _this = _super.call(this, "string", function(u) {
            return typeof u === "string";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "StringType";
          return _this;
        }
        return StringType2;
      }(Type)
    );
    exports.StringType = StringType;
    exports.string = new StringType();
    var NumberType = (
      /** @class */
      function(_super) {
        __extends(NumberType2, _super);
        function NumberType2() {
          var _this = _super.call(this, "number", function(u) {
            return typeof u === "number";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NumberType";
          return _this;
        }
        return NumberType2;
      }(Type)
    );
    exports.NumberType = NumberType;
    exports.number = new NumberType();
    var BigIntType = (
      /** @class */
      function(_super) {
        __extends(BigIntType2, _super);
        function BigIntType2() {
          var _this = _super.call(
            this,
            "bigint",
            // tslint:disable-next-line: valid-typeof
            function(u) {
              return typeof u === "bigint";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "BigIntType";
          return _this;
        }
        return BigIntType2;
      }(Type)
    );
    exports.BigIntType = BigIntType;
    exports.bigint = new BigIntType();
    var BooleanType = (
      /** @class */
      function(_super) {
        __extends(BooleanType2, _super);
        function BooleanType2() {
          var _this = _super.call(this, "boolean", function(u) {
            return typeof u === "boolean";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "BooleanType";
          return _this;
        }
        return BooleanType2;
      }(Type)
    );
    exports.BooleanType = BooleanType;
    exports.boolean = new BooleanType();
    var AnyArrayType = (
      /** @class */
      function(_super) {
        __extends(AnyArrayType2, _super);
        function AnyArrayType2() {
          var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyArrayType";
          return _this;
        }
        return AnyArrayType2;
      }(Type)
    );
    exports.AnyArrayType = AnyArrayType;
    exports.UnknownArray = new AnyArrayType();
    exports.Array = exports.UnknownArray;
    var AnyDictionaryType = (
      /** @class */
      function(_super) {
        __extends(AnyDictionaryType2, _super);
        function AnyDictionaryType2() {
          var _this = _super.call(this, "UnknownRecord", function(u) {
            return u !== null && typeof u === "object" && !Array.isArray(u);
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyDictionaryType";
          return _this;
        }
        return AnyDictionaryType2;
      }(Type)
    );
    exports.AnyDictionaryType = AnyDictionaryType;
    exports.UnknownRecord = new AnyDictionaryType();
    var LiteralType = (
      /** @class */
      function(_super) {
        __extends(LiteralType2, _super);
        function LiteralType2(name, is, validate, encode, value) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.value = value;
          _this._tag = "LiteralType";
          return _this;
        }
        return LiteralType2;
      }(Type)
    );
    exports.LiteralType = LiteralType;
    function literal2(value, name) {
      if (name === void 0) {
        name = JSON.stringify(value);
      }
      var is = function(u) {
        return u === value;
      };
      return new LiteralType(name, is, function(u, c) {
        return is(u) ? (0, exports.success)(value) : (0, exports.failure)(u, c);
      }, exports.identity, value);
    }
    exports.literal = literal2;
    var KeyofType = (
      /** @class */
      function(_super) {
        __extends(KeyofType2, _super);
        function KeyofType2(name, is, validate, encode, keys4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.keys = keys4;
          _this._tag = "KeyofType";
          return _this;
        }
        return KeyofType2;
      }(Type)
    );
    exports.KeyofType = KeyofType;
    function keyof(keys4, name) {
      if (name === void 0) {
        name = Object.keys(keys4).map(function(k) {
          return JSON.stringify(k);
        }).join(" | ");
      }
      var is = function(u) {
        return exports.string.is(u) && hasOwnProperty.call(keys4, u);
      };
      return new KeyofType(name, is, function(u, c) {
        return is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
      }, exports.identity, keys4);
    }
    exports.keyof = keyof;
    var RefinementType = (
      /** @class */
      function(_super) {
        __extends(RefinementType2, _super);
        function RefinementType2(name, is, validate, encode, type4, predicate) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this.predicate = predicate;
          _this._tag = "RefinementType";
          return _this;
        }
        return RefinementType2;
      }(Type)
    );
    exports.RefinementType = RefinementType;
    function brand(codec, predicate, name) {
      return refinement(codec, predicate, name);
    }
    exports.brand = brand;
    exports.Int = brand(exports.number, function(n) {
      return Number.isInteger(n);
    }, "Int");
    var RecursiveType = (
      /** @class */
      function(_super) {
        __extends(RecursiveType2, _super);
        function RecursiveType2(name, is, validate, encode, runDefinition) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.runDefinition = runDefinition;
          _this._tag = "RecursiveType";
          return _this;
        }
        return RecursiveType2;
      }(Type)
    );
    exports.RecursiveType = RecursiveType;
    Object.defineProperty(RecursiveType.prototype, "type", {
      get: function() {
        return this.runDefinition();
      },
      enumerable: true,
      configurable: true
    });
    function recursion(name, definition) {
      var cache;
      var runDefinition = function() {
        if (!cache) {
          cache = definition(Self);
          cache.name = name;
        }
        return cache;
      };
      var Self = new RecursiveType(name, function(u) {
        return runDefinition().is(u);
      }, function(u, c) {
        return runDefinition().validate(u, c);
      }, function(a) {
        return runDefinition().encode(a);
      }, runDefinition);
      return Self;
    }
    exports.recursion = recursion;
    var ArrayType = (
      /** @class */
      function(_super) {
        __extends(ArrayType2, _super);
        function ArrayType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ArrayType";
          return _this;
        }
        return ArrayType2;
      }(Type)
    );
    exports.ArrayType = ArrayType;
    function array2(item, name) {
      if (name === void 0) {
        name = "Array<".concat(item.name, ">");
      }
      return new ArrayType(name, function(u) {
        return exports.UnknownArray.is(u) && u.every(item.is);
      }, function(u, c) {
        var e = exports.UnknownArray.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var us = e.right;
        var len = us.length;
        var as = us;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var ui = us[i];
          var result = item.validate(ui, appendContext(c, String(i), item, ui));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            var ai = result.right;
            if (ai !== ui) {
              if (as === us) {
                as = us.slice();
              }
              as[i] = ai;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
      }, item.encode === exports.identity ? exports.identity : function(a) {
        return a.map(item.encode);
      }, item);
    }
    exports.array = array2;
    var InterfaceType = (
      /** @class */
      function(_super) {
        __extends(InterfaceType2, _super);
        function InterfaceType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "InterfaceType";
          return _this;
        }
        return InterfaceType2;
      }(Type)
    );
    exports.InterfaceType = InterfaceType;
    function type3(props, name) {
      if (name === void 0) {
        name = getInterfaceTypeName(props);
      }
      var keys4 = Object.keys(props);
      var types = keys4.map(function(key) {
        return props[key];
      });
      var len = keys4.length;
      return new InterfaceType(name, function(u) {
        if (exports.UnknownRecord.is(u)) {
          for (var i = 0; i < len; i++) {
            var k = keys4[i];
            var uk = u[k];
            if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i].is(uk)) {
              return false;
            }
          }
          return true;
        }
        return false;
      }, function(u, c) {
        var e = exports.UnknownRecord.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var k = keys4[i];
          var ak = a[k];
          var type_1 = types[i];
          var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            var vak = result.right;
            if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a, k)) {
              if (a === o) {
                a = __assign({}, o);
              }
              a[k] = vak;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
      }, useIdentity(types) ? exports.identity : function(a) {
        var s = __assign({}, a);
        for (var i = 0; i < len; i++) {
          var k = keys4[i];
          var encode = types[i].encode;
          if (encode !== exports.identity) {
            s[k] = encode(a[k]);
          }
        }
        return s;
      }, props);
    }
    exports.type = type3;
    exports.interface = type3;
    var PartialType = (
      /** @class */
      function(_super) {
        __extends(PartialType2, _super);
        function PartialType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "PartialType";
          return _this;
        }
        return PartialType2;
      }(Type)
    );
    exports.PartialType = PartialType;
    function partial(props, name) {
      if (name === void 0) {
        name = getPartialTypeName(getInterfaceTypeName(props));
      }
      var keys4 = Object.keys(props);
      var types = keys4.map(function(key) {
        return props[key];
      });
      var len = keys4.length;
      return new PartialType(name, function(u) {
        if (exports.UnknownRecord.is(u)) {
          for (var i = 0; i < len; i++) {
            var k = keys4[i];
            var uk = u[k];
            if (uk !== void 0 && !props[k].is(uk)) {
              return false;
            }
          }
          return true;
        }
        return false;
      }, function(u, c) {
        var e = exports.UnknownRecord.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var k = keys4[i];
          var ak = a[k];
          var type_2 = props[k];
          var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
          if ((0, Either_1.isLeft)(result)) {
            if (ak !== void 0) {
              pushAll(errors, result.left);
            }
          } else {
            var vak = result.right;
            if (vak !== ak) {
              if (a === o) {
                a = __assign({}, o);
              }
              a[k] = vak;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
      }, useIdentity(types) ? exports.identity : function(a) {
        var s = __assign({}, a);
        for (var i = 0; i < len; i++) {
          var k = keys4[i];
          var ak = a[k];
          if (ak !== void 0) {
            s[k] = types[i].encode(ak);
          }
        }
        return s;
      }, props);
    }
    exports.partial = partial;
    var DictionaryType = (
      /** @class */
      function(_super) {
        __extends(DictionaryType2, _super);
        function DictionaryType2(name, is, validate, encode, domain, codomain) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.domain = domain;
          _this.codomain = codomain;
          _this._tag = "DictionaryType";
          return _this;
        }
        return DictionaryType2;
      }(Type)
    );
    exports.DictionaryType = DictionaryType;
    function record(domain, codomain, name) {
      var keys4 = getDomainKeys(domain);
      return keys4 ? enumerableRecord(Object.keys(keys4), domain, codomain, name) : nonEnumerableRecord(domain, codomain, name);
    }
    exports.record = record;
    var UnionType = (
      /** @class */
      function(_super) {
        __extends(UnionType2, _super);
        function UnionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "UnionType";
          return _this;
        }
        return UnionType2;
      }(Type)
    );
    exports.UnionType = UnionType;
    function union(codecs, name) {
      if (name === void 0) {
        name = getUnionName(codecs);
      }
      var index = getIndex(codecs);
      if (index !== void 0 && codecs.length > 0) {
        var tag_1 = index[0], groups_1 = index[1];
        var len_1 = groups_1.length;
        var find_1 = function(value) {
          for (var i = 0; i < len_1; i++) {
            if (groups_1[i].indexOf(value) !== -1) {
              return i;
            }
          }
          return void 0;
        };
        return new TaggedUnionType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            var i = find_1(u[tag_1]);
            return i !== void 0 ? codecs[i].is(u) : false;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var r = e.right;
          var i = find_1(r[tag_1]);
          if (i === void 0) {
            return (0, exports.failure)(u, c);
          }
          var codec = codecs[i];
          return codec.validate(r, appendContext(c, String(i), codec, r));
        }, useIdentity(codecs) ? exports.identity : function(a) {
          var i = find_1(a[tag_1]);
          if (i === void 0) {
            throw new Error("no codec found to encode value in union codec ".concat(name));
          } else {
            return codecs[i].encode(a);
          }
        }, codecs, tag_1);
      } else {
        return new UnionType(name, function(u) {
          return codecs.some(function(type4) {
            return type4.is(u);
          });
        }, function(u, c) {
          var errors = [];
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            var result = codec.validate(u, appendContext(c, String(i), codec, u));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              return (0, exports.success)(result.right);
            }
          }
          return (0, exports.failures)(errors);
        }, useIdentity(codecs) ? exports.identity : function(a) {
          for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
            var codec = codecs_1[_i];
            if (codec.is(a)) {
              return codec.encode(a);
            }
          }
          throw new Error("no codec found to encode value in union type ".concat(name));
        }, codecs);
      }
    }
    exports.union = union;
    var IntersectionType = (
      /** @class */
      function(_super) {
        __extends(IntersectionType2, _super);
        function IntersectionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "IntersectionType";
          return _this;
        }
        return IntersectionType2;
      }(Type)
    );
    exports.IntersectionType = IntersectionType;
    function intersection(codecs, name) {
      if (name === void 0) {
        name = "(".concat(codecs.map(function(type4) {
          return type4.name;
        }).join(" & "), ")");
      }
      var len = codecs.length;
      return new IntersectionType(name, function(u) {
        return codecs.every(function(type4) {
          return type4.is(u);
        });
      }, codecs.length === 0 ? exports.success : function(u, c) {
        var us = [];
        var errors = [];
        for (var i = 0; i < len; i++) {
          var codec = codecs[i];
          var result = codec.validate(u, appendContext(c, String(i), codec, u));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            us.push(result.right);
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(mergeAll(u, us));
      }, codecs.length === 0 ? exports.identity : function(a) {
        return mergeAll(a, codecs.map(function(codec) {
          return codec.encode(a);
        }));
      }, codecs);
    }
    exports.intersection = intersection;
    var TupleType = (
      /** @class */
      function(_super) {
        __extends(TupleType2, _super);
        function TupleType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "TupleType";
          return _this;
        }
        return TupleType2;
      }(Type)
    );
    exports.TupleType = TupleType;
    function tuple(codecs, name) {
      if (name === void 0) {
        name = "[".concat(codecs.map(function(type4) {
          return type4.name;
        }).join(", "), "]");
      }
      var len = codecs.length;
      return new TupleType(name, function(u) {
        return exports.UnknownArray.is(u) && u.length === len && codecs.every(function(type4, i) {
          return type4.is(u[i]);
        });
      }, function(u, c) {
        var e = exports.UnknownArray.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var us = e.right;
        var as = us.length > len ? us.slice(0, len) : us;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var a = us[i];
          var type_3 = codecs[i];
          var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            var va = result.right;
            if (va !== a) {
              if (as === us) {
                as = us.slice();
              }
              as[i] = va;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
      }, useIdentity(codecs) ? exports.identity : function(a) {
        return codecs.map(function(type4, i) {
          return type4.encode(a[i]);
        });
      }, codecs);
    }
    exports.tuple = tuple;
    var ReadonlyType = (
      /** @class */
      function(_super) {
        __extends(ReadonlyType2, _super);
        function ReadonlyType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ReadonlyType";
          return _this;
        }
        return ReadonlyType2;
      }(Type)
    );
    exports.ReadonlyType = ReadonlyType;
    function readonly(codec, name) {
      if (name === void 0) {
        name = "Readonly<".concat(codec.name, ">");
      }
      return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
    }
    exports.readonly = readonly;
    var ReadonlyArrayType = (
      /** @class */
      function(_super) {
        __extends(ReadonlyArrayType2, _super);
        function ReadonlyArrayType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ReadonlyArrayType";
          return _this;
        }
        return ReadonlyArrayType2;
      }(Type)
    );
    exports.ReadonlyArrayType = ReadonlyArrayType;
    function readonlyArray(item, name) {
      if (name === void 0) {
        name = "ReadonlyArray<".concat(item.name, ">");
      }
      var codec = array2(item);
      return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
    }
    exports.readonlyArray = readonlyArray;
    var strict = function(props, name) {
      return exact(type3(props), name);
    };
    exports.strict = strict;
    var ExactType = (
      /** @class */
      function(_super) {
        __extends(ExactType2, _super);
        function ExactType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ExactType";
          return _this;
        }
        return ExactType2;
      }(Type)
    );
    exports.ExactType = ExactType;
    function exact(codec, name) {
      if (name === void 0) {
        name = getExactTypeName(codec);
      }
      var props = getProps(codec);
      return new ExactType(name, codec.is, function(u, c) {
        var e = exports.UnknownRecord.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var ce = codec.validate(u, c);
        if ((0, Either_1.isLeft)(ce)) {
          return ce;
        }
        return (0, Either_1.right)(stripKeys(ce.right, props));
      }, function(a) {
        return codec.encode(stripKeys(a, props));
      }, codec);
    }
    exports.exact = exact;
    var FunctionType = (
      /** @class */
      function(_super) {
        __extends(FunctionType2, _super);
        function FunctionType2() {
          var _this = _super.call(
            this,
            "Function",
            // tslint:disable-next-line:strict-type-predicates
            function(u) {
              return typeof u === "function";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "FunctionType";
          return _this;
        }
        return FunctionType2;
      }(Type)
    );
    exports.FunctionType = FunctionType;
    exports.Function = new FunctionType();
    var NeverType = (
      /** @class */
      function(_super) {
        __extends(NeverType2, _super);
        function NeverType2() {
          var _this = _super.call(
            this,
            "never",
            function(_) {
              return false;
            },
            function(u, c) {
              return (0, exports.failure)(u, c);
            },
            /* istanbul ignore next */
            function() {
              throw new Error("cannot encode never");
            }
          ) || this;
          _this._tag = "NeverType";
          return _this;
        }
        return NeverType2;
      }(Type)
    );
    exports.NeverType = NeverType;
    exports.never = new NeverType();
    var AnyType = (
      /** @class */
      function(_super) {
        __extends(AnyType2, _super);
        function AnyType2() {
          var _this = _super.call(this, "any", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "AnyType";
          return _this;
        }
        return AnyType2;
      }(Type)
    );
    exports.AnyType = AnyType;
    exports.any = new AnyType();
    function refinement(codec, predicate, name) {
      if (name === void 0) {
        name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
      }
      return new RefinementType(name, function(u) {
        return codec.is(u) && predicate(u);
      }, function(i, c) {
        var e = codec.validate(i, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var a = e.right;
        return predicate(a) ? (0, exports.success)(a) : (0, exports.failure)(a, c);
      }, codec.encode, codec, predicate);
    }
    exports.refinement = refinement;
    exports.Integer = refinement(exports.number, Number.isInteger, "Integer");
    var TaggedUnionType = (
      /** @class */
      function(_super) {
        __extends(TaggedUnionType2, _super);
        function TaggedUnionType2(name, is, validate, encode, codecs, tag) {
          var _this = _super.call(this, name, is, validate, encode, codecs) || this;
          _this.tag = tag;
          return _this;
        }
        return TaggedUnionType2;
      }(UnionType)
    );
    exports.TaggedUnionType = TaggedUnionType;
    var taggedUnion = function(tag, codecs, name) {
      if (name === void 0) {
        name = getUnionName(codecs);
      }
      var U = union(codecs, name);
      if (U instanceof TaggedUnionType) {
        return U;
      } else {
        console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
      }
    };
    exports.taggedUnion = taggedUnion;
    var getValidationError = function(value, context) {
      return {
        value,
        context
      };
    };
    exports.getValidationError = getValidationError;
    var getDefaultContext = function(decoder) {
      return [
        { key: "", type: decoder }
      ];
    };
    exports.getDefaultContext = getDefaultContext;
    exports.Dictionary = exports.UnknownRecord;
    var ObjectType = (
      /** @class */
      function(_super) {
        __extends(ObjectType2, _super);
        function ObjectType2() {
          var _this = _super.call(this, "object", function(u) {
            return u !== null && typeof u === "object";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "ObjectType";
          return _this;
        }
        return ObjectType2;
      }(Type)
    );
    exports.ObjectType = ObjectType;
    exports.object = new ObjectType();
    exports.dictionary = record;
    var StrictType = (
      /** @class */
      function(_super) {
        __extends(StrictType2, _super);
        function StrictType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "StrictType";
          return _this;
        }
        return StrictType2;
      }(Type)
    );
    exports.StrictType = StrictType;
    function clean(codec) {
      return codec;
    }
    exports.clean = clean;
    function alias(codec) {
      return function() {
        return codec;
      };
    }
    exports.alias = alias;
  }
});

// node_modules/@ioredis/commands/built/commands.json
var require_commands = __commonJS({
  "node_modules/@ioredis/commands/built/commands.json"(exports, module2) {
    module2.exports = {
      acl: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      append: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      asking: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      auth: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "no_auth",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgrewriteaof: {
        arity: 1,
        flags: [
          "admin",
          "noscript",
          "no_async_loading"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgsave: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "no_async_loading"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bitcount: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield_ro: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitop: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 2,
        keyStop: -1,
        step: 1
      },
      bitpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      blmove: {
        arity: 6,
        flags: [
          "write",
          "denyoom",
          "noscript",
          "blocking"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      blmpop: {
        arity: -5,
        flags: [
          "write",
          "blocking",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      blpop: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "blocking"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpop: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "blocking"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpoplpush: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "noscript",
          "blocking"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      bzmpop: {
        arity: -5,
        flags: [
          "write",
          "blocking",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bzpopmax: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "blocking",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      bzpopmin: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "blocking",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      client: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      cluster: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      command: {
        arity: -1,
        flags: [
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      config: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      copy: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      dbsize: {
        arity: 1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      debug: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      decr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      decrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      del: {
        arity: -2,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      discard: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      dump: {
        arity: 2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      echo: {
        arity: 2,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      eval: {
        arity: -3,
        flags: [
          "noscript",
          "stale",
          "skip_monitor",
          "no_mandatory_keys",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      eval_ro: {
        arity: -3,
        flags: [
          "readonly",
          "noscript",
          "stale",
          "skip_monitor",
          "no_mandatory_keys",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      evalsha: {
        arity: -3,
        flags: [
          "noscript",
          "stale",
          "skip_monitor",
          "no_mandatory_keys",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      evalsha_ro: {
        arity: -3,
        flags: [
          "readonly",
          "noscript",
          "stale",
          "skip_monitor",
          "no_mandatory_keys",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exec: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_slowlog"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exists: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      expire: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      expireat: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      expiretime: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      failover: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      fcall: {
        arity: -3,
        flags: [
          "noscript",
          "stale",
          "skip_monitor",
          "no_mandatory_keys",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      fcall_ro: {
        arity: -3,
        flags: [
          "readonly",
          "noscript",
          "stale",
          "skip_monitor",
          "no_mandatory_keys",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushall: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushdb: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      function: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      geoadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geodist: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geohash: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geopos: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius: {
        arity: -6,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius_ro: {
        arity: -6,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember_ro: {
        arity: -5,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearch: {
        arity: -7,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearchstore: {
        arity: -8,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      get: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getbit: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getdel: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getex: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getset: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hello: {
        arity: -1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "no_auth",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      hexists: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hget: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hgetall: {
        arity: 2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrbyfloat: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hkeys: {
        arity: 2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmget: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hrandfield: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hscan: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hsetnx: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hstrlen: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hvals: {
        arity: 2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrbyfloat: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      info: {
        arity: -1,
        flags: [
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      keys: {
        arity: 2,
        flags: [
          "readonly"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lastsave: {
        arity: 1,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      latency: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lcs: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      lindex: {
        arity: 3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      linsert: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      llen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lmove: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      lmpop: {
        arity: -4,
        flags: [
          "write",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lolwut: {
        arity: -1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrem: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lset: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      ltrim: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      memory: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      mget: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      migrate: {
        arity: -6,
        flags: [
          "write",
          "movablekeys"
        ],
        keyStart: 3,
        keyStop: 3,
        step: 1
      },
      module: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      monitor: {
        arity: 1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      move: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      mset: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      msetnx: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      multi: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      object: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      persist: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpire: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpireat: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpiretime: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfadd: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfcount: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfdebug: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "admin"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      pfmerge: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfselftest: {
        arity: 1,
        flags: [
          "admin"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      ping: {
        arity: -1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psetex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      psubscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psync: {
        arity: -3,
        flags: [
          "admin",
          "noscript",
          "no_async_loading",
          "no_multi"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pttl: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      publish: {
        arity: 3,
        flags: [
          "pubsub",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pubsub: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      punsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      quit: {
        arity: -1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "no_auth",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      randomkey: {
        arity: 1,
        flags: [
          "readonly"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readonly: {
        arity: 1,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readwrite: {
        arity: 1,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rename: {
        arity: 3,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      renamenx: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      replconf: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      replicaof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale",
          "no_async_loading"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      reset: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "no_auth",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      restore: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      "restore-asking": {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "asking"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      role: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpoplpush: {
        arity: 3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      rpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sadd: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      save: {
        arity: 1,
        flags: [
          "admin",
          "noscript",
          "no_async_loading",
          "no_multi"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scan: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      script: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sdiff: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sdiffstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      select: {
        arity: 2,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      set: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setbit: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setnx: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setrange: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      shutdown: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale",
          "no_multi",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sinter: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sintercard: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sinterstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sismember: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      slaveof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale",
          "no_async_loading"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      slowlog: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      smembers: {
        arity: 2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smismember: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smove: {
        arity: 4,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      sort: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sort_ro: {
        arity: -2,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      spop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      spublish: {
        arity: 3,
        flags: [
          "pubsub",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srandmember: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sscan: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      ssubscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      strlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      subscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      substr: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sunion: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sunionstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sunsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      swapdb: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sync: {
        arity: 1,
        flags: [
          "admin",
          "noscript",
          "no_async_loading",
          "no_multi"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      time: {
        arity: 1,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      touch: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      ttl: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      type: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      unlink: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      unsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      unwatch: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "allow_busy"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      wait: {
        arity: 3,
        flags: [
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      watch: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast",
          "allow_busy"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      xack: {
        arity: -4,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xautoclaim: {
        arity: -6,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xclaim: {
        arity: -6,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xgroup: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xinfo: {
        arity: -2,
        flags: [],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xpending: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xread: {
        arity: -4,
        flags: [
          "readonly",
          "blocking",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xreadgroup: {
        arity: -7,
        flags: [
          "write",
          "blocking",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xsetid: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xtrim: {
        arity: -4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zadd: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zdiff: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zdiffstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zinter: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zintercard: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zinterstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zlexcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zmpop: {
        arity: -4,
        flags: [
          "write",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zmscore: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmax: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmin: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrandmember: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangestore: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      zrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebylex: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyrank: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyscore: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscan: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscore: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zunion: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zunionstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      }
    };
  }
});

// node_modules/@ioredis/commands/built/index.js
var require_built = __commonJS({
  "node_modules/@ioredis/commands/built/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getKeyIndexes = exports.hasFlag = exports.exists = exports.list = void 0;
    var commands_json_1 = __importDefault(require_commands());
    exports.list = Object.keys(commands_json_1.default);
    var flags = {};
    exports.list.forEach((commandName) => {
      flags[commandName] = commands_json_1.default[commandName].flags.reduce(function(flags2, flag) {
        flags2[flag] = true;
        return flags2;
      }, {});
    });
    function exists(commandName) {
      return Boolean(commands_json_1.default[commandName]);
    }
    exports.exists = exists;
    function hasFlag(commandName, flag) {
      if (!flags[commandName]) {
        throw new Error("Unknown command " + commandName);
      }
      return Boolean(flags[commandName][flag]);
    }
    exports.hasFlag = hasFlag;
    function getKeyIndexes(commandName, args, options) {
      const command = commands_json_1.default[commandName];
      if (!command) {
        throw new Error("Unknown command " + commandName);
      }
      if (!Array.isArray(args)) {
        throw new Error("Expect args to be an array");
      }
      const keys4 = [];
      const parseExternalKey = Boolean(options && options.parseExternalKey);
      const takeDynamicKeys = (args2, startIndex) => {
        const keys5 = [];
        const keyStop = Number(args2[startIndex]);
        for (let i = 0; i < keyStop; i++) {
          keys5.push(i + startIndex + 1);
        }
        return keys5;
      };
      const takeKeyAfterToken = (args2, startIndex, token) => {
        for (let i = startIndex; i < args2.length - 1; i += 1) {
          if (String(args2[i]).toLowerCase() === token.toLowerCase()) {
            return i + 1;
          }
        }
        return null;
      };
      switch (commandName) {
        case "zunionstore":
        case "zinterstore":
        case "zdiffstore":
          keys4.push(0, ...takeDynamicKeys(args, 1));
          break;
        case "eval":
        case "evalsha":
        case "eval_ro":
        case "evalsha_ro":
        case "fcall":
        case "fcall_ro":
        case "blmpop":
        case "bzmpop":
          keys4.push(...takeDynamicKeys(args, 1));
          break;
        case "sintercard":
        case "lmpop":
        case "zunion":
        case "zinter":
        case "zmpop":
        case "zintercard":
        case "zdiff": {
          keys4.push(...takeDynamicKeys(args, 0));
          break;
        }
        case "georadius": {
          keys4.push(0);
          const storeKey = takeKeyAfterToken(args, 5, "STORE");
          if (storeKey)
            keys4.push(storeKey);
          const distKey = takeKeyAfterToken(args, 5, "STOREDIST");
          if (distKey)
            keys4.push(distKey);
          break;
        }
        case "georadiusbymember": {
          keys4.push(0);
          const storeKey = takeKeyAfterToken(args, 4, "STORE");
          if (storeKey)
            keys4.push(storeKey);
          const distKey = takeKeyAfterToken(args, 4, "STOREDIST");
          if (distKey)
            keys4.push(distKey);
          break;
        }
        case "sort":
        case "sort_ro":
          keys4.push(0);
          for (let i = 1; i < args.length - 1; i++) {
            let arg = args[i];
            if (typeof arg !== "string") {
              continue;
            }
            const directive = arg.toUpperCase();
            if (directive === "GET") {
              i += 1;
              arg = args[i];
              if (arg !== "#") {
                if (parseExternalKey) {
                  keys4.push([i, getExternalKeyNameLength(arg)]);
                } else {
                  keys4.push(i);
                }
              }
            } else if (directive === "BY") {
              i += 1;
              if (parseExternalKey) {
                keys4.push([i, getExternalKeyNameLength(args[i])]);
              } else {
                keys4.push(i);
              }
            } else if (directive === "STORE") {
              i += 1;
              keys4.push(i);
            }
          }
          break;
        case "migrate":
          if (args[2] === "") {
            for (let i = 5; i < args.length - 1; i++) {
              const arg = args[i];
              if (typeof arg === "string" && arg.toUpperCase() === "KEYS") {
                for (let j = i + 1; j < args.length; j++) {
                  keys4.push(j);
                }
                break;
              }
            }
          } else {
            keys4.push(2);
          }
          break;
        case "xreadgroup":
        case "xread":
          for (let i = commandName === "xread" ? 0 : 3; i < args.length - 1; i++) {
            if (String(args[i]).toUpperCase() === "STREAMS") {
              for (let j = i + 1; j <= i + (args.length - 1 - i) / 2; j++) {
                keys4.push(j);
              }
              break;
            }
          }
          break;
        default:
          if (command.step > 0) {
            const keyStart = command.keyStart - 1;
            const keyStop = command.keyStop > 0 ? command.keyStop : args.length + command.keyStop + 1;
            for (let i = keyStart; i < keyStop; i += command.step) {
              keys4.push(i);
            }
          }
          break;
      }
      return keys4;
    }
    exports.getKeyIndexes = getKeyIndexes;
    function getExternalKeyNameLength(key) {
      if (typeof key !== "string") {
        key = String(key);
      }
      const hashPos = key.indexOf("->");
      return hashPos === -1 ? key.length : hashPos;
    }
  }
});

// node_modules/standard-as-callback/built/utils.js
var require_utils = __commonJS({
  "node_modules/standard-as-callback/built/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tryCatch = exports.errorObj = void 0;
    exports.errorObj = { e: {} };
    var tryCatchTarget;
    function tryCatcher(err, val) {
      try {
        const target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        exports.errorObj.e = e;
        return exports.errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    exports.tryCatch = tryCatch;
  }
});

// node_modules/standard-as-callback/built/index.js
var require_built2 = __commonJS({
  "node_modules/standard-as-callback/built/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    function throwLater(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function asCallback(promise, nodeback, options) {
      if (typeof nodeback === "function") {
        promise.then((val) => {
          let ret;
          if (options !== void 0 && Object(options).spread && Array.isArray(val)) {
            ret = utils_1.tryCatch(nodeback).apply(void 0, [null].concat(val));
          } else {
            ret = val === void 0 ? utils_1.tryCatch(nodeback)(null) : utils_1.tryCatch(nodeback)(null, val);
          }
          if (ret === utils_1.errorObj) {
            throwLater(ret.e);
          }
        }, (cause) => {
          if (!cause) {
            const newReason = new Error(cause + "");
            Object.assign(newReason, { cause });
            cause = newReason;
          }
          const ret = utils_1.tryCatch(nodeback)(cause);
          if (ret === utils_1.errorObj) {
            throwLater(ret.e);
          }
        });
      }
      return promise;
    }
    exports.default = asCallback;
  }
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS({
  "node_modules/redis-errors/lib/old.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var util = require("util");
    function RedisError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(RedisError, Error);
    Object.defineProperty(RedisError.prototype, "name", {
      value: "RedisError",
      configurable: true,
      writable: true
    });
    function ParserError(message, buffer, offset) {
      assert(buffer);
      assert.strictEqual(typeof offset, "number");
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
      this.offset = offset;
      this.buffer = buffer;
    }
    util.inherits(ParserError, RedisError);
    Object.defineProperty(ParserError.prototype, "name", {
      value: "ParserError",
      configurable: true,
      writable: true
    });
    function ReplyError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
    }
    util.inherits(ReplyError, RedisError);
    Object.defineProperty(ReplyError.prototype, "name", {
      value: "ReplyError",
      configurable: true,
      writable: true
    });
    function AbortError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(AbortError, RedisError);
    Object.defineProperty(AbortError.prototype, "name", {
      value: "AbortError",
      configurable: true,
      writable: true
    });
    function InterruptError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(InterruptError, AbortError);
    Object.defineProperty(InterruptError.prototype, "name", {
      value: "InterruptError",
      configurable: true,
      writable: true
    });
    module2.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError,
      InterruptError
    };
  }
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS({
  "node_modules/redis-errors/lib/modern.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var RedisError = class extends Error {
      get name() {
        return this.constructor.name;
      }
    };
    var ParserError = class extends RedisError {
      constructor(message, buffer, offset) {
        assert(buffer);
        assert.strictEqual(typeof offset, "number");
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
        this.offset = offset;
        this.buffer = buffer;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var ReplyError = class extends RedisError {
      constructor(message) {
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var AbortError = class extends RedisError {
      get name() {
        return this.constructor.name;
      }
    };
    var InterruptError = class extends AbortError {
      get name() {
        return this.constructor.name;
      }
    };
    module2.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError,
      InterruptError
    };
  }
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS({
  "node_modules/redis-errors/index.js"(exports, module2) {
    "use strict";
    var Errors = process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46 ? require_old() : require_modern();
    module2.exports = Errors;
  }
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/cluster-key-slot/lib/index.js"(exports, module2) {
    var lookup = [
      0,
      4129,
      8258,
      12387,
      16516,
      20645,
      24774,
      28903,
      33032,
      37161,
      41290,
      45419,
      49548,
      53677,
      57806,
      61935,
      4657,
      528,
      12915,
      8786,
      21173,
      17044,
      29431,
      25302,
      37689,
      33560,
      45947,
      41818,
      54205,
      50076,
      62463,
      58334,
      9314,
      13379,
      1056,
      5121,
      25830,
      29895,
      17572,
      21637,
      42346,
      46411,
      34088,
      38153,
      58862,
      62927,
      50604,
      54669,
      13907,
      9842,
      5649,
      1584,
      30423,
      26358,
      22165,
      18100,
      46939,
      42874,
      38681,
      34616,
      63455,
      59390,
      55197,
      51132,
      18628,
      22757,
      26758,
      30887,
      2112,
      6241,
      10242,
      14371,
      51660,
      55789,
      59790,
      63919,
      35144,
      39273,
      43274,
      47403,
      23285,
      19156,
      31415,
      27286,
      6769,
      2640,
      14899,
      10770,
      56317,
      52188,
      64447,
      60318,
      39801,
      35672,
      47931,
      43802,
      27814,
      31879,
      19684,
      23749,
      11298,
      15363,
      3168,
      7233,
      60846,
      64911,
      52716,
      56781,
      44330,
      48395,
      36200,
      40265,
      32407,
      28342,
      24277,
      20212,
      15891,
      11826,
      7761,
      3696,
      65439,
      61374,
      57309,
      53244,
      48923,
      44858,
      40793,
      36728,
      37256,
      33193,
      45514,
      41451,
      53516,
      49453,
      61774,
      57711,
      4224,
      161,
      12482,
      8419,
      20484,
      16421,
      28742,
      24679,
      33721,
      37784,
      41979,
      46042,
      49981,
      54044,
      58239,
      62302,
      689,
      4752,
      8947,
      13010,
      16949,
      21012,
      25207,
      29270,
      46570,
      42443,
      38312,
      34185,
      62830,
      58703,
      54572,
      50445,
      13538,
      9411,
      5280,
      1153,
      29798,
      25671,
      21540,
      17413,
      42971,
      47098,
      34713,
      38840,
      59231,
      63358,
      50973,
      55100,
      9939,
      14066,
      1681,
      5808,
      26199,
      30326,
      17941,
      22068,
      55628,
      51565,
      63758,
      59695,
      39368,
      35305,
      47498,
      43435,
      22596,
      18533,
      30726,
      26663,
      6336,
      2273,
      14466,
      10403,
      52093,
      56156,
      60223,
      64286,
      35833,
      39896,
      43963,
      48026,
      19061,
      23124,
      27191,
      31254,
      2801,
      6864,
      10931,
      14994,
      64814,
      60687,
      56684,
      52557,
      48554,
      44427,
      40424,
      36297,
      31782,
      27655,
      23652,
      19525,
      15522,
      11395,
      7392,
      3265,
      61215,
      65342,
      53085,
      57212,
      44955,
      49082,
      36825,
      40952,
      28183,
      32310,
      20053,
      24180,
      11923,
      16050,
      3793,
      7920
    ];
    var toUTF8Array = function toUTF8Array2(str) {
      var char;
      var i = 0;
      var p = 0;
      var utf8 = [];
      var len = str.length;
      for (; i < len; i++) {
        char = str.charCodeAt(i);
        if (char < 128) {
          utf8[p++] = char;
        } else if (char < 2048) {
          utf8[p++] = char >> 6 | 192;
          utf8[p++] = char & 63 | 128;
        } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
          char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
          utf8[p++] = char >> 18 | 240;
          utf8[p++] = char >> 12 & 63 | 128;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        } else {
          utf8[p++] = char >> 12 | 224;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        }
      }
      return utf8;
    };
    var generate = module2.exports = function generate2(str) {
      var char;
      var i = 0;
      var start = -1;
      var result = 0;
      var resultHash = 0;
      var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
      var len = utf8.length;
      while (i < len) {
        char = utf8[i++];
        if (start === -1) {
          if (char === 123) {
            start = i;
          }
        } else if (char !== 125) {
          resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
        } else if (i - 1 !== start) {
          return resultHash & 16383;
        }
        result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
      }
      return result & 16383;
    };
    module2.exports.generateMulti = function generateMulti(keys4) {
      var i = 1;
      var len = keys4.length;
      var base = generate(keys4[0]);
      while (i < len) {
        if (generate(keys4[i++]) !== base)
          return -1;
      }
      return base;
    };
  }
});

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.defaults/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignInDefaults(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
        while (++index < length) {
          array2[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array2;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type3 = typeof index;
      if (type3 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type3 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type3 = typeof value;
      return !!value && (type3 == "object" || type3 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    var defaults = baseRest(function(args) {
      args.push(void 0, assignInDefaults);
      return apply(assignInWith, void 0, args);
    });
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = defaults;
  }
});

// node_modules/lodash.isarguments/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isarguments/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type3 = typeof value;
      return !!value && (type3 == "object" || type3 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isArguments;
  }
});

// node_modules/ioredis/built/utils/lodash.js
var require_lodash3 = __commonJS({
  "node_modules/ioredis/built/utils/lodash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArguments = exports.defaults = exports.noop = void 0;
    var defaults = require_lodash();
    exports.defaults = defaults;
    var isArguments = require_lodash2();
    exports.isArguments = isArguments;
    function noop() {
    }
    exports.noop = noop;
  }
});

// node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/debug/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type3 = typeof val;
      if (type3 === "string" && val.length > 0) {
        return parse(val);
      } else if (type3 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type3 = (match[2] || "ms").toLowerCase();
      switch (type3) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys4 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys4.length; i++) {
        debug.inspectOpts[keys4[i]] = exports.inspectOpts[keys4[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/ioredis/built/utils/debug.js
var require_debug = __commonJS({
  "node_modules/ioredis/built/utils/debug.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = void 0;
    var debug_1 = require_src();
    var MAX_ARGUMENT_LENGTH = 200;
    exports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;
    var NAMESPACE_PREFIX = "ioredis";
    function getStringValue(v) {
      if (v === null) {
        return;
      }
      switch (typeof v) {
        case "boolean":
          return;
        case "number":
          return;
        case "object":
          if (Buffer.isBuffer(v)) {
            return v.toString("hex");
          }
          if (Array.isArray(v)) {
            return v.join(",");
          }
          try {
            return JSON.stringify(v);
          } catch (e) {
            return;
          }
        case "string":
          return v;
      }
    }
    exports.getStringValue = getStringValue;
    function genRedactedString(str, maxLen) {
      const { length } = str;
      return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length="' + length + '">';
    }
    exports.genRedactedString = genRedactedString;
    function genDebugFunction(namespace) {
      const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);
      function wrappedDebug(...args) {
        if (!fn.enabled) {
          return;
        }
        for (let i = 1; i < args.length; i++) {
          const str = getStringValue(args[i]);
          if (typeof str === "string" && str.length > MAX_ARGUMENT_LENGTH) {
            args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);
          }
        }
        return fn.apply(null, args);
      }
      Object.defineProperties(wrappedDebug, {
        namespace: {
          get() {
            return fn.namespace;
          }
        },
        enabled: {
          get() {
            return fn.enabled;
          }
        },
        destroy: {
          get() {
            return fn.destroy;
          }
        },
        log: {
          get() {
            return fn.log;
          },
          set(l) {
            fn.log = l;
          }
        }
      });
      return wrappedDebug;
    }
    exports.default = genDebugFunction;
  }
});

// node_modules/ioredis/built/constants/TLSProfiles.js
var require_TLSProfiles = __commonJS({
  "node_modules/ioredis/built/constants/TLSProfiles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RedisCloudCA = `-----BEGIN CERTIFICATE-----
MIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP
JnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz
rmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E
QwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2
BDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3
TMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp
4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w
MB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w
DQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta
lbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6
Su8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ
uFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k
BpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp
Z4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx
CzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w
KwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN
MTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG
A1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy
bWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA
A4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv
Tq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4
VuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym
hjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W
P0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN
r0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw
hhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s
UzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u
P1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9
MjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT
t5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID
AQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy
LnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw
AYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G
A1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4
L2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB
hjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr
AP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW
vcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw
7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+
XoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc
AUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1
jQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh
/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z
zDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli
iF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43
iqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo
616pxqo=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz
TGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y
aXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC
VVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz
MS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw
ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1
G5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY
Dm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl
pp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT
ULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag
54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ
xeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC
JpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K
2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3
StsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI
SIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B
cS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL
yzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T
AQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg
z5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu
rYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3
3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+
hSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ
D0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj
TY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l
FXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj
mcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf
ybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji
n8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F
UhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM
MSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv
YmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y
NTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu
IG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy
MDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf
8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD
BVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg
ofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK
dZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh
counQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu
jE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG
CCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW
BBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj
move4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw
Mi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1
cmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w
K6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD
VR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC
AQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/
3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY
0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX
y+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3
15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5
ZgKnO/Fx2hBgTxhOTMYaD312kg==
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
WD9f
-----END CERTIFICATE-----`;
    var TLSProfiles = {
      RedisCloudFixed: { ca: RedisCloudCA },
      RedisCloudFlexible: { ca: RedisCloudCA }
    };
    exports.default = TLSProfiles;
  }
});

// node_modules/ioredis/built/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/ioredis/built/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noop = exports.defaults = exports.Debug = exports.zipMap = exports.CONNECTION_CLOSED_ERROR_MSG = exports.shuffle = exports.sample = exports.resolveTLSProfile = exports.parseURL = exports.optimizeErrorStack = exports.toArg = exports.convertMapToArray = exports.convertObjectToArray = exports.timeout = exports.packObject = exports.isInt = exports.wrapMultiResult = exports.convertBufferToString = void 0;
    var url_1 = require("url");
    var lodash_1 = require_lodash3();
    Object.defineProperty(exports, "defaults", { enumerable: true, get: function() {
      return lodash_1.defaults;
    } });
    Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
      return lodash_1.noop;
    } });
    var debug_1 = require_debug();
    exports.Debug = debug_1.default;
    var TLSProfiles_1 = require_TLSProfiles();
    function convertBufferToString(value, encoding) {
      if (value instanceof Buffer) {
        return value.toString(encoding);
      }
      if (Array.isArray(value)) {
        const length = value.length;
        const res = Array(length);
        for (let i = 0; i < length; ++i) {
          res[i] = value[i] instanceof Buffer && encoding === "utf8" ? value[i].toString() : convertBufferToString(value[i], encoding);
        }
        return res;
      }
      return value;
    }
    exports.convertBufferToString = convertBufferToString;
    function wrapMultiResult(arr) {
      if (!arr) {
        return null;
      }
      const result = [];
      const length = arr.length;
      for (let i = 0; i < length; ++i) {
        const item = arr[i];
        if (item instanceof Error) {
          result.push([item]);
        } else {
          result.push([null, item]);
        }
      }
      return result;
    }
    exports.wrapMultiResult = wrapMultiResult;
    function isInt(value) {
      const x = parseFloat(value);
      return !isNaN(value) && (x | 0) === x;
    }
    exports.isInt = isInt;
    function packObject(array2) {
      const result = {};
      const length = array2.length;
      for (let i = 1; i < length; i += 2) {
        result[array2[i - 1]] = array2[i];
      }
      return result;
    }
    exports.packObject = packObject;
    function timeout(callback, timeout2) {
      let timer = null;
      const run = function() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
          callback.apply(this, arguments);
        }
      };
      timer = setTimeout(run, timeout2, new Error("timeout"));
      return run;
    }
    exports.timeout = timeout;
    function convertObjectToArray(obj) {
      const result = [];
      const keys4 = Object.keys(obj);
      for (let i = 0, l = keys4.length; i < l; i++) {
        result.push(keys4[i], obj[keys4[i]]);
      }
      return result;
    }
    exports.convertObjectToArray = convertObjectToArray;
    function convertMapToArray(map) {
      const result = [];
      let pos = 0;
      map.forEach(function(value, key) {
        result[pos] = key;
        result[pos + 1] = value;
        pos += 2;
      });
      return result;
    }
    exports.convertMapToArray = convertMapToArray;
    function toArg(arg) {
      if (arg === null || typeof arg === "undefined") {
        return "";
      }
      return String(arg);
    }
    exports.toArg = toArg;
    function optimizeErrorStack(error, friendlyStack, filterPath) {
      const stacks = friendlyStack.split("\n");
      let lines = "";
      let i;
      for (i = 1; i < stacks.length; ++i) {
        if (stacks[i].indexOf(filterPath) === -1) {
          break;
        }
      }
      for (let j = i; j < stacks.length; ++j) {
        lines += "\n" + stacks[j];
      }
      if (error.stack) {
        const pos = error.stack.indexOf("\n");
        error.stack = error.stack.slice(0, pos) + lines;
      }
      return error;
    }
    exports.optimizeErrorStack = optimizeErrorStack;
    function parseURL(url) {
      if (isInt(url)) {
        return { port: url };
      }
      let parsed = (0, url_1.parse)(url, true, true);
      if (!parsed.slashes && url[0] !== "/") {
        url = "//" + url;
        parsed = (0, url_1.parse)(url, true, true);
      }
      const options = parsed.query || {};
      const result = {};
      if (parsed.auth) {
        const index = parsed.auth.indexOf(":");
        result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);
        result.password = index === -1 ? "" : parsed.auth.slice(index + 1);
      }
      if (parsed.pathname) {
        if (parsed.protocol === "redis:" || parsed.protocol === "rediss:") {
          if (parsed.pathname.length > 1) {
            result.db = parsed.pathname.slice(1);
          }
        } else {
          result.path = parsed.pathname;
        }
      }
      if (parsed.host) {
        result.host = parsed.hostname;
      }
      if (parsed.port) {
        result.port = parsed.port;
      }
      if (typeof options.family === "string") {
        const intFamily = Number.parseInt(options.family, 10);
        if (!Number.isNaN(intFamily)) {
          result.family = intFamily;
        }
      }
      (0, lodash_1.defaults)(result, options);
      return result;
    }
    exports.parseURL = parseURL;
    function resolveTLSProfile(options) {
      let tls = options === null || options === void 0 ? void 0 : options.tls;
      if (typeof tls === "string")
        tls = { profile: tls };
      const profile = TLSProfiles_1.default[tls === null || tls === void 0 ? void 0 : tls.profile];
      if (profile) {
        tls = Object.assign({}, profile, tls);
        delete tls.profile;
        options = Object.assign({}, options, { tls });
      }
      return options;
    }
    exports.resolveTLSProfile = resolveTLSProfile;
    function sample(array2, from = 0) {
      const length = array2.length;
      if (from >= length) {
        return null;
      }
      return array2[from + Math.floor(Math.random() * (length - from))];
    }
    exports.sample = sample;
    function shuffle(array2) {
      let counter = array2.length;
      while (counter > 0) {
        const index = Math.floor(Math.random() * counter);
        counter--;
        [array2[counter], array2[index]] = [array2[index], array2[counter]];
      }
      return array2;
    }
    exports.shuffle = shuffle;
    exports.CONNECTION_CLOSED_ERROR_MSG = "Connection is closed.";
    function zipMap(keys4, values) {
      const map = /* @__PURE__ */ new Map();
      keys4.forEach((key, index) => {
        map.set(key, values[index]);
      });
      return map;
    }
    exports.zipMap = zipMap;
  }
});

// node_modules/ioredis/built/Command.js
var require_Command = __commonJS({
  "node_modules/ioredis/built/Command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = require_built();
    var calculateSlot = require_lib3();
    var standard_as_callback_1 = require_built2();
    var utils_1 = require_utils2();
    var Command = class _Command {
      /**
       * Creates an instance of Command.
       * @param name Command name
       * @param args An array of command arguments
       * @param options
       * @param callback The callback that handles the response.
       * If omit, the response will be handled via Promise
       */
      constructor(name, args = [], options = {}, callback) {
        this.name = name;
        this.inTransaction = false;
        this.isResolved = false;
        this.transformed = false;
        this.replyEncoding = options.replyEncoding;
        this.errorStack = options.errorStack;
        this.args = args.flat();
        this.callback = callback;
        this.initPromise();
        if (options.keyPrefix) {
          const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;
          let keyPrefixBuffer = isBufferKeyPrefix ? options.keyPrefix : null;
          this._iterateKeys((key) => {
            if (key instanceof Buffer) {
              if (keyPrefixBuffer === null) {
                keyPrefixBuffer = Buffer.from(options.keyPrefix);
              }
              return Buffer.concat([keyPrefixBuffer, key]);
            } else if (isBufferKeyPrefix) {
              return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);
            }
            return options.keyPrefix + key;
          });
        }
        if (options.readOnly) {
          this.isReadOnly = true;
        }
      }
      /**
       * Check whether the command has the flag
       */
      static checkFlag(flagName, commandName) {
        return !!this.getFlagMap()[flagName][commandName];
      }
      static setArgumentTransformer(name, func) {
        this._transformer.argument[name] = func;
      }
      static setReplyTransformer(name, func) {
        this._transformer.reply[name] = func;
      }
      static getFlagMap() {
        if (!this.flagMap) {
          this.flagMap = Object.keys(_Command.FLAGS).reduce((map, flagName) => {
            map[flagName] = {};
            _Command.FLAGS[flagName].forEach((commandName) => {
              map[flagName][commandName] = true;
            });
            return map;
          }, {});
        }
        return this.flagMap;
      }
      getSlot() {
        if (typeof this.slot === "undefined") {
          const key = this.getKeys()[0];
          this.slot = key == null ? null : calculateSlot(key);
        }
        return this.slot;
      }
      getKeys() {
        return this._iterateKeys();
      }
      /**
       * Convert command to writable buffer or string
       */
      toWritable(_socket) {
        let result;
        const commandStr = "*" + (this.args.length + 1) + "\r\n$" + Buffer.byteLength(this.name) + "\r\n" + this.name + "\r\n";
        if (this.bufferMode) {
          const buffers = new MixedBuffers();
          buffers.push(commandStr);
          for (let i = 0; i < this.args.length; ++i) {
            const arg = this.args[i];
            if (arg instanceof Buffer) {
              if (arg.length === 0) {
                buffers.push("$0\r\n\r\n");
              } else {
                buffers.push("$" + arg.length + "\r\n");
                buffers.push(arg);
                buffers.push("\r\n");
              }
            } else {
              buffers.push("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
            }
          }
          result = buffers.toBuffer();
        } else {
          result = commandStr;
          for (let i = 0; i < this.args.length; ++i) {
            const arg = this.args[i];
            result += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
          }
        }
        return result;
      }
      stringifyArguments() {
        for (let i = 0; i < this.args.length; ++i) {
          const arg = this.args[i];
          if (typeof arg === "string") {
          } else if (arg instanceof Buffer) {
            this.bufferMode = true;
          } else {
            this.args[i] = (0, utils_1.toArg)(arg);
          }
        }
      }
      /**
       * Convert buffer/buffer[] to string/string[],
       * and apply reply transformer.
       */
      transformReply(result) {
        if (this.replyEncoding) {
          result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);
        }
        const transformer = _Command._transformer.reply[this.name];
        if (transformer) {
          result = transformer(result);
        }
        return result;
      }
      /**
       * Set the wait time before terminating the attempt to execute a command
       * and generating an error.
       */
      setTimeout(ms) {
        if (!this._commandTimeoutTimer) {
          this._commandTimeoutTimer = setTimeout(() => {
            if (!this.isResolved) {
              this.reject(new Error("Command timed out"));
            }
          }, ms);
        }
      }
      initPromise() {
        const promise = new Promise((resolve, reject) => {
          if (!this.transformed) {
            this.transformed = true;
            const transformer = _Command._transformer.argument[this.name];
            if (transformer) {
              this.args = transformer(this.args);
            }
            this.stringifyArguments();
          }
          this.resolve = this._convertValue(resolve);
          if (this.errorStack) {
            this.reject = (err) => {
              reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));
            };
          } else {
            this.reject = reject;
          }
        });
        this.promise = (0, standard_as_callback_1.default)(promise, this.callback);
      }
      /**
       * Iterate through the command arguments that are considered keys.
       */
      _iterateKeys(transform = (key) => key) {
        if (typeof this.keys === "undefined") {
          this.keys = [];
          if ((0, commands_1.exists)(this.name)) {
            const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);
            for (const index of keyIndexes) {
              this.args[index] = transform(this.args[index]);
              this.keys.push(this.args[index]);
            }
          }
        }
        return this.keys;
      }
      /**
       * Convert the value from buffer to the target encoding.
       */
      _convertValue(resolve) {
        return (value) => {
          try {
            const existingTimer = this._commandTimeoutTimer;
            if (existingTimer) {
              clearTimeout(existingTimer);
              delete this._commandTimeoutTimer;
            }
            resolve(this.transformReply(value));
            this.isResolved = true;
          } catch (err) {
            this.reject(err);
          }
          return this.promise;
        };
      }
    };
    exports.default = Command;
    Command.FLAGS = {
      VALID_IN_SUBSCRIBER_MODE: [
        "subscribe",
        "psubscribe",
        "unsubscribe",
        "punsubscribe",
        "ssubscribe",
        "sunsubscribe",
        "ping",
        "quit"
      ],
      VALID_IN_MONITOR_MODE: ["monitor", "auth"],
      ENTER_SUBSCRIBER_MODE: ["subscribe", "psubscribe", "ssubscribe"],
      EXIT_SUBSCRIBER_MODE: ["unsubscribe", "punsubscribe", "sunsubscribe"],
      WILL_DISCONNECT: ["quit"]
    };
    Command._transformer = {
      argument: {},
      reply: {}
    };
    var msetArgumentTransformer = function(args) {
      if (args.length === 1) {
        if (args[0] instanceof Map) {
          return (0, utils_1.convertMapToArray)(args[0]);
        }
        if (typeof args[0] === "object" && args[0] !== null) {
          return (0, utils_1.convertObjectToArray)(args[0]);
        }
      }
      return args;
    };
    var hsetArgumentTransformer = function(args) {
      if (args.length === 2) {
        if (args[1] instanceof Map) {
          return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));
        }
        if (typeof args[1] === "object" && args[1] !== null) {
          return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));
        }
      }
      return args;
    };
    Command.setArgumentTransformer("mset", msetArgumentTransformer);
    Command.setArgumentTransformer("msetnx", msetArgumentTransformer);
    Command.setArgumentTransformer("hset", hsetArgumentTransformer);
    Command.setArgumentTransformer("hmset", hsetArgumentTransformer);
    Command.setReplyTransformer("hgetall", function(result) {
      if (Array.isArray(result)) {
        const obj = {};
        for (let i = 0; i < result.length; i += 2) {
          const key = result[i];
          const value = result[i + 1];
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
        }
        return obj;
      }
      return result;
    });
    var MixedBuffers = class {
      constructor() {
        this.length = 0;
        this.items = [];
      }
      push(x) {
        this.length += Buffer.byteLength(x);
        this.items.push(x);
      }
      toBuffer() {
        const result = Buffer.allocUnsafe(this.length);
        let offset = 0;
        for (const item of this.items) {
          const length = Buffer.byteLength(item);
          Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);
          offset += length;
        }
        return result;
      }
    };
  }
});

// node_modules/ioredis/built/errors/ClusterAllFailedError.js
var require_ClusterAllFailedError = __commonJS({
  "node_modules/ioredis/built/errors/ClusterAllFailedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var redis_errors_1 = require_redis_errors();
    var ClusterAllFailedError = class extends redis_errors_1.RedisError {
      constructor(message, lastNodeError) {
        super(message);
        this.lastNodeError = lastNodeError;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
    };
    exports.default = ClusterAllFailedError;
    ClusterAllFailedError.defaultMessage = "Failed to refresh slots cache.";
  }
});

// node_modules/ioredis/built/ScanStream.js
var require_ScanStream = __commonJS({
  "node_modules/ioredis/built/ScanStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var ScanStream = class extends stream_1.Readable {
      constructor(opt) {
        super(opt);
        this.opt = opt;
        this._redisCursor = "0";
        this._redisDrained = false;
      }
      _read() {
        if (this._redisDrained) {
          this.push(null);
          return;
        }
        const args = [this._redisCursor];
        if (this.opt.key) {
          args.unshift(this.opt.key);
        }
        if (this.opt.match) {
          args.push("MATCH", this.opt.match);
        }
        if (this.opt.type) {
          args.push("TYPE", this.opt.type);
        }
        if (this.opt.count) {
          args.push("COUNT", String(this.opt.count));
        }
        this.opt.redis[this.opt.command](args, (err, res) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];
          if (this._redisCursor === "0") {
            this._redisDrained = true;
          }
          this.push(res[1]);
        });
      }
      close() {
        this._redisDrained = true;
      }
    };
    exports.default = ScanStream;
  }
});

// node_modules/ioredis/built/autoPipelining.js
var require_autoPipelining = __commonJS({
  "node_modules/ioredis/built/autoPipelining.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = void 0;
    var lodash_1 = require_lodash3();
    var calculateSlot = require_lib3();
    var standard_as_callback_1 = require_built2();
    exports.kExec = Symbol("exec");
    exports.kCallbacks = Symbol("callbacks");
    exports.notAllowedAutoPipelineCommands = [
      "auth",
      "info",
      "script",
      "quit",
      "cluster",
      "pipeline",
      "multi",
      "subscribe",
      "psubscribe",
      "unsubscribe",
      "unpsubscribe",
      "select"
    ];
    function executeAutoPipeline(client, slotKey) {
      if (client._runningAutoPipelines.has(slotKey)) {
        return;
      }
      if (!client._autoPipelines.has(slotKey)) {
        return;
      }
      client._runningAutoPipelines.add(slotKey);
      const pipeline = client._autoPipelines.get(slotKey);
      client._autoPipelines.delete(slotKey);
      const callbacks = pipeline[exports.kCallbacks];
      pipeline[exports.kCallbacks] = null;
      pipeline.exec(function(err, results) {
        client._runningAutoPipelines.delete(slotKey);
        if (err) {
          for (let i = 0; i < callbacks.length; i++) {
            process.nextTick(callbacks[i], err);
          }
        } else {
          for (let i = 0; i < callbacks.length; i++) {
            process.nextTick(callbacks[i], ...results[i]);
          }
        }
        if (client._autoPipelines.has(slotKey)) {
          executeAutoPipeline(client, slotKey);
        }
      });
    }
    function shouldUseAutoPipelining(client, functionName, commandName) {
      return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);
    }
    exports.shouldUseAutoPipelining = shouldUseAutoPipelining;
    function getFirstValueInFlattenedArray(args) {
      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (typeof arg === "string") {
          return arg;
        } else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {
          if (arg.length === 0) {
            continue;
          }
          return arg[0];
        }
        const flattened = [arg].flat();
        if (flattened.length > 0) {
          return flattened[0];
        }
      }
      return void 0;
    }
    exports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;
    function executeWithAutoPipelining(client, functionName, commandName, args, callback) {
      if (client.isCluster && !client.slots.length) {
        if (client.status === "wait")
          client.connect().catch(lodash_1.noop);
        return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {
          client.delayUntilReady((err) => {
            if (err) {
              reject(err);
              return;
            }
            executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);
          });
        }), callback);
      }
      const prefix = client.options.keyPrefix || "";
      const slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(",") : "main";
      if (!client._autoPipelines.has(slotKey)) {
        const pipeline2 = client.pipeline();
        pipeline2[exports.kExec] = false;
        pipeline2[exports.kCallbacks] = [];
        client._autoPipelines.set(slotKey, pipeline2);
      }
      const pipeline = client._autoPipelines.get(slotKey);
      if (!pipeline[exports.kExec]) {
        pipeline[exports.kExec] = true;
        setImmediate(executeAutoPipeline, client, slotKey);
      }
      const autoPipelinePromise = new Promise(function(resolve, reject) {
        pipeline[exports.kCallbacks].push(function(err, value) {
          if (err) {
            reject(err);
            return;
          }
          resolve(value);
        });
        if (functionName === "call") {
          args.unshift(commandName);
        }
        pipeline[functionName](...args);
      });
      return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);
    }
    exports.executeWithAutoPipelining = executeWithAutoPipelining;
  }
});

// node_modules/ioredis/built/Script.js
var require_Script = __commonJS({
  "node_modules/ioredis/built/Script.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var Command_1 = require_Command();
    var standard_as_callback_1 = require_built2();
    var Script2 = class {
      constructor(lua, numberOfKeys = null, keyPrefix = "", readOnly = false) {
        this.lua = lua;
        this.numberOfKeys = numberOfKeys;
        this.keyPrefix = keyPrefix;
        this.readOnly = readOnly;
        this.sha = (0, crypto_1.createHash)("sha1").update(lua).digest("hex");
        const sha = this.sha;
        const socketHasScriptLoaded = /* @__PURE__ */ new WeakSet();
        this.Command = class CustomScriptCommand extends Command_1.default {
          toWritable(socket) {
            const origReject = this.reject;
            this.reject = (err) => {
              if (err.message.indexOf("NOSCRIPT") !== -1) {
                socketHasScriptLoaded.delete(socket);
              }
              origReject.call(this, err);
            };
            if (!socketHasScriptLoaded.has(socket)) {
              socketHasScriptLoaded.add(socket);
              this.name = "eval";
              this.args[0] = lua;
            } else if (this.name === "eval") {
              this.name = "evalsha";
              this.args[0] = sha;
            }
            return super.toWritable(socket);
          }
        };
      }
      execute(container, args, options, callback) {
        if (typeof this.numberOfKeys === "number") {
          args.unshift(this.numberOfKeys);
        }
        if (this.keyPrefix) {
          options.keyPrefix = this.keyPrefix;
        }
        if (this.readOnly) {
          options.readOnly = true;
        }
        const evalsha = new this.Command("evalsha", [this.sha, ...args], options);
        evalsha.promise = evalsha.promise.catch((err) => {
          if (err.message.indexOf("NOSCRIPT") === -1) {
            throw err;
          }
          const resend = new this.Command("evalsha", [this.sha, ...args], options);
          const client = container.isPipeline ? container.redis : container;
          return client.sendCommand(resend);
        });
        (0, standard_as_callback_1.default)(evalsha.promise, callback);
        return container.sendCommand(evalsha);
      }
    };
    exports.default = Script2;
  }
});

// node_modules/ioredis/built/utils/Commander.js
var require_Commander = __commonJS({
  "node_modules/ioredis/built/utils/Commander.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = require_built();
    var autoPipelining_1 = require_autoPipelining();
    var Command_1 = require_Command();
    var Script_1 = require_Script();
    var Commander = class {
      constructor() {
        this.options = {};
        this.scriptsSet = {};
        this.addedBuiltinSet = /* @__PURE__ */ new Set();
      }
      /**
       * Return supported builtin commands
       */
      getBuiltinCommands() {
        return commands.slice(0);
      }
      /**
       * Create a builtin command
       */
      createBuiltinCommand(commandName) {
        return {
          string: generateFunction(null, commandName, "utf8"),
          buffer: generateFunction(null, commandName, null)
        };
      }
      /**
       * Create add builtin command
       */
      addBuiltinCommand(commandName) {
        this.addedBuiltinSet.add(commandName);
        this[commandName] = generateFunction(commandName, commandName, "utf8");
        this[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
      }
      /**
       * Define a custom command using lua script
       */
      defineCommand(name, definition) {
        const script = new Script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);
        this.scriptsSet[name] = script;
        this[name] = generateScriptingFunction(name, name, script, "utf8");
        this[name + "Buffer"] = generateScriptingFunction(name + "Buffer", name, script, null);
      }
      /**
       * @ignore
       */
      sendCommand(command, stream, node) {
        throw new Error('"sendCommand" is not implemented');
      }
    };
    var commands = commands_1.list.filter((command) => command !== "monitor");
    commands.push("sentinel");
    commands.forEach(function(commandName) {
      Commander.prototype[commandName] = generateFunction(commandName, commandName, "utf8");
      Commander.prototype[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
    });
    Commander.prototype.call = generateFunction("call", "utf8");
    Commander.prototype.callBuffer = generateFunction("callBuffer", null);
    Commander.prototype.send_command = Commander.prototype.call;
    function generateFunction(functionName, _commandName, _encoding) {
      if (typeof _encoding === "undefined") {
        _encoding = _commandName;
        _commandName = null;
      }
      return function(...args) {
        const commandName = _commandName || args.shift();
        let callback = args[args.length - 1];
        if (typeof callback === "function") {
          args.pop();
        } else {
          callback = void 0;
        }
        const options = {
          errorStack: this.options.showFriendlyErrorStack ? new Error() : void 0,
          keyPrefix: this.options.keyPrefix,
          replyEncoding: _encoding
        };
        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
          return this.sendCommand(
            // @ts-expect-error
            new Command_1.default(commandName, args, options, callback)
          );
        }
        return (0, autoPipelining_1.executeWithAutoPipelining)(
          this,
          functionName,
          commandName,
          // @ts-expect-error
          args,
          callback
        );
      };
    }
    function generateScriptingFunction(functionName, commandName, script, encoding) {
      return function(...args) {
        const callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
        const options = {
          replyEncoding: encoding
        };
        if (this.options.showFriendlyErrorStack) {
          options.errorStack = new Error();
        }
        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
          return script.execute(this, args, options, callback);
        }
        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);
      };
    }
    exports.default = Commander;
  }
});

// node_modules/ioredis/built/Pipeline.js
var require_Pipeline = __commonJS({
  "node_modules/ioredis/built/Pipeline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var calculateSlot = require_lib3();
    var commands_1 = require_built();
    var standard_as_callback_1 = require_built2();
    var util_1 = require("util");
    var Command_1 = require_Command();
    var utils_1 = require_utils2();
    var Commander_1 = require_Commander();
    function generateMultiWithNodes(redis, keys4) {
      const slot = calculateSlot(keys4[0]);
      const target = redis._groupsBySlot[slot];
      for (let i = 1; i < keys4.length; i++) {
        if (redis._groupsBySlot[calculateSlot(keys4[i])] !== target) {
          return -1;
        }
      }
      return slot;
    }
    var Pipeline = class extends Commander_1.default {
      constructor(redis) {
        super();
        this.redis = redis;
        this.isPipeline = true;
        this.replyPending = 0;
        this._queue = [];
        this._result = [];
        this._transactions = 0;
        this._shaToScript = {};
        this.isCluster = this.redis.constructor.name === "Cluster" || this.redis.isCluster;
        this.options = redis.options;
        Object.keys(redis.scriptsSet).forEach((name) => {
          const script = redis.scriptsSet[name];
          this._shaToScript[script.sha] = script;
          this[name] = redis[name];
          this[name + "Buffer"] = redis[name + "Buffer"];
        });
        redis.addedBuiltinSet.forEach((name) => {
          this[name] = redis[name];
          this[name + "Buffer"] = redis[name + "Buffer"];
        });
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
        const _this = this;
        Object.defineProperty(this, "length", {
          get: function() {
            return _this._queue.length;
          }
        });
      }
      fillResult(value, position) {
        if (this._queue[position].name === "exec" && Array.isArray(value[1])) {
          const execLength = value[1].length;
          for (let i = 0; i < execLength; i++) {
            if (value[1][i] instanceof Error) {
              continue;
            }
            const cmd = this._queue[position - (execLength - i)];
            try {
              value[1][i] = cmd.transformReply(value[1][i]);
            } catch (err) {
              value[1][i] = err;
            }
          }
        }
        this._result[position] = value;
        if (--this.replyPending) {
          return;
        }
        if (this.isCluster) {
          let retriable = true;
          let commonError;
          for (let i = 0; i < this._result.length; ++i) {
            const error = this._result[i][0];
            const command = this._queue[i];
            if (error) {
              if (command.name === "exec" && error.message === "EXECABORT Transaction discarded because of previous errors.") {
                continue;
              }
              if (!commonError) {
                commonError = {
                  name: error.name,
                  message: error.message
                };
              } else if (commonError.name !== error.name || commonError.message !== error.message) {
                retriable = false;
                break;
              }
            } else if (!command.inTransaction) {
              const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "readonly");
              if (!isReadOnly) {
                retriable = false;
                break;
              }
            }
          }
          if (commonError && retriable) {
            const _this = this;
            const errv = commonError.message.split(" ");
            const queue = this._queue;
            let inTransaction = false;
            this._queue = [];
            for (let i = 0; i < queue.length; ++i) {
              if (errv[0] === "ASK" && !inTransaction && queue[i].name !== "asking" && (!queue[i - 1] || queue[i - 1].name !== "asking")) {
                const asking = new Command_1.default("asking");
                asking.ignore = true;
                this.sendCommand(asking);
              }
              queue[i].initPromise();
              this.sendCommand(queue[i]);
              inTransaction = queue[i].inTransaction;
            }
            let matched = true;
            if (typeof this.leftRedirections === "undefined") {
              this.leftRedirections = {};
            }
            const exec = function() {
              _this.exec();
            };
            const cluster = this.redis;
            cluster.handleError(commonError, this.leftRedirections, {
              moved: function(_slot, key) {
                _this.preferKey = key;
                cluster.slots[errv[1]] = [key];
                cluster._groupsBySlot[errv[1]] = cluster._groupsIds[cluster.slots[errv[1]].join(";")];
                cluster.refreshSlotsCache();
                _this.exec();
              },
              ask: function(_slot, key) {
                _this.preferKey = key;
                _this.exec();
              },
              tryagain: exec,
              clusterDown: exec,
              connectionClosed: exec,
              maxRedirections: () => {
                matched = false;
              },
              defaults: () => {
                matched = false;
              }
            });
            if (matched) {
              return;
            }
          }
        }
        let ignoredCount = 0;
        for (let i = 0; i < this._queue.length - ignoredCount; ++i) {
          if (this._queue[i + ignoredCount].ignore) {
            ignoredCount += 1;
          }
          this._result[i] = this._result[i + ignoredCount];
        }
        this.resolve(this._result.slice(0, this._result.length - ignoredCount));
      }
      sendCommand(command) {
        if (this._transactions > 0) {
          command.inTransaction = true;
        }
        const position = this._queue.length;
        command.pipelineIndex = position;
        command.promise.then((result) => {
          this.fillResult([null, result], position);
        }).catch((error) => {
          this.fillResult([error], position);
        });
        this._queue.push(command);
        return this;
      }
      addBatch(commands) {
        let command, commandName, args;
        for (let i = 0; i < commands.length; ++i) {
          command = commands[i];
          commandName = command[0];
          args = command.slice(1);
          this[commandName].apply(this, args);
        }
        return this;
      }
    };
    exports.default = Pipeline;
    var multi = Pipeline.prototype.multi;
    Pipeline.prototype.multi = function() {
      this._transactions += 1;
      return multi.apply(this, arguments);
    };
    var execBuffer = Pipeline.prototype.execBuffer;
    Pipeline.prototype.execBuffer = (0, util_1.deprecate)(function() {
      if (this._transactions > 0) {
        this._transactions -= 1;
      }
      return execBuffer.apply(this, arguments);
    }, "Pipeline#execBuffer: Use Pipeline#exec instead");
    Pipeline.prototype.exec = function(callback) {
      if (this.isCluster && !this.redis.slots.length) {
        if (this.redis.status === "wait")
          this.redis.connect().catch(utils_1.noop);
        if (callback && !this.nodeifiedPromise) {
          this.nodeifiedPromise = true;
          (0, standard_as_callback_1.default)(this.promise, callback);
        }
        this.redis.delayUntilReady((err) => {
          if (err) {
            this.reject(err);
            return;
          }
          this.exec(callback);
        });
        return this.promise;
      }
      if (this._transactions > 0) {
        this._transactions -= 1;
        return execBuffer.apply(this, arguments);
      }
      if (!this.nodeifiedPromise) {
        this.nodeifiedPromise = true;
        (0, standard_as_callback_1.default)(this.promise, callback);
      }
      if (!this._queue.length) {
        this.resolve([]);
      }
      let pipelineSlot;
      if (this.isCluster) {
        const sampleKeys = [];
        for (let i = 0; i < this._queue.length; i++) {
          const keys4 = this._queue[i].getKeys();
          if (keys4.length) {
            sampleKeys.push(keys4[0]);
          }
          if (keys4.length && calculateSlot.generateMulti(keys4) < 0) {
            this.reject(new Error("All the keys in a pipeline command should belong to the same slot"));
            return this.promise;
          }
        }
        if (sampleKeys.length) {
          pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);
          if (pipelineSlot < 0) {
            this.reject(new Error("All keys in the pipeline should belong to the same slots allocation group"));
            return this.promise;
          }
        } else {
          pipelineSlot = Math.random() * 16384 | 0;
        }
      }
      const _this = this;
      execPipeline();
      return this.promise;
      function execPipeline() {
        let writePending = _this.replyPending = _this._queue.length;
        let node;
        if (_this.isCluster) {
          node = {
            slot: pipelineSlot,
            redis: _this.redis.connectionPool.nodes.all[_this.preferKey]
          };
        }
        let data = "";
        let buffers;
        const stream = {
          isPipeline: true,
          destination: _this.isCluster ? node : { redis: _this.redis },
          write(writable) {
            if (typeof writable !== "string") {
              if (!buffers) {
                buffers = [];
              }
              if (data) {
                buffers.push(Buffer.from(data, "utf8"));
                data = "";
              }
              buffers.push(writable);
            } else {
              data += writable;
            }
            if (!--writePending) {
              if (buffers) {
                if (data) {
                  buffers.push(Buffer.from(data, "utf8"));
                }
                stream.destination.redis.stream.write(Buffer.concat(buffers));
              } else {
                stream.destination.redis.stream.write(data);
              }
              writePending = _this._queue.length;
              data = "";
              buffers = void 0;
            }
          }
        };
        for (let i = 0; i < _this._queue.length; ++i) {
          _this.redis.sendCommand(_this._queue[i], stream, node);
        }
        return _this.promise;
      }
    };
  }
});

// node_modules/ioredis/built/transaction.js
var require_transaction = __commonJS({
  "node_modules/ioredis/built/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addTransactionSupport = void 0;
    var utils_1 = require_utils2();
    var standard_as_callback_1 = require_built2();
    var Pipeline_1 = require_Pipeline();
    function addTransactionSupport(redis) {
      redis.pipeline = function(commands) {
        const pipeline = new Pipeline_1.default(this);
        if (Array.isArray(commands)) {
          pipeline.addBatch(commands);
        }
        return pipeline;
      };
      const { multi } = redis;
      redis.multi = function(commands, options) {
        if (typeof options === "undefined" && !Array.isArray(commands)) {
          options = commands;
          commands = null;
        }
        if (options && options.pipeline === false) {
          return multi.call(this);
        }
        const pipeline = new Pipeline_1.default(this);
        pipeline.multi();
        if (Array.isArray(commands)) {
          pipeline.addBatch(commands);
        }
        const exec2 = pipeline.exec;
        pipeline.exec = function(callback) {
          if (this.isCluster && !this.redis.slots.length) {
            if (this.redis.status === "wait")
              this.redis.connect().catch(utils_1.noop);
            return (0, standard_as_callback_1.default)(new Promise((resolve, reject) => {
              this.redis.delayUntilReady((err) => {
                if (err) {
                  reject(err);
                  return;
                }
                this.exec(pipeline).then(resolve, reject);
              });
            }), callback);
          }
          if (this._transactions > 0) {
            exec2.call(pipeline);
          }
          if (this.nodeifiedPromise) {
            return exec2.call(pipeline);
          }
          const promise = exec2.call(pipeline);
          return (0, standard_as_callback_1.default)(promise.then(function(result) {
            const execResult = result[result.length - 1];
            if (typeof execResult === "undefined") {
              throw new Error("Pipeline cannot be used to send any commands when the `exec()` has been called on it.");
            }
            if (execResult[0]) {
              execResult[0].previousErrors = [];
              for (let i = 0; i < result.length - 1; ++i) {
                if (result[i][0]) {
                  execResult[0].previousErrors.push(result[i][0]);
                }
              }
              throw execResult[0];
            }
            return (0, utils_1.wrapMultiResult)(execResult[1]);
          }), callback);
        };
        const { execBuffer } = pipeline;
        pipeline.execBuffer = function(callback) {
          if (this._transactions > 0) {
            execBuffer.call(pipeline);
          }
          return pipeline.exec(callback);
        };
        return pipeline;
      };
      const { exec } = redis;
      redis.exec = function(callback) {
        return (0, standard_as_callback_1.default)(exec.call(this).then(function(results) {
          if (Array.isArray(results)) {
            results = (0, utils_1.wrapMultiResult)(results);
          }
          return results;
        }), callback);
      };
    }
    exports.addTransactionSupport = addTransactionSupport;
  }
});

// node_modules/ioredis/built/utils/applyMixin.js
var require_applyMixin = __commonJS({
  "node_modules/ioredis/built/utils/applyMixin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function applyMixin(derivedConstructor, mixinConstructor) {
      Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name) => {
        Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name));
      });
    }
    exports.default = applyMixin;
  }
});

// node_modules/ioredis/built/cluster/ClusterOptions.js
var require_ClusterOptions = __commonJS({
  "node_modules/ioredis/built/cluster/ClusterOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_CLUSTER_OPTIONS = void 0;
    var dns_1 = require("dns");
    exports.DEFAULT_CLUSTER_OPTIONS = {
      clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2e3),
      enableOfflineQueue: true,
      enableReadyCheck: true,
      scaleReads: "master",
      maxRedirections: 16,
      retryDelayOnMoved: 0,
      retryDelayOnFailover: 100,
      retryDelayOnClusterDown: 100,
      retryDelayOnTryAgain: 100,
      slotsRefreshTimeout: 1e3,
      useSRVRecords: false,
      resolveSrv: dns_1.resolveSrv,
      dnsLookup: dns_1.lookup,
      enableAutoPipelining: false,
      autoPipeliningIgnoredCommands: []
    };
  }
});

// node_modules/ioredis/built/cluster/util.js
var require_util = __commonJS({
  "node_modules/ioredis/built/cluster/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getConnectionName = exports.weightSrvRecords = exports.groupSrvRecords = exports.getUniqueHostnamesFromOptions = exports.normalizeNodeOptions = exports.nodeKeyToRedisOptions = exports.getNodeKey = void 0;
    var utils_1 = require_utils2();
    var net_1 = require("net");
    function getNodeKey(node) {
      node.port = node.port || 6379;
      node.host = node.host || "127.0.0.1";
      return node.host + ":" + node.port;
    }
    exports.getNodeKey = getNodeKey;
    function nodeKeyToRedisOptions(nodeKey) {
      const portIndex = nodeKey.lastIndexOf(":");
      if (portIndex === -1) {
        throw new Error(`Invalid node key ${nodeKey}`);
      }
      return {
        host: nodeKey.slice(0, portIndex),
        port: Number(nodeKey.slice(portIndex + 1))
      };
    }
    exports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;
    function normalizeNodeOptions(nodes) {
      return nodes.map((node) => {
        const options = {};
        if (typeof node === "object") {
          Object.assign(options, node);
        } else if (typeof node === "string") {
          Object.assign(options, (0, utils_1.parseURL)(node));
        } else if (typeof node === "number") {
          options.port = node;
        } else {
          throw new Error("Invalid argument " + node);
        }
        if (typeof options.port === "string") {
          options.port = parseInt(options.port, 10);
        }
        delete options.db;
        if (!options.port) {
          options.port = 6379;
        }
        if (!options.host) {
          options.host = "127.0.0.1";
        }
        return (0, utils_1.resolveTLSProfile)(options);
      });
    }
    exports.normalizeNodeOptions = normalizeNodeOptions;
    function getUniqueHostnamesFromOptions(nodes) {
      const uniqueHostsMap = {};
      nodes.forEach((node) => {
        uniqueHostsMap[node.host] = true;
      });
      return Object.keys(uniqueHostsMap).filter((host) => !(0, net_1.isIP)(host));
    }
    exports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;
    function groupSrvRecords(records) {
      const recordsByPriority = {};
      for (const record of records) {
        if (!recordsByPriority.hasOwnProperty(record.priority)) {
          recordsByPriority[record.priority] = {
            totalWeight: record.weight,
            records: [record]
          };
        } else {
          recordsByPriority[record.priority].totalWeight += record.weight;
          recordsByPriority[record.priority].records.push(record);
        }
      }
      return recordsByPriority;
    }
    exports.groupSrvRecords = groupSrvRecords;
    function weightSrvRecords(recordsGroup) {
      if (recordsGroup.records.length === 1) {
        recordsGroup.totalWeight = 0;
        return recordsGroup.records.shift();
      }
      const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));
      let total = 0;
      for (const [i, record] of recordsGroup.records.entries()) {
        total += 1 + record.weight;
        if (total > random) {
          recordsGroup.totalWeight -= record.weight;
          recordsGroup.records.splice(i, 1);
          return record;
        }
      }
    }
    exports.weightSrvRecords = weightSrvRecords;
    function getConnectionName(component, nodeConnectionName) {
      const prefix = `ioredis-cluster(${component})`;
      return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;
    }
    exports.getConnectionName = getConnectionName;
  }
});

// node_modules/ioredis/built/cluster/ClusterSubscriber.js
var require_ClusterSubscriber = __commonJS({
  "node_modules/ioredis/built/cluster/ClusterSubscriber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var utils_1 = require_utils2();
    var Redis_1 = require_Redis();
    var debug = (0, utils_1.Debug)("cluster:subscriber");
    var ClusterSubscriber = class {
      constructor(connectionPool, emitter) {
        this.connectionPool = connectionPool;
        this.emitter = emitter;
        this.started = false;
        this.subscriber = null;
        this.onSubscriberEnd = () => {
          if (!this.started) {
            debug("subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.");
            return;
          }
          debug("subscriber has disconnected, selecting a new one...");
          this.selectSubscriber();
        };
        this.connectionPool.on("-node", (_, key) => {
          if (!this.started || !this.subscriber) {
            return;
          }
          if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {
            debug("subscriber has left, selecting a new one...");
            this.selectSubscriber();
          }
        });
        this.connectionPool.on("+node", () => {
          if (!this.started || this.subscriber) {
            return;
          }
          debug("a new node is discovered and there is no subscriber, selecting a new one...");
          this.selectSubscriber();
        });
      }
      getInstance() {
        return this.subscriber;
      }
      start() {
        this.started = true;
        this.selectSubscriber();
        debug("started");
      }
      stop() {
        this.started = false;
        if (this.subscriber) {
          this.subscriber.disconnect();
          this.subscriber = null;
        }
        debug("stopped");
      }
      selectSubscriber() {
        const lastActiveSubscriber = this.lastActiveSubscriber;
        if (lastActiveSubscriber) {
          lastActiveSubscriber.off("end", this.onSubscriberEnd);
          lastActiveSubscriber.disconnect();
        }
        if (this.subscriber) {
          this.subscriber.off("end", this.onSubscriberEnd);
          this.subscriber.disconnect();
        }
        const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());
        if (!sampleNode) {
          debug("selecting subscriber failed since there is no node discovered in the cluster yet");
          this.subscriber = null;
          return;
        }
        const { options } = sampleNode;
        debug("selected a subscriber %s:%s", options.host, options.port);
        this.subscriber = new Redis_1.default({
          port: options.port,
          host: options.host,
          username: options.username,
          password: options.password,
          enableReadyCheck: true,
          connectionName: (0, util_1.getConnectionName)("subscriber", options.connectionName),
          lazyConnect: true,
          tls: options.tls,
          // Don't try to reconnect the subscriber connection. If the connection fails
          // we will get an end event (handled below), at which point we'll pick a new
          // node from the pool and try to connect to that as the subscriber connection.
          retryStrategy: null
        });
        this.subscriber.on("error", utils_1.noop);
        this.subscriber.once("end", this.onSubscriberEnd);
        const previousChannels = { subscribe: [], psubscribe: [], ssubscribe: [] };
        if (lastActiveSubscriber) {
          const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;
          if (condition && condition.subscriber) {
            previousChannels.subscribe = condition.subscriber.channels("subscribe");
            previousChannels.psubscribe = condition.subscriber.channels("psubscribe");
            previousChannels.ssubscribe = condition.subscriber.channels("ssubscribe");
          }
        }
        if (previousChannels.subscribe.length || previousChannels.psubscribe.length || previousChannels.ssubscribe.length) {
          let pending = 0;
          for (const type3 of ["subscribe", "psubscribe", "ssubscribe"]) {
            const channels = previousChannels[type3];
            if (channels.length) {
              pending += 1;
              debug("%s %d channels", type3, channels.length);
              this.subscriber[type3](channels).then(() => {
                if (!--pending) {
                  this.lastActiveSubscriber = this.subscriber;
                }
              }).catch(() => {
                debug("failed to %s %d channels", type3, channels.length);
              });
            }
          }
        } else {
          this.lastActiveSubscriber = this.subscriber;
        }
        for (const event of [
          "message",
          "messageBuffer",
          "smessage",
          "smessageBuffer"
        ]) {
          this.subscriber.on(event, (arg1, arg2) => {
            this.emitter.emit(event, arg1, arg2);
          });
        }
        for (const event of ["pmessage", "pmessageBuffer"]) {
          this.subscriber.on(event, (arg1, arg2, arg3) => {
            this.emitter.emit(event, arg1, arg2, arg3);
          });
        }
      }
    };
    exports.default = ClusterSubscriber;
  }
});

// node_modules/ioredis/built/cluster/ConnectionPool.js
var require_ConnectionPool = __commonJS({
  "node_modules/ioredis/built/cluster/ConnectionPool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require("events");
    var utils_1 = require_utils2();
    var util_1 = require_util();
    var Redis_1 = require_Redis();
    var debug = (0, utils_1.Debug)("cluster:connectionPool");
    var ConnectionPool = class extends events_1.EventEmitter {
      constructor(redisOptions) {
        super();
        this.redisOptions = redisOptions;
        this.nodes = {
          all: {},
          master: {},
          slave: {}
        };
        this.specifiedOptions = {};
      }
      getNodes(role = "all") {
        const nodes = this.nodes[role];
        return Object.keys(nodes).map((key) => nodes[key]);
      }
      getInstanceByKey(key) {
        return this.nodes.all[key];
      }
      getSampleInstance(role) {
        const keys4 = Object.keys(this.nodes[role]);
        const sampleKey = (0, utils_1.sample)(keys4);
        return this.nodes[role][sampleKey];
      }
      /**
       * Find or create a connection to the node
       */
      findOrCreate(node, readOnly = false) {
        const key = (0, util_1.getNodeKey)(node);
        readOnly = Boolean(readOnly);
        if (this.specifiedOptions[key]) {
          Object.assign(node, this.specifiedOptions[key]);
        } else {
          this.specifiedOptions[key] = node;
        }
        let redis;
        if (this.nodes.all[key]) {
          redis = this.nodes.all[key];
          if (redis.options.readOnly !== readOnly) {
            redis.options.readOnly = readOnly;
            debug("Change role of %s to %s", key, readOnly ? "slave" : "master");
            redis[readOnly ? "readonly" : "readwrite"]().catch(utils_1.noop);
            if (readOnly) {
              delete this.nodes.master[key];
              this.nodes.slave[key] = redis;
            } else {
              delete this.nodes.slave[key];
              this.nodes.master[key] = redis;
            }
          }
        } else {
          debug("Connecting to %s as %s", key, readOnly ? "slave" : "master");
          redis = new Redis_1.default((0, utils_1.defaults)({
            // Never try to reconnect when a node is lose,
            // instead, waiting for a `MOVED` error and
            // fetch the slots again.
            retryStrategy: null,
            // Offline queue should be enabled so that
            // we don't need to wait for the `ready` event
            // before sending commands to the node.
            enableOfflineQueue: true,
            readOnly
          }, node, this.redisOptions, { lazyConnect: true }));
          this.nodes.all[key] = redis;
          this.nodes[readOnly ? "slave" : "master"][key] = redis;
          redis.once("end", () => {
            this.removeNode(key);
            this.emit("-node", redis, key);
            if (!Object.keys(this.nodes.all).length) {
              this.emit("drain");
            }
          });
          this.emit("+node", redis, key);
          redis.on("error", function(error) {
            this.emit("nodeError", error, key);
          });
        }
        return redis;
      }
      /**
       * Reset the pool with a set of nodes.
       * The old node will be removed.
       */
      reset(nodes) {
        debug("Reset with %O", nodes);
        const newNodes = {};
        nodes.forEach((node) => {
          const key = (0, util_1.getNodeKey)(node);
          if (!(node.readOnly && newNodes[key])) {
            newNodes[key] = node;
          }
        });
        Object.keys(this.nodes.all).forEach((key) => {
          if (!newNodes[key]) {
            debug("Disconnect %s because the node does not hold any slot", key);
            this.nodes.all[key].disconnect();
            this.removeNode(key);
          }
        });
        Object.keys(newNodes).forEach((key) => {
          const node = newNodes[key];
          this.findOrCreate(node, node.readOnly);
        });
      }
      /**
       * Remove a node from the pool.
       */
      removeNode(key) {
        const { nodes } = this;
        if (nodes.all[key]) {
          debug("Remove %s from the pool", key);
          delete nodes.all[key];
        }
        delete nodes.master[key];
        delete nodes.slave[key];
      }
    };
    exports.default = ConnectionPool;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports, module2) {
    "use strict";
    function Denque(array2, options) {
      var options = options || {};
      this._capacity = options.capacity;
      this._head = 0;
      this._tail = 0;
      if (Array.isArray(array2)) {
        this._fromArray(array2);
      } else {
        this._capacityMask = 3;
        this._list = new Array(4);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (arguments.length === 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (arguments.length === 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._list = new Array(this._list.length);
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array2) {
      var length = array2.length;
      var capacity = this._nextPowerOf2(length);
      this._list = new Array(capacity);
      this._capacityMask = capacity - 1;
      this._tail = length;
      for (var i = 0; i < length; i++)
        this._list[i] = array2[i];
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
      var src = this._list;
      var capacity = src.length;
      var length = this.length;
      size = size | length;
      if (size == length && this._head < this._tail) {
        return this._list.slice(this._head, this._tail);
      }
      var dest = new Array(size);
      var k = 0;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < capacity; i++)
          dest[k++] = src[i];
        for (i = 0; i < this._tail; i++)
          dest[k++] = src[i];
      } else {
        for (i = this._head; i < this._tail; i++)
          dest[k++] = src[i];
      }
      return dest;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head != 0) {
        var newList = this._copyArray(true, this._list.length << 1);
        this._tail = this._list.length;
        this._head = 0;
        this._list = newList;
      } else {
        this._tail = this._list.length;
        this._list.length <<= 1;
      }
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
      var log2 = Math.log(num) / Math.log(2);
      var nextPow2 = 1 << log2 + 1;
      return Math.max(nextPow2, 4);
    };
    module2.exports = Denque;
  }
});

// node_modules/ioredis/built/cluster/DelayQueue.js
var require_DelayQueue = __commonJS({
  "node_modules/ioredis/built/cluster/DelayQueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var Deque = require_denque();
    var debug = (0, utils_1.Debug)("delayqueue");
    var DelayQueue = class {
      constructor() {
        this.queues = {};
        this.timeouts = {};
      }
      /**
       * Add a new item to the queue
       *
       * @param bucket bucket name
       * @param item function that will run later
       * @param options
       */
      push(bucket, item, options) {
        const callback = options.callback || process.nextTick;
        if (!this.queues[bucket]) {
          this.queues[bucket] = new Deque();
        }
        const queue = this.queues[bucket];
        queue.push(item);
        if (!this.timeouts[bucket]) {
          this.timeouts[bucket] = setTimeout(() => {
            callback(() => {
              this.timeouts[bucket] = null;
              this.execute(bucket);
            });
          }, options.timeout);
        }
      }
      execute(bucket) {
        const queue = this.queues[bucket];
        if (!queue) {
          return;
        }
        const { length } = queue;
        if (!length) {
          return;
        }
        debug("send %d commands in %s queue", length, bucket);
        this.queues[bucket] = null;
        while (queue.length > 0) {
          queue.shift()();
        }
      }
    };
    exports.default = DelayQueue;
  }
});

// node_modules/ioredis/built/cluster/index.js
var require_cluster = __commonJS({
  "node_modules/ioredis/built/cluster/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = require_built();
    var events_1 = require("events");
    var redis_errors_1 = require_redis_errors();
    var standard_as_callback_1 = require_built2();
    var Command_1 = require_Command();
    var ClusterAllFailedError_1 = require_ClusterAllFailedError();
    var Redis_1 = require_Redis();
    var ScanStream_1 = require_ScanStream();
    var transaction_1 = require_transaction();
    var utils_1 = require_utils2();
    var applyMixin_1 = require_applyMixin();
    var Commander_1 = require_Commander();
    var ClusterOptions_1 = require_ClusterOptions();
    var ClusterSubscriber_1 = require_ClusterSubscriber();
    var ConnectionPool_1 = require_ConnectionPool();
    var DelayQueue_1 = require_DelayQueue();
    var util_1 = require_util();
    var Deque = require_denque();
    var debug = (0, utils_1.Debug)("cluster");
    var REJECT_OVERWRITTEN_COMMANDS = /* @__PURE__ */ new WeakSet();
    var Cluster = class _Cluster extends Commander_1.default {
      /**
       * Creates an instance of Cluster.
       */
      constructor(startupNodes, options = {}) {
        super();
        this.slots = [];
        this._groupsIds = {};
        this._groupsBySlot = Array(16384);
        this.isCluster = true;
        this.retryAttempts = 0;
        this.delayQueue = new DelayQueue_1.default();
        this.offlineQueue = new Deque();
        this.isRefreshing = false;
        this._autoPipelines = /* @__PURE__ */ new Map();
        this._runningAutoPipelines = /* @__PURE__ */ new Set();
        this._readyDelayedCallbacks = [];
        this.connectionEpoch = 0;
        events_1.EventEmitter.call(this);
        this.startupNodes = startupNodes;
        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);
        if (this.options.redisOptions && this.options.redisOptions.keyPrefix && !this.options.keyPrefix) {
          this.options.keyPrefix = this.options.redisOptions.keyPrefix;
        }
        if (typeof this.options.scaleReads !== "function" && ["all", "master", "slave"].indexOf(this.options.scaleReads) === -1) {
          throw new Error('Invalid option scaleReads "' + this.options.scaleReads + '". Expected "all", "master", "slave" or a custom function');
        }
        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
        this.connectionPool.on("-node", (redis, key) => {
          this.emit("-node", redis);
        });
        this.connectionPool.on("+node", (redis) => {
          this.emit("+node", redis);
        });
        this.connectionPool.on("drain", () => {
          this.setStatus("close");
        });
        this.connectionPool.on("nodeError", (error, key) => {
          this.emit("node error", error, key);
        });
        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
        if (this.options.scripts) {
          Object.entries(this.options.scripts).forEach(([name, definition]) => {
            this.defineCommand(name, definition);
          });
        }
        if (this.options.lazyConnect) {
          this.setStatus("wait");
        } else {
          this.connect().catch((err) => {
            debug("connecting failed: %s", err);
          });
        }
      }
      /**
       * Connect to a cluster
       */
      connect() {
        return new Promise((resolve, reject) => {
          if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
            reject(new Error("Redis is already connecting/connected"));
            return;
          }
          const epoch = ++this.connectionEpoch;
          this.setStatus("connecting");
          this.resolveStartupNodeHostnames().then((nodes) => {
            if (this.connectionEpoch !== epoch) {
              debug("discard connecting after resolving startup nodes because epoch not match: %d != %d", epoch, this.connectionEpoch);
              reject(new redis_errors_1.RedisError("Connection is discarded because a new connection is made"));
              return;
            }
            if (this.status !== "connecting") {
              debug("discard connecting after resolving startup nodes because the status changed to %s", this.status);
              reject(new redis_errors_1.RedisError("Connection is aborted"));
              return;
            }
            this.connectionPool.reset(nodes);
            const readyHandler = () => {
              this.setStatus("ready");
              this.retryAttempts = 0;
              this.executeOfflineCommands();
              this.resetNodesRefreshInterval();
              resolve();
            };
            let closeListener = void 0;
            const refreshListener = () => {
              this.invokeReadyDelayedCallbacks(void 0);
              this.removeListener("close", closeListener);
              this.manuallyClosing = false;
              this.setStatus("connect");
              if (this.options.enableReadyCheck) {
                this.readyCheck((err, fail) => {
                  if (err || fail) {
                    debug("Ready check failed (%s). Reconnecting...", err || fail);
                    if (this.status === "connect") {
                      this.disconnect(true);
                    }
                  } else {
                    readyHandler();
                  }
                });
              } else {
                readyHandler();
              }
            };
            closeListener = () => {
              const error = new Error("None of startup nodes is available");
              this.removeListener("refresh", refreshListener);
              this.invokeReadyDelayedCallbacks(error);
              reject(error);
            };
            this.once("refresh", refreshListener);
            this.once("close", closeListener);
            this.once("close", this.handleCloseEvent.bind(this));
            this.refreshSlotsCache((err) => {
              if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {
                Redis_1.default.prototype.silentEmit.call(this, "error", err);
                this.connectionPool.reset([]);
              }
            });
            this.subscriber.start();
          }).catch((err) => {
            this.setStatus("close");
            this.handleCloseEvent(err);
            this.invokeReadyDelayedCallbacks(err);
            reject(err);
          });
        });
      }
      /**
       * Disconnect from every node in the cluster.
       */
      disconnect(reconnect = false) {
        const status = this.status;
        this.setStatus("disconnecting");
        if (!reconnect) {
          this.manuallyClosing = true;
        }
        if (this.reconnectTimeout && !reconnect) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
          debug("Canceled reconnecting attempts");
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        if (status === "wait") {
          this.setStatus("close");
          this.handleCloseEvent();
        } else {
          this.connectionPool.reset([]);
        }
      }
      /**
       * Quit the cluster gracefully.
       */
      quit(callback) {
        const status = this.status;
        this.setStatus("disconnecting");
        this.manuallyClosing = true;
        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        if (status === "wait") {
          const ret = (0, standard_as_callback_1.default)(Promise.resolve("OK"), callback);
          setImmediate(function() {
            this.setStatus("close");
            this.handleCloseEvent();
          }.bind(this));
          return ret;
        }
        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) => node.quit().catch((err) => {
          if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {
            return "OK";
          }
          throw err;
        }))).then(() => "OK"), callback);
      }
      /**
       * Create a new instance with the same startup nodes and options as the current one.
       *
       * @example
       * ```js
       * var cluster = new Redis.Cluster([{ host: "127.0.0.1", port: "30001" }]);
       * var anotherCluster = cluster.duplicate();
       * ```
       */
      duplicate(overrideStartupNodes = [], overrideOptions = {}) {
        const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);
        const options = Object.assign({}, this.options, overrideOptions);
        return new _Cluster(startupNodes, options);
      }
      /**
       * Get nodes with the specified role
       */
      nodes(role = "all") {
        if (role !== "all" && role !== "master" && role !== "slave") {
          throw new Error('Invalid role "' + role + '". Expected "all", "master" or "slave"');
        }
        return this.connectionPool.getNodes(role);
      }
      /**
       * This is needed in order not to install a listener for each auto pipeline
       *
       * @ignore
       */
      delayUntilReady(callback) {
        this._readyDelayedCallbacks.push(callback);
      }
      /**
       * Get the number of commands queued in automatic pipelines.
       *
       * This is not available (and returns 0) until the cluster is connected and slots information have been received.
       */
      get autoPipelineQueueSize() {
        let queued = 0;
        for (const pipeline of this._autoPipelines.values()) {
          queued += pipeline.length;
        }
        return queued;
      }
      /**
       * Refresh the slot cache
       *
       * @ignore
       */
      refreshSlotsCache(callback) {
        if (this.isRefreshing) {
          if (callback) {
            process.nextTick(callback);
          }
          return;
        }
        this.isRefreshing = true;
        const _this = this;
        const wrapper = (error) => {
          this.isRefreshing = false;
          if (callback) {
            callback(error);
          }
        };
        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());
        let lastNodeError = null;
        function tryNode(index) {
          if (index === nodes.length) {
            const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);
            return wrapper(error);
          }
          const node = nodes[index];
          const key = `${node.options.host}:${node.options.port}`;
          debug("getting slot cache from %s", key);
          _this.getInfoFromNode(node, function(err) {
            switch (_this.status) {
              case "close":
              case "end":
                return wrapper(new Error("Cluster is disconnected."));
              case "disconnecting":
                return wrapper(new Error("Cluster is disconnecting."));
            }
            if (err) {
              _this.emit("node error", err, key);
              lastNodeError = err;
              tryNode(index + 1);
            } else {
              _this.emit("refresh");
              wrapper();
            }
          });
        }
        tryNode(0);
      }
      /**
       * @ignore
       */
      sendCommand(command, stream, node) {
        if (this.status === "wait") {
          this.connect().catch(utils_1.noop);
        }
        if (this.status === "end") {
          command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
          return command.promise;
        }
        let to = this.options.scaleReads;
        if (to !== "master") {
          const isCommandReadOnly = command.isReadOnly || (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "readonly");
          if (!isCommandReadOnly) {
            to = "master";
          }
        }
        let targetSlot = node ? node.slot : command.getSlot();
        const ttl = {};
        const _this = this;
        if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {
          REJECT_OVERWRITTEN_COMMANDS.add(command);
          const reject = command.reject;
          command.reject = function(err) {
            const partialTry = tryConnection.bind(null, true);
            _this.handleError(err, ttl, {
              moved: function(slot, key) {
                debug("command %s is moved to %s", command.name, key);
                targetSlot = Number(slot);
                if (_this.slots[slot]) {
                  _this.slots[slot][0] = key;
                } else {
                  _this.slots[slot] = [key];
                }
                _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(";")];
                _this.connectionPool.findOrCreate(_this.natMapper(key));
                tryConnection();
                debug("refreshing slot caches... (triggered by MOVED error)");
                _this.refreshSlotsCache();
              },
              ask: function(slot, key) {
                debug("command %s is required to ask %s:%s", command.name, key);
                const mapped = _this.natMapper(key);
                _this.connectionPool.findOrCreate(mapped);
                tryConnection(false, `${mapped.host}:${mapped.port}`);
              },
              tryagain: partialTry,
              clusterDown: partialTry,
              connectionClosed: partialTry,
              maxRedirections: function(redirectionError) {
                reject.call(command, redirectionError);
              },
              defaults: function() {
                reject.call(command, err);
              }
            });
          };
        }
        tryConnection();
        function tryConnection(random, asking) {
          if (_this.status === "end") {
            command.reject(new redis_errors_1.AbortError("Cluster is ended."));
            return;
          }
          let redis;
          if (_this.status === "ready" || command.name === "cluster") {
            if (node && node.redis) {
              redis = node.redis;
            } else if (Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", command.name) || Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", command.name)) {
              redis = _this.subscriber.getInstance();
              if (!redis) {
                command.reject(new redis_errors_1.AbortError("No subscriber for the cluster"));
                return;
              }
            } else {
              if (!random) {
                if (typeof targetSlot === "number" && _this.slots[targetSlot]) {
                  const nodeKeys = _this.slots[targetSlot];
                  if (typeof to === "function") {
                    const nodes = nodeKeys.map(function(key) {
                      return _this.connectionPool.getInstanceByKey(key);
                    });
                    redis = to(nodes, command);
                    if (Array.isArray(redis)) {
                      redis = (0, utils_1.sample)(redis);
                    }
                    if (!redis) {
                      redis = nodes[0];
                    }
                  } else {
                    let key;
                    if (to === "all") {
                      key = (0, utils_1.sample)(nodeKeys);
                    } else if (to === "slave" && nodeKeys.length > 1) {
                      key = (0, utils_1.sample)(nodeKeys, 1);
                    } else {
                      key = nodeKeys[0];
                    }
                    redis = _this.connectionPool.getInstanceByKey(key);
                  }
                }
                if (asking) {
                  redis = _this.connectionPool.getInstanceByKey(asking);
                  redis.asking();
                }
              }
              if (!redis) {
                redis = (typeof to === "function" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance("all");
              }
            }
            if (node && !node.redis) {
              node.redis = redis;
            }
          }
          if (redis) {
            redis.sendCommand(command, stream);
          } else if (_this.options.enableOfflineQueue) {
            _this.offlineQueue.push({
              command,
              stream,
              node
            });
          } else {
            command.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"));
          }
        }
        return command.promise;
      }
      sscanStream(key, options) {
        return this.createScanStream("sscan", { key, options });
      }
      sscanBufferStream(key, options) {
        return this.createScanStream("sscanBuffer", { key, options });
      }
      hscanStream(key, options) {
        return this.createScanStream("hscan", { key, options });
      }
      hscanBufferStream(key, options) {
        return this.createScanStream("hscanBuffer", { key, options });
      }
      zscanStream(key, options) {
        return this.createScanStream("zscan", { key, options });
      }
      zscanBufferStream(key, options) {
        return this.createScanStream("zscanBuffer", { key, options });
      }
      /**
       * @ignore
       */
      handleError(error, ttl, handlers) {
        if (typeof ttl.value === "undefined") {
          ttl.value = this.options.maxRedirections;
        } else {
          ttl.value -= 1;
        }
        if (ttl.value <= 0) {
          handlers.maxRedirections(new Error("Too many Cluster redirections. Last error: " + error));
          return;
        }
        const errv = error.message.split(" ");
        if (errv[0] === "MOVED") {
          const timeout = this.options.retryDelayOnMoved;
          if (timeout && typeof timeout === "number") {
            this.delayQueue.push("moved", handlers.moved.bind(null, errv[1], errv[2]), { timeout });
          } else {
            handlers.moved(errv[1], errv[2]);
          }
        } else if (errv[0] === "ASK") {
          handlers.ask(errv[1], errv[2]);
        } else if (errv[0] === "TRYAGAIN") {
          this.delayQueue.push("tryagain", handlers.tryagain, {
            timeout: this.options.retryDelayOnTryAgain
          });
        } else if (errv[0] === "CLUSTERDOWN" && this.options.retryDelayOnClusterDown > 0) {
          this.delayQueue.push("clusterdown", handlers.connectionClosed, {
            timeout: this.options.retryDelayOnClusterDown,
            callback: this.refreshSlotsCache.bind(this)
          });
        } else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === "ready") {
          this.delayQueue.push("failover", handlers.connectionClosed, {
            timeout: this.options.retryDelayOnFailover,
            callback: this.refreshSlotsCache.bind(this)
          });
        } else {
          handlers.defaults();
        }
      }
      resetOfflineQueue() {
        this.offlineQueue = new Deque();
      }
      clearNodesRefreshInterval() {
        if (this.slotsTimer) {
          clearTimeout(this.slotsTimer);
          this.slotsTimer = null;
        }
      }
      resetNodesRefreshInterval() {
        if (this.slotsTimer || !this.options.slotsRefreshInterval) {
          return;
        }
        const nextRound = () => {
          this.slotsTimer = setTimeout(() => {
            debug('refreshing slot caches... (triggered by "slotsRefreshInterval" option)');
            this.refreshSlotsCache(() => {
              nextRound();
            });
          }, this.options.slotsRefreshInterval);
        };
        nextRound();
      }
      /**
       * Change cluster instance's status
       */
      setStatus(status) {
        debug("status: %s -> %s", this.status || "[empty]", status);
        this.status = status;
        process.nextTick(() => {
          this.emit(status);
        });
      }
      /**
       * Called when closed to check whether a reconnection should be made
       */
      handleCloseEvent(reason) {
        if (reason) {
          debug("closed because %s", reason);
        }
        let retryDelay;
        if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === "function") {
          retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
        }
        if (typeof retryDelay === "number") {
          this.setStatus("reconnecting");
          this.reconnectTimeout = setTimeout(() => {
            this.reconnectTimeout = null;
            debug("Cluster is disconnected. Retrying after %dms", retryDelay);
            this.connect().catch(function(err) {
              debug("Got error %s when reconnecting. Ignoring...", err);
            });
          }, retryDelay);
        } else {
          this.setStatus("end");
          this.flushQueue(new Error("None of startup nodes is available"));
        }
      }
      /**
       * Flush offline queue with error.
       */
      flushQueue(error) {
        let item;
        while (item = this.offlineQueue.shift()) {
          item.command.reject(error);
        }
      }
      executeOfflineCommands() {
        if (this.offlineQueue.length) {
          debug("send %d commands in offline queue", this.offlineQueue.length);
          const offlineQueue = this.offlineQueue;
          this.resetOfflineQueue();
          let item;
          while (item = offlineQueue.shift()) {
            this.sendCommand(item.command, item.stream, item.node);
          }
        }
      }
      natMapper(nodeKey) {
        if (this.options.natMap && typeof this.options.natMap === "object") {
          const key = typeof nodeKey === "string" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;
          const mapped = this.options.natMap[key];
          if (mapped) {
            debug("NAT mapping %s -> %O", key, mapped);
            return Object.assign({}, mapped);
          }
        }
        return typeof nodeKey === "string" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;
      }
      getInfoFromNode(redis, callback) {
        if (!redis) {
          return callback(new Error("Node is disconnected"));
        }
        const duplicatedConnection = redis.duplicate({
          enableOfflineQueue: true,
          enableReadyCheck: false,
          retryStrategy: null,
          connectionName: (0, util_1.getConnectionName)("refresher", this.options.redisOptions && this.options.redisOptions.connectionName)
        });
        duplicatedConnection.on("error", utils_1.noop);
        duplicatedConnection.cluster("SLOTS", (0, utils_1.timeout)((err, result) => {
          duplicatedConnection.disconnect();
          if (err) {
            return callback(err);
          }
          if (this.status === "disconnecting" || this.status === "close" || this.status === "end") {
            debug("ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s", result.length, this.status);
            callback();
            return;
          }
          const nodes = [];
          debug("cluster slots result count: %d", result.length);
          for (let i = 0; i < result.length; ++i) {
            const items = result[i];
            const slotRangeStart = items[0];
            const slotRangeEnd = items[1];
            const keys4 = [];
            for (let j2 = 2; j2 < items.length; j2++) {
              if (!items[j2][0]) {
                continue;
              }
              const node = this.natMapper({
                host: items[j2][0],
                port: items[j2][1]
              });
              node.readOnly = j2 !== 2;
              nodes.push(node);
              keys4.push(node.host + ":" + node.port);
            }
            debug("cluster slots result [%d]: slots %d~%d served by %s", i, slotRangeStart, slotRangeEnd, keys4);
            for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {
              this.slots[slot] = keys4;
            }
          }
          this._groupsIds = /* @__PURE__ */ Object.create(null);
          let j = 0;
          for (let i = 0; i < 16384; i++) {
            const target = (this.slots[i] || []).join(";");
            if (!target.length) {
              this._groupsBySlot[i] = void 0;
              continue;
            }
            if (!this._groupsIds[target]) {
              this._groupsIds[target] = ++j;
            }
            this._groupsBySlot[i] = this._groupsIds[target];
          }
          this.connectionPool.reset(nodes);
          callback();
        }, this.options.slotsRefreshTimeout));
      }
      invokeReadyDelayedCallbacks(err) {
        for (const c of this._readyDelayedCallbacks) {
          process.nextTick(c, err);
        }
        this._readyDelayedCallbacks = [];
      }
      /**
       * Check whether Cluster is able to process commands
       */
      readyCheck(callback) {
        this.cluster("INFO", (err, res) => {
          if (err) {
            return callback(err);
          }
          if (typeof res !== "string") {
            return callback();
          }
          let state;
          const lines = res.split("\r\n");
          for (let i = 0; i < lines.length; ++i) {
            const parts = lines[i].split(":");
            if (parts[0] === "cluster_state") {
              state = parts[1];
              break;
            }
          }
          if (state === "fail") {
            debug("cluster state not ok (%s)", state);
            callback(null, state);
          } else {
            callback();
          }
        });
      }
      resolveSrv(hostname) {
        return new Promise((resolve, reject) => {
          this.options.resolveSrv(hostname, (err, records) => {
            if (err) {
              return reject(err);
            }
            const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));
            function tryFirstOne(err2) {
              if (!sortedKeys.length) {
                return reject(err2);
              }
              const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);
              if (!group.records.length) {
                sortedKeys.shift();
              }
              self.dnsLookup(record.name).then((host) => resolve({
                host,
                port: record.port
              }), tryFirstOne);
            }
            tryFirstOne();
          });
        });
      }
      dnsLookup(hostname) {
        return new Promise((resolve, reject) => {
          this.options.dnsLookup(hostname, (err, address) => {
            if (err) {
              debug("failed to resolve hostname %s to IP: %s", hostname, err.message);
              reject(err);
            } else {
              debug("resolved hostname %s to IP %s", hostname, address);
              resolve(address);
            }
          });
        });
      }
      /**
       * Normalize startup nodes, and resolving hostnames to IPs.
       *
       * This process happens every time when #connect() is called since
       * #startupNodes and DNS records may chanage.
       */
      async resolveStartupNodeHostnames() {
        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
          throw new Error("`startupNodes` should contain at least one node.");
        }
        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);
        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);
        if (hostnames.length === 0) {
          return startupNodes;
        }
        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));
        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);
        return startupNodes.map((node) => {
          const config = hostnameToConfig.get(node.host);
          if (!config) {
            return node;
          }
          if (this.options.useSRVRecords) {
            return Object.assign({}, node, config);
          }
          return Object.assign({}, node, { host: config });
        });
      }
      createScanStream(command, { key, options = {} }) {
        return new ScanStream_1.default({
          objectMode: true,
          key,
          redis: this,
          command,
          ...options
        });
      }
    };
    (0, applyMixin_1.default)(Cluster, events_1.EventEmitter);
    (0, transaction_1.addTransactionSupport)(Cluster.prototype);
    exports.default = Cluster;
  }
});

// node_modules/ioredis/built/connectors/AbstractConnector.js
var require_AbstractConnector = __commonJS({
  "node_modules/ioredis/built/connectors/AbstractConnector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var debug = (0, utils_1.Debug)("AbstractConnector");
    var AbstractConnector = class {
      constructor(disconnectTimeout) {
        this.connecting = false;
        this.disconnectTimeout = disconnectTimeout;
      }
      check(info) {
        return true;
      }
      disconnect() {
        this.connecting = false;
        if (this.stream) {
          const stream = this.stream;
          const timeout = setTimeout(() => {
            debug("stream %s:%s still open, destroying it", stream.remoteAddress, stream.remotePort);
            stream.destroy();
          }, this.disconnectTimeout);
          stream.on("close", () => clearTimeout(timeout));
          stream.end();
        }
      }
    };
    exports.default = AbstractConnector;
  }
});

// node_modules/ioredis/built/connectors/StandaloneConnector.js
var require_StandaloneConnector = __commonJS({
  "node_modules/ioredis/built/connectors/StandaloneConnector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = require("net");
    var tls_1 = require("tls");
    var utils_1 = require_utils2();
    var AbstractConnector_1 = require_AbstractConnector();
    var StandaloneConnector = class extends AbstractConnector_1.default {
      constructor(options) {
        super(options.disconnectTimeout);
        this.options = options;
      }
      connect(_) {
        const { options } = this;
        this.connecting = true;
        let connectionOptions;
        if ("path" in options && options.path) {
          connectionOptions = {
            path: options.path
          };
        } else {
          connectionOptions = {};
          if ("port" in options && options.port != null) {
            connectionOptions.port = options.port;
          }
          if ("host" in options && options.host != null) {
            connectionOptions.host = options.host;
          }
          if ("family" in options && options.family != null) {
            connectionOptions.family = options.family;
          }
        }
        if (options.tls) {
          Object.assign(connectionOptions, options.tls);
        }
        return new Promise((resolve, reject) => {
          process.nextTick(() => {
            if (!this.connecting) {
              reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
              return;
            }
            try {
              if (options.tls) {
                this.stream = (0, tls_1.connect)(connectionOptions);
              } else {
                this.stream = (0, net_1.createConnection)(connectionOptions);
              }
            } catch (err) {
              reject(err);
              return;
            }
            this.stream.once("error", (err) => {
              this.firstError = err;
            });
            resolve(this.stream);
          });
        });
      }
    };
    exports.default = StandaloneConnector;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js
var require_SentinelIterator = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSentinelEql(a, b) {
      return (a.host || "127.0.0.1") === (b.host || "127.0.0.1") && (a.port || 26379) === (b.port || 26379);
    }
    var SentinelIterator = class {
      constructor(sentinels) {
        this.cursor = 0;
        this.sentinels = sentinels.slice(0);
      }
      next() {
        const done = this.cursor >= this.sentinels.length;
        return { done, value: done ? void 0 : this.sentinels[this.cursor++] };
      }
      reset(moveCurrentEndpointToFirst) {
        if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {
          this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));
        }
        this.cursor = 0;
      }
      add(sentinel) {
        for (let i = 0; i < this.sentinels.length; i++) {
          if (isSentinelEql(sentinel, this.sentinels[i])) {
            return false;
          }
        }
        this.sentinels.push(sentinel);
        return true;
      }
      toString() {
        return `${JSON.stringify(this.sentinels)} @${this.cursor}`;
      }
    };
    exports.default = SentinelIterator;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js
var require_FailoverDetector = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FailoverDetector = void 0;
    var utils_1 = require_utils2();
    var debug = (0, utils_1.Debug)("FailoverDetector");
    var CHANNEL_NAME = "+switch-master";
    var FailoverDetector = class {
      // sentinels can't be used for regular commands after this
      constructor(connector, sentinels) {
        this.isDisconnected = false;
        this.connector = connector;
        this.sentinels = sentinels;
      }
      cleanup() {
        this.isDisconnected = true;
        for (const sentinel of this.sentinels) {
          sentinel.client.disconnect();
        }
      }
      async subscribe() {
        debug("Starting FailoverDetector");
        const promises = [];
        for (const sentinel of this.sentinels) {
          const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {
            debug("Failed to subscribe to failover messages on sentinel %s:%s (%s)", sentinel.address.host || "127.0.0.1", sentinel.address.port || 26739, err.message);
          });
          promises.push(promise);
          sentinel.client.on("message", (channel) => {
            if (!this.isDisconnected && channel === CHANNEL_NAME) {
              this.disconnect();
            }
          });
        }
        await Promise.all(promises);
      }
      disconnect() {
        this.isDisconnected = true;
        debug("Failover detected, disconnecting");
        this.connector.disconnect();
      }
    };
    exports.FailoverDetector = FailoverDetector;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/index.js
var require_SentinelConnector = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SentinelIterator = void 0;
    var net_1 = require("net");
    var utils_1 = require_utils2();
    var tls_1 = require("tls");
    var SentinelIterator_1 = require_SentinelIterator();
    exports.SentinelIterator = SentinelIterator_1.default;
    var AbstractConnector_1 = require_AbstractConnector();
    var Redis_1 = require_Redis();
    var FailoverDetector_1 = require_FailoverDetector();
    var debug = (0, utils_1.Debug)("SentinelConnector");
    var SentinelConnector = class extends AbstractConnector_1.default {
      constructor(options) {
        super(options.disconnectTimeout);
        this.options = options;
        this.emitter = null;
        this.failoverDetector = null;
        if (!this.options.sentinels.length) {
          throw new Error("Requires at least one sentinel to connect to.");
        }
        if (!this.options.name) {
          throw new Error("Requires the name of master.");
        }
        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);
      }
      check(info) {
        const roleMatches = !info.role || this.options.role === info.role;
        if (!roleMatches) {
          debug("role invalid, expected %s, but got %s", this.options.role, info.role);
          this.sentinelIterator.next();
          this.sentinelIterator.next();
          this.sentinelIterator.reset(true);
        }
        return roleMatches;
      }
      disconnect() {
        super.disconnect();
        if (this.failoverDetector) {
          this.failoverDetector.cleanup();
        }
      }
      connect(eventEmitter) {
        this.connecting = true;
        this.retryAttempts = 0;
        let lastError;
        const connectToNext = async () => {
          const endpoint = this.sentinelIterator.next();
          if (endpoint.done) {
            this.sentinelIterator.reset(false);
            const retryDelay = typeof this.options.sentinelRetryStrategy === "function" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;
            let errorMsg = typeof retryDelay !== "number" ? "All sentinels are unreachable and retry is disabled." : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;
            if (lastError) {
              errorMsg += ` Last error: ${lastError.message}`;
            }
            debug(errorMsg);
            const error = new Error(errorMsg);
            if (typeof retryDelay === "number") {
              eventEmitter("error", error);
              await new Promise((resolve) => setTimeout(resolve, retryDelay));
              return connectToNext();
            } else {
              throw error;
            }
          }
          let resolved = null;
          let err = null;
          try {
            resolved = await this.resolve(endpoint.value);
          } catch (error) {
            err = error;
          }
          if (!this.connecting) {
            throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);
          }
          const endpointAddress = endpoint.value.host + ":" + endpoint.value.port;
          if (resolved) {
            debug("resolved: %s:%s from sentinel %s", resolved.host, resolved.port, endpointAddress);
            if (this.options.enableTLSForSentinelMode && this.options.tls) {
              Object.assign(resolved, this.options.tls);
              this.stream = (0, tls_1.connect)(resolved);
              this.stream.once("secureConnect", this.initFailoverDetector.bind(this));
            } else {
              this.stream = (0, net_1.createConnection)(resolved);
              this.stream.once("connect", this.initFailoverDetector.bind(this));
            }
            this.stream.once("error", (err2) => {
              this.firstError = err2;
            });
            return this.stream;
          } else {
            const errorMsg = err ? "failed to connect to sentinel " + endpointAddress + " because " + err.message : "connected to sentinel " + endpointAddress + " successfully, but got an invalid reply: " + resolved;
            debug(errorMsg);
            eventEmitter("sentinelError", new Error(errorMsg));
            if (err) {
              lastError = err;
            }
            return connectToNext();
          }
        };
        return connectToNext();
      }
      async updateSentinels(client) {
        if (!this.options.updateSentinels) {
          return;
        }
        const result = await client.sentinel("sentinels", this.options.name);
        if (!Array.isArray(result)) {
          return;
        }
        result.map(utils_1.packObject).forEach((sentinel) => {
          const flags = sentinel.flags ? sentinel.flags.split(",") : [];
          if (flags.indexOf("disconnected") === -1 && sentinel.ip && sentinel.port) {
            const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));
            if (this.sentinelIterator.add(endpoint)) {
              debug("adding sentinel %s:%s", endpoint.host, endpoint.port);
            }
          }
        });
        debug("Updated internal sentinels: %s", this.sentinelIterator);
      }
      async resolveMaster(client) {
        const result = await client.sentinel("get-master-addr-by-name", this.options.name);
        await this.updateSentinels(client);
        return this.sentinelNatResolve(Array.isArray(result) ? { host: result[0], port: Number(result[1]) } : null);
      }
      async resolveSlave(client) {
        const result = await client.sentinel("slaves", this.options.name);
        if (!Array.isArray(result)) {
          return null;
        }
        const availableSlaves = result.map(utils_1.packObject).filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));
        return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));
      }
      sentinelNatResolve(item) {
        if (!item || !this.options.natMap)
          return item;
        return this.options.natMap[`${item.host}:${item.port}`] || item;
      }
      connectToSentinel(endpoint, options) {
        const redis = new Redis_1.default({
          port: endpoint.port || 26379,
          host: endpoint.host,
          username: this.options.sentinelUsername || null,
          password: this.options.sentinelPassword || null,
          family: endpoint.family || // @ts-expect-error
          ("path" in this.options && this.options.path ? void 0 : (
            // @ts-expect-error
            this.options.family
          )),
          tls: this.options.sentinelTLS,
          retryStrategy: null,
          enableReadyCheck: false,
          connectTimeout: this.options.connectTimeout,
          commandTimeout: this.options.sentinelCommandTimeout,
          ...options
        });
        return redis;
      }
      async resolve(endpoint) {
        const client = this.connectToSentinel(endpoint);
        client.on("error", noop);
        try {
          if (this.options.role === "slave") {
            return await this.resolveSlave(client);
          } else {
            return await this.resolveMaster(client);
          }
        } finally {
          client.disconnect();
        }
      }
      async initFailoverDetector() {
        var _a2;
        if (!this.options.failoverDetector) {
          return;
        }
        this.sentinelIterator.reset(true);
        const sentinels = [];
        while (sentinels.length < this.options.sentinelMaxConnections) {
          const { done, value } = this.sentinelIterator.next();
          if (done) {
            break;
          }
          const client = this.connectToSentinel(value, {
            lazyConnect: true,
            retryStrategy: this.options.sentinelReconnectStrategy
          });
          client.on("reconnecting", () => {
            var _a3;
            (_a3 = this.emitter) === null || _a3 === void 0 ? void 0 : _a3.emit("sentinelReconnecting");
          });
          sentinels.push({ address: value, client });
        }
        this.sentinelIterator.reset(false);
        if (this.failoverDetector) {
          this.failoverDetector.cleanup();
        }
        this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);
        await this.failoverDetector.subscribe();
        (_a2 = this.emitter) === null || _a2 === void 0 ? void 0 : _a2.emit("failoverSubscribed");
      }
    };
    exports.default = SentinelConnector;
    function selectPreferredSentinel(availableSlaves, preferredSlaves) {
      if (availableSlaves.length === 0) {
        return null;
      }
      let selectedSlave;
      if (typeof preferredSlaves === "function") {
        selectedSlave = preferredSlaves(availableSlaves);
      } else if (preferredSlaves !== null && typeof preferredSlaves === "object") {
        const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves];
        preferredSlavesArray.sort((a, b) => {
          if (!a.prio) {
            a.prio = 1;
          }
          if (!b.prio) {
            b.prio = 1;
          }
          if (a.prio < b.prio) {
            return -1;
          }
          if (a.prio > b.prio) {
            return 1;
          }
          return 0;
        });
        for (let p = 0; p < preferredSlavesArray.length; p++) {
          for (let a = 0; a < availableSlaves.length; a++) {
            const slave = availableSlaves[a];
            if (slave.ip === preferredSlavesArray[p].ip) {
              if (slave.port === preferredSlavesArray[p].port) {
                selectedSlave = slave;
                break;
              }
            }
          }
          if (selectedSlave) {
            break;
          }
        }
      }
      if (!selectedSlave) {
        selectedSlave = (0, utils_1.sample)(availableSlaves);
      }
      return addressResponseToAddress(selectedSlave);
    }
    function addressResponseToAddress(input) {
      return { host: input.ip, port: Number(input.port) };
    }
    function noop() {
    }
  }
});

// node_modules/ioredis/built/connectors/index.js
var require_connectors = __commonJS({
  "node_modules/ioredis/built/connectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SentinelConnector = exports.StandaloneConnector = void 0;
    var StandaloneConnector_1 = require_StandaloneConnector();
    exports.StandaloneConnector = StandaloneConnector_1.default;
    var SentinelConnector_1 = require_SentinelConnector();
    exports.SentinelConnector = SentinelConnector_1.default;
  }
});

// node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js
var require_MaxRetriesPerRequestError = __commonJS({
  "node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var redis_errors_1 = require_redis_errors();
    var MaxRetriesPerRequestError = class extends redis_errors_1.AbortError {
      constructor(maxRetriesPerRequest) {
        const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to "maxRetriesPerRequest" option for details.`;
        super(message);
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
    };
    exports.default = MaxRetriesPerRequestError;
  }
});

// node_modules/ioredis/built/errors/index.js
var require_errors = __commonJS({
  "node_modules/ioredis/built/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxRetriesPerRequestError = void 0;
    var MaxRetriesPerRequestError_1 = require_MaxRetriesPerRequestError();
    exports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;
  }
});

// node_modules/redis-parser/lib/parser.js
var require_parser = __commonJS({
  "node_modules/redis-parser/lib/parser.js"(exports, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var StringDecoder = require("string_decoder").StringDecoder;
    var decoder = new StringDecoder();
    var errors = require_redis_errors();
    var ReplyError = errors.ReplyError;
    var ParserError = errors.ParserError;
    var bufferPool = Buffer2.allocUnsafe(32 * 1024);
    var bufferOffset = 0;
    var interval = null;
    var counter = 0;
    var notDecreased = 0;
    function parseSimpleNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number2 = 0;
      var sign = 1;
      if (parser.buffer[offset] === 45) {
        sign = -1;
        offset++;
      }
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return sign * number2;
        }
        number2 = number2 * 10 + (c1 - 48);
      }
    }
    function parseStringNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number2 = 0;
      var res = "";
      if (parser.buffer[offset] === 45) {
        res += "-";
        offset++;
      }
      while (offset < length) {
        var c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          if (number2 !== 0) {
            res += number2;
          }
          return res;
        } else if (number2 > 429496728) {
          res += number2 * 10 + (c1 - 48);
          number2 = 0;
        } else if (c1 === 48 && number2 === 0) {
          res += 0;
        } else {
          number2 = number2 * 10 + (c1 - 48);
        }
      }
    }
    function parseSimpleString(parser) {
      const start = parser.offset;
      const buffer = parser.buffer;
      const length = buffer.length - 1;
      var offset = start;
      while (offset < length) {
        if (buffer[offset++] === 13) {
          parser.offset = offset + 1;
          if (parser.optionReturnBuffers === true) {
            return parser.buffer.slice(start, offset - 1);
          }
          return parser.buffer.toString("utf8", start, offset - 1);
        }
      }
    }
    function parseLength(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number2 = 0;
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return number2;
        }
        number2 = number2 * 10 + (c1 - 48);
      }
    }
    function parseInteger(parser) {
      if (parser.optionStringNumbers === true) {
        return parseStringNumbers(parser);
      }
      return parseSimpleNumbers(parser);
    }
    function parseBulkString(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const offset = parser.offset + length;
      if (offset + 2 > parser.buffer.length) {
        parser.bigStrSize = offset + 2;
        parser.totalChunkSize = parser.buffer.length;
        parser.bufferCache.push(parser.buffer);
        return;
      }
      const start = parser.offset;
      parser.offset = offset + 2;
      if (parser.optionReturnBuffers === true) {
        return parser.buffer.slice(start, offset);
      }
      return parser.buffer.toString("utf8", start, offset);
    }
    function parseError(parser) {
      var string3 = parseSimpleString(parser);
      if (string3 !== void 0) {
        if (parser.optionReturnBuffers === true) {
          string3 = string3.toString();
        }
        return new ReplyError(string3);
      }
    }
    function handleError(parser, type3) {
      const err = new ParserError(
        "Protocol error, got " + JSON.stringify(String.fromCharCode(type3)) + " as reply type byte",
        JSON.stringify(parser.buffer),
        parser.offset
      );
      parser.buffer = null;
      parser.returnFatalError(err);
    }
    function parseArray(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const responses = new Array(length);
      return parseArrayElements(parser, responses, 0);
    }
    function pushArrayCache(parser, array2, pos) {
      parser.arrayCache.push(array2);
      parser.arrayPos.push(pos);
    }
    function parseArrayChunks(parser) {
      const tmp = parser.arrayCache.pop();
      var pos = parser.arrayPos.pop();
      if (parser.arrayCache.length) {
        const res = parseArrayChunks(parser);
        if (res === void 0) {
          pushArrayCache(parser, tmp, pos);
          return;
        }
        tmp[pos++] = res;
      }
      return parseArrayElements(parser, tmp, pos);
    }
    function parseArrayElements(parser, responses, i) {
      const bufferLength = parser.buffer.length;
      while (i < responses.length) {
        const offset = parser.offset;
        if (parser.offset >= bufferLength) {
          pushArrayCache(parser, responses, i);
          return;
        }
        const response = parseType(parser, parser.buffer[parser.offset++]);
        if (response === void 0) {
          if (!(parser.arrayCache.length || parser.bufferCache.length)) {
            parser.offset = offset;
          }
          pushArrayCache(parser, responses, i);
          return;
        }
        responses[i] = response;
        i++;
      }
      return responses;
    }
    function parseType(parser, type3) {
      switch (type3) {
        case 36:
          return parseBulkString(parser);
        case 43:
          return parseSimpleString(parser);
        case 42:
          return parseArray(parser);
        case 58:
          return parseInteger(parser);
        case 45:
          return parseError(parser);
        default:
          return handleError(parser, type3);
      }
    }
    function decreaseBufferPool() {
      if (bufferPool.length > 50 * 1024) {
        if (counter === 1 || notDecreased > counter * 2) {
          const minSliceLen = Math.floor(bufferPool.length / 10);
          const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
          bufferOffset = 0;
          bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
        } else {
          notDecreased++;
          counter--;
        }
      } else {
        clearInterval(interval);
        counter = 0;
        notDecreased = 0;
        interval = null;
      }
    }
    function resizeBuffer(length) {
      if (bufferPool.length < length + bufferOffset) {
        const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
        if (bufferOffset > 1024 * 1024 * 111) {
          bufferOffset = 1024 * 1024 * 50;
        }
        bufferPool = Buffer2.allocUnsafe(length * multiplier + bufferOffset);
        bufferOffset = 0;
        counter++;
        if (interval === null) {
          interval = setInterval(decreaseBufferPool, 50);
        }
      }
    }
    function concatBulkString(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      var res = decoder.write(list[0].slice(oldOffset));
      for (var i = 1; i < chunks - 1; i++) {
        res += decoder.write(list[i]);
      }
      res += decoder.end(list[i].slice(0, offset - 2));
      return res;
    }
    function concatBulkBuffer(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      const length = parser.bigStrSize - oldOffset - 2;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].slice(oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      resizeBuffer(length);
      const start = bufferOffset;
      list[0].copy(bufferPool, start, oldOffset, list[0].length);
      bufferOffset += list[0].length - oldOffset;
      for (var i = 1; i < chunks - 1; i++) {
        list[i].copy(bufferPool, bufferOffset);
        bufferOffset += list[i].length;
      }
      list[i].copy(bufferPool, bufferOffset, 0, offset - 2);
      bufferOffset += offset - 2;
      return bufferPool.slice(start, bufferOffset);
    }
    var JavascriptRedisParser = class {
      /**
       * Javascript Redis Parser constructor
       * @param {{returnError: Function, returnReply: Function, returnFatalError?: Function, returnBuffers: boolean, stringNumbers: boolean }} options
       * @constructor
       */
      constructor(options) {
        if (!options) {
          throw new TypeError("Options are mandatory.");
        }
        if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
          throw new TypeError("The returnReply and returnError options have to be functions.");
        }
        this.setReturnBuffers(!!options.returnBuffers);
        this.setStringNumbers(!!options.stringNumbers);
        this.returnError = options.returnError;
        this.returnFatalError = options.returnFatalError || options.returnError;
        this.returnReply = options.returnReply;
        this.reset();
      }
      /**
       * Reset the parser values to the initial state
       *
       * @returns {undefined}
       */
      reset() {
        this.offset = 0;
        this.buffer = null;
        this.bigStrSize = 0;
        this.totalChunkSize = 0;
        this.bufferCache = [];
        this.arrayCache = [];
        this.arrayPos = [];
      }
      /**
       * Set the returnBuffers option
       *
       * @param {boolean} returnBuffers
       * @returns {undefined}
       */
      setReturnBuffers(returnBuffers) {
        if (typeof returnBuffers !== "boolean") {
          throw new TypeError("The returnBuffers argument has to be a boolean");
        }
        this.optionReturnBuffers = returnBuffers;
      }
      /**
       * Set the stringNumbers option
       *
       * @param {boolean} stringNumbers
       * @returns {undefined}
       */
      setStringNumbers(stringNumbers) {
        if (typeof stringNumbers !== "boolean") {
          throw new TypeError("The stringNumbers argument has to be a boolean");
        }
        this.optionStringNumbers = stringNumbers;
      }
      /**
       * Parse the redis buffer
       * @param {Buffer} buffer
       * @returns {undefined}
       */
      execute(buffer) {
        if (this.buffer === null) {
          this.buffer = buffer;
          this.offset = 0;
        } else if (this.bigStrSize === 0) {
          const oldLength = this.buffer.length;
          const remainingLength = oldLength - this.offset;
          const newBuffer = Buffer2.allocUnsafe(remainingLength + buffer.length);
          this.buffer.copy(newBuffer, 0, this.offset, oldLength);
          buffer.copy(newBuffer, remainingLength, 0, buffer.length);
          this.buffer = newBuffer;
          this.offset = 0;
          if (this.arrayCache.length) {
            const arr = parseArrayChunks(this);
            if (arr === void 0) {
              return;
            }
            this.returnReply(arr);
          }
        } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {
          this.bufferCache.push(buffer);
          var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
          this.bigStrSize = 0;
          this.bufferCache = [];
          this.buffer = buffer;
          if (this.arrayCache.length) {
            this.arrayCache[0][this.arrayPos[0]++] = tmp;
            tmp = parseArrayChunks(this);
            if (tmp === void 0) {
              return;
            }
          }
          this.returnReply(tmp);
        } else {
          this.bufferCache.push(buffer);
          this.totalChunkSize += buffer.length;
          return;
        }
        while (this.offset < this.buffer.length) {
          const offset = this.offset;
          const type3 = this.buffer[this.offset++];
          const response = parseType(this, type3);
          if (response === void 0) {
            if (!(this.arrayCache.length || this.bufferCache.length)) {
              this.offset = offset;
            }
            return;
          }
          if (type3 === 45) {
            this.returnError(response);
          } else {
            this.returnReply(response);
          }
        }
        this.buffer = null;
      }
    };
    module2.exports = JavascriptRedisParser;
  }
});

// node_modules/redis-parser/index.js
var require_redis_parser = __commonJS({
  "node_modules/redis-parser/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_parser();
  }
});

// node_modules/ioredis/built/SubscriptionSet.js
var require_SubscriptionSet = __commonJS({
  "node_modules/ioredis/built/SubscriptionSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SubscriptionSet = class {
      constructor() {
        this.set = {
          subscribe: {},
          psubscribe: {},
          ssubscribe: {}
        };
      }
      add(set, channel) {
        this.set[mapSet(set)][channel] = true;
      }
      del(set, channel) {
        delete this.set[mapSet(set)][channel];
      }
      channels(set) {
        return Object.keys(this.set[mapSet(set)]);
      }
      isEmpty() {
        return this.channels("subscribe").length === 0 && this.channels("psubscribe").length === 0 && this.channels("ssubscribe").length === 0;
      }
    };
    exports.default = SubscriptionSet;
    function mapSet(set) {
      if (set === "unsubscribe") {
        return "subscribe";
      }
      if (set === "punsubscribe") {
        return "psubscribe";
      }
      if (set === "sunsubscribe") {
        return "ssubscribe";
      }
      return set;
    }
  }
});

// node_modules/ioredis/built/DataHandler.js
var require_DataHandler = __commonJS({
  "node_modules/ioredis/built/DataHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Command_1 = require_Command();
    var utils_1 = require_utils2();
    var RedisParser = require_redis_parser();
    var SubscriptionSet_1 = require_SubscriptionSet();
    var debug = (0, utils_1.Debug)("dataHandler");
    var DataHandler = class {
      constructor(redis, parserOptions) {
        this.redis = redis;
        const parser = new RedisParser({
          stringNumbers: parserOptions.stringNumbers,
          returnBuffers: true,
          returnError: (err) => {
            this.returnError(err);
          },
          returnFatalError: (err) => {
            this.returnFatalError(err);
          },
          returnReply: (reply) => {
            this.returnReply(reply);
          }
        });
        redis.stream.on("data", (data) => {
          parser.execute(data);
        });
      }
      returnFatalError(err) {
        err.message += ". Please report this.";
        this.redis.recoverFromFatalError(err, err, { offlineQueue: false });
      }
      returnError(err) {
        const item = this.shiftCommand(err);
        if (!item) {
          return;
        }
        err.command = {
          name: item.command.name,
          args: item.command.args
        };
        this.redis.handleReconnection(err, item);
      }
      returnReply(reply) {
        if (this.handleMonitorReply(reply)) {
          return;
        }
        if (this.handleSubscriberReply(reply)) {
          return;
        }
        const item = this.shiftCommand(reply);
        if (!item) {
          return;
        }
        if (Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", item.command.name)) {
          this.redis.condition.subscriber = new SubscriptionSet_1.default();
          this.redis.condition.subscriber.add(item.command.name, reply[1].toString());
          if (!fillSubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
        } else if (Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", item.command.name)) {
          if (!fillUnsubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
        } else {
          item.command.resolve(reply);
        }
      }
      handleSubscriberReply(reply) {
        if (!this.redis.condition.subscriber) {
          return false;
        }
        const replyType = Array.isArray(reply) ? reply[0].toString() : null;
        debug('receive reply "%s" in subscriber mode', replyType);
        switch (replyType) {
          case "message":
            if (this.redis.listeners("message").length > 0) {
              this.redis.emit("message", reply[1].toString(), reply[2] ? reply[2].toString() : "");
            }
            this.redis.emit("messageBuffer", reply[1], reply[2]);
            break;
          case "pmessage": {
            const pattern = reply[1].toString();
            if (this.redis.listeners("pmessage").length > 0) {
              this.redis.emit("pmessage", pattern, reply[2].toString(), reply[3].toString());
            }
            this.redis.emit("pmessageBuffer", pattern, reply[2], reply[3]);
            break;
          }
          case "smessage": {
            if (this.redis.listeners("smessage").length > 0) {
              this.redis.emit("smessage", reply[1].toString(), reply[2] ? reply[2].toString() : "");
            }
            this.redis.emit("smessageBuffer", reply[1], reply[2]);
            break;
          }
          case "ssubscribe":
          case "subscribe":
          case "psubscribe": {
            const channel = reply[1].toString();
            this.redis.condition.subscriber.add(replyType, channel);
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            if (!fillSubCommand(item.command, reply[2])) {
              this.redis.commandQueue.unshift(item);
            }
            break;
          }
          case "sunsubscribe":
          case "unsubscribe":
          case "punsubscribe": {
            const channel = reply[1] ? reply[1].toString() : null;
            if (channel) {
              this.redis.condition.subscriber.del(replyType, channel);
            }
            const count = reply[2];
            if (Number(count) === 0) {
              this.redis.condition.subscriber = false;
            }
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            if (!fillUnsubCommand(item.command, count)) {
              this.redis.commandQueue.unshift(item);
            }
            break;
          }
          default: {
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            item.command.resolve(reply);
          }
        }
        return true;
      }
      handleMonitorReply(reply) {
        if (this.redis.status !== "monitoring") {
          return false;
        }
        const replyStr = reply.toString();
        if (replyStr === "OK") {
          return false;
        }
        const len = replyStr.indexOf(" ");
        const timestamp = replyStr.slice(0, len);
        const argIndex = replyStr.indexOf('"');
        const args = replyStr.slice(argIndex + 1, -1).split('" "').map((elem) => elem.replace(/\\"/g, '"'));
        const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(" ");
        this.redis.emit("monitor", timestamp, args, dbAndSource[1], dbAndSource[0]);
        return true;
      }
      shiftCommand(reply) {
        const item = this.redis.commandQueue.shift();
        if (!item) {
          const message = "Command queue state error. If you can reproduce this, please report it.";
          const error = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));
          this.redis.emit("error", error);
          return null;
        }
        return item;
      }
    };
    exports.default = DataHandler;
    var remainingRepliesMap = /* @__PURE__ */ new WeakMap();
    function fillSubCommand(command, count) {
      let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;
      remainingReplies -= 1;
      if (remainingReplies <= 0) {
        command.resolve(count);
        remainingRepliesMap.delete(command);
        return true;
      }
      remainingRepliesMap.set(command, remainingReplies);
      return false;
    }
    function fillUnsubCommand(command, count) {
      let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;
      if (remainingReplies === 0) {
        if (Number(count) === 0) {
          remainingRepliesMap.delete(command);
          command.resolve(count);
          return true;
        }
        return false;
      }
      remainingReplies -= 1;
      if (remainingReplies <= 0) {
        command.resolve(count);
        return true;
      }
      remainingRepliesMap.set(command, remainingReplies);
      return false;
    }
  }
});

// node_modules/ioredis/built/redis/event_handler.js
var require_event_handler = __commonJS({
  "node_modules/ioredis/built/redis/event_handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = void 0;
    var redis_errors_1 = require_redis_errors();
    var Command_1 = require_Command();
    var errors_1 = require_errors();
    var utils_1 = require_utils2();
    var DataHandler_1 = require_DataHandler();
    var debug = (0, utils_1.Debug)("connection");
    function connectHandler(self) {
      return function() {
        self.setStatus("connect");
        self.resetCommandQueue();
        let flushed = false;
        const { connectionEpoch } = self;
        if (self.condition.auth) {
          self.auth(self.condition.auth, function(err) {
            if (connectionEpoch !== self.connectionEpoch) {
              return;
            }
            if (err) {
              if (err.message.indexOf("no password is set") !== -1) {
                console.warn("[WARN] Redis server does not require a password, but a password was supplied.");
              } else if (err.message.indexOf("without any password configured for the default user") !== -1) {
                console.warn("[WARN] This Redis server's `default` user does not require a password, but a password was supplied");
              } else if (err.message.indexOf("wrong number of arguments for 'auth' command") !== -1) {
                console.warn(`[ERROR] The server returned "wrong number of arguments for 'auth' command". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);
              } else {
                flushed = true;
                self.recoverFromFatalError(err, err);
              }
            }
          });
        }
        if (self.condition.select) {
          self.select(self.condition.select).catch((err) => {
            self.silentEmit("error", err);
          });
        }
        if (!self.options.enableReadyCheck) {
          exports.readyHandler(self)();
        }
        new DataHandler_1.default(self, {
          stringNumbers: self.options.stringNumbers
        });
        if (self.options.enableReadyCheck) {
          self._readyCheck(function(err, info) {
            if (connectionEpoch !== self.connectionEpoch) {
              return;
            }
            if (err) {
              if (!flushed) {
                self.recoverFromFatalError(new Error("Ready check failed: " + err.message), err);
              }
            } else {
              if (self.connector.check(info)) {
                exports.readyHandler(self)();
              } else {
                self.disconnect(true);
              }
            }
          });
        }
      };
    }
    exports.connectHandler = connectHandler;
    function abortError(command) {
      const err = new redis_errors_1.AbortError("Command aborted due to connection close");
      err.command = {
        name: command.name,
        args: command.args
      };
      return err;
    }
    function abortIncompletePipelines(commandQueue) {
      var _a2;
      let expectedIndex = 0;
      for (let i = 0; i < commandQueue.length; ) {
        const command = (_a2 = commandQueue.peekAt(i)) === null || _a2 === void 0 ? void 0 : _a2.command;
        const pipelineIndex = command.pipelineIndex;
        if (pipelineIndex === void 0 || pipelineIndex === 0) {
          expectedIndex = 0;
        }
        if (pipelineIndex !== void 0 && pipelineIndex !== expectedIndex++) {
          commandQueue.remove(i, 1);
          command.reject(abortError(command));
          continue;
        }
        i++;
      }
    }
    function abortTransactionFragments(commandQueue) {
      var _a2;
      for (let i = 0; i < commandQueue.length; ) {
        const command = (_a2 = commandQueue.peekAt(i)) === null || _a2 === void 0 ? void 0 : _a2.command;
        if (command.name === "multi") {
          break;
        }
        if (command.name === "exec") {
          commandQueue.remove(i, 1);
          command.reject(abortError(command));
          break;
        }
        if (command.inTransaction) {
          commandQueue.remove(i, 1);
          command.reject(abortError(command));
        } else {
          i++;
        }
      }
    }
    function closeHandler(self) {
      return function() {
        const prevStatus = self.status;
        self.setStatus("close");
        if (self.commandQueue.length) {
          abortIncompletePipelines(self.commandQueue);
        }
        if (self.offlineQueue.length) {
          abortTransactionFragments(self.offlineQueue);
        }
        if (prevStatus === "ready") {
          if (!self.prevCondition) {
            self.prevCondition = self.condition;
          }
          if (self.commandQueue.length) {
            self.prevCommandQueue = self.commandQueue;
          }
        }
        if (self.manuallyClosing) {
          self.manuallyClosing = false;
          debug("skip reconnecting since the connection is manually closed.");
          return close();
        }
        if (typeof self.options.retryStrategy !== "function") {
          debug("skip reconnecting because `retryStrategy` is not a function");
          return close();
        }
        const retryDelay = self.options.retryStrategy(++self.retryAttempts);
        if (typeof retryDelay !== "number") {
          debug("skip reconnecting because `retryStrategy` doesn't return a number");
          return close();
        }
        debug("reconnect in %sms", retryDelay);
        self.setStatus("reconnecting", retryDelay);
        self.reconnectTimeout = setTimeout(function() {
          self.reconnectTimeout = null;
          self.connect().catch(utils_1.noop);
        }, retryDelay);
        const { maxRetriesPerRequest } = self.options;
        if (typeof maxRetriesPerRequest === "number") {
          if (maxRetriesPerRequest < 0) {
            debug("maxRetriesPerRequest is negative, ignoring...");
          } else {
            const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);
            if (remainder === 0) {
              debug("reach maxRetriesPerRequest limitation, flushing command queue...");
              self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));
            }
          }
        }
      };
      function close() {
        self.setStatus("end");
        self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
      }
    }
    exports.closeHandler = closeHandler;
    function errorHandler(self) {
      return function(error) {
        debug("error: %s", error);
        self.silentEmit("error", error);
      };
    }
    exports.errorHandler = errorHandler;
    function readyHandler(self) {
      return function() {
        self.setStatus("ready");
        self.retryAttempts = 0;
        if (self.options.monitor) {
          self.call("monitor").then(() => self.setStatus("monitoring"), (error) => self.emit("error", error));
          const { sendCommand } = self;
          self.sendCommand = function(command) {
            if (Command_1.default.checkFlag("VALID_IN_MONITOR_MODE", command.name)) {
              return sendCommand.call(self, command);
            }
            command.reject(new Error("Connection is in monitoring mode, can't process commands."));
            return command.promise;
          };
          self.once("close", function() {
            delete self.sendCommand;
          });
          return;
        }
        const finalSelect = self.prevCondition ? self.prevCondition.select : self.condition.select;
        if (self.options.connectionName) {
          debug("set the connection name [%s]", self.options.connectionName);
          self.client("setname", self.options.connectionName).catch(utils_1.noop);
        }
        if (self.options.readOnly) {
          debug("set the connection to readonly mode");
          self.readonly().catch(utils_1.noop);
        }
        if (self.prevCondition) {
          const condition = self.prevCondition;
          self.prevCondition = null;
          if (condition.subscriber && self.options.autoResubscribe) {
            if (self.condition.select !== finalSelect) {
              debug("connect to db [%d]", finalSelect);
              self.select(finalSelect);
            }
            const subscribeChannels = condition.subscriber.channels("subscribe");
            if (subscribeChannels.length) {
              debug("subscribe %d channels", subscribeChannels.length);
              self.subscribe(subscribeChannels);
            }
            const psubscribeChannels = condition.subscriber.channels("psubscribe");
            if (psubscribeChannels.length) {
              debug("psubscribe %d channels", psubscribeChannels.length);
              self.psubscribe(psubscribeChannels);
            }
            const ssubscribeChannels = condition.subscriber.channels("ssubscribe");
            if (ssubscribeChannels.length) {
              debug("ssubscribe %d channels", ssubscribeChannels.length);
              self.ssubscribe(ssubscribeChannels);
            }
          }
        }
        if (self.prevCommandQueue) {
          if (self.options.autoResendUnfulfilledCommands) {
            debug("resend %d unfulfilled commands", self.prevCommandQueue.length);
            while (self.prevCommandQueue.length > 0) {
              const item = self.prevCommandQueue.shift();
              if (item.select !== self.condition.select && item.command.name !== "select") {
                self.select(item.select);
              }
              self.sendCommand(item.command, item.stream);
            }
          } else {
            self.prevCommandQueue = null;
          }
        }
        if (self.offlineQueue.length) {
          debug("send %d commands in offline queue", self.offlineQueue.length);
          const offlineQueue = self.offlineQueue;
          self.resetOfflineQueue();
          while (offlineQueue.length > 0) {
            const item = offlineQueue.shift();
            if (item.select !== self.condition.select && item.command.name !== "select") {
              self.select(item.select);
            }
            self.sendCommand(item.command, item.stream);
          }
        }
        if (self.condition.select !== finalSelect) {
          debug("connect to db [%d]", finalSelect);
          self.select(finalSelect);
        }
      };
    }
    exports.readyHandler = readyHandler;
  }
});

// node_modules/ioredis/built/redis/RedisOptions.js
var require_RedisOptions = __commonJS({
  "node_modules/ioredis/built/redis/RedisOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_REDIS_OPTIONS = void 0;
    exports.DEFAULT_REDIS_OPTIONS = {
      // Connection
      port: 6379,
      host: "localhost",
      family: 4,
      connectTimeout: 1e4,
      disconnectTimeout: 2e3,
      retryStrategy: function(times) {
        return Math.min(times * 50, 2e3);
      },
      keepAlive: 0,
      noDelay: true,
      connectionName: null,
      // Sentinel
      sentinels: null,
      name: null,
      role: "master",
      sentinelRetryStrategy: function(times) {
        return Math.min(times * 10, 1e3);
      },
      sentinelReconnectStrategy: function() {
        return 6e4;
      },
      natMap: null,
      enableTLSForSentinelMode: false,
      updateSentinels: true,
      failoverDetector: false,
      // Status
      username: null,
      password: null,
      db: 0,
      // Others
      enableOfflineQueue: true,
      enableReadyCheck: true,
      autoResubscribe: true,
      autoResendUnfulfilledCommands: true,
      lazyConnect: false,
      keyPrefix: "",
      reconnectOnError: null,
      readOnly: false,
      stringNumbers: false,
      maxRetriesPerRequest: 20,
      maxLoadingRetryTime: 1e4,
      enableAutoPipelining: false,
      autoPipeliningIgnoredCommands: [],
      sentinelMaxConnections: 10
    };
  }
});

// node_modules/ioredis/built/Redis.js
var require_Redis = __commonJS({
  "node_modules/ioredis/built/Redis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = require_built();
    var events_1 = require("events");
    var standard_as_callback_1 = require_built2();
    var cluster_1 = require_cluster();
    var Command_1 = require_Command();
    var connectors_1 = require_connectors();
    var SentinelConnector_1 = require_SentinelConnector();
    var eventHandler = require_event_handler();
    var RedisOptions_1 = require_RedisOptions();
    var ScanStream_1 = require_ScanStream();
    var transaction_1 = require_transaction();
    var utils_1 = require_utils2();
    var applyMixin_1 = require_applyMixin();
    var Commander_1 = require_Commander();
    var lodash_1 = require_lodash3();
    var Deque = require_denque();
    var debug = (0, utils_1.Debug)("redis");
    var Redis2 = class _Redis extends Commander_1.default {
      constructor(arg1, arg2, arg3) {
        super();
        this.status = "wait";
        this.isCluster = false;
        this.reconnectTimeout = null;
        this.connectionEpoch = 0;
        this.retryAttempts = 0;
        this.manuallyClosing = false;
        this._autoPipelines = /* @__PURE__ */ new Map();
        this._runningAutoPipelines = /* @__PURE__ */ new Set();
        this.parseOptions(arg1, arg2, arg3);
        events_1.EventEmitter.call(this);
        this.resetCommandQueue();
        this.resetOfflineQueue();
        if (this.options.Connector) {
          this.connector = new this.options.Connector(this.options);
        } else if (this.options.sentinels) {
          const sentinelConnector = new SentinelConnector_1.default(this.options);
          sentinelConnector.emitter = this;
          this.connector = sentinelConnector;
        } else {
          this.connector = new connectors_1.StandaloneConnector(this.options);
        }
        if (this.options.scripts) {
          Object.entries(this.options.scripts).forEach(([name, definition]) => {
            this.defineCommand(name, definition);
          });
        }
        if (this.options.lazyConnect) {
          this.setStatus("wait");
        } else {
          this.connect().catch(lodash_1.noop);
        }
      }
      /**
       * Create a Redis instance.
       * This is the same as `new Redis()` but is included for compatibility with node-redis.
       */
      static createClient(...args) {
        return new _Redis(...args);
      }
      get autoPipelineQueueSize() {
        let queued = 0;
        for (const pipeline of this._autoPipelines.values()) {
          queued += pipeline.length;
        }
        return queued;
      }
      /**
       * Create a connection to Redis.
       * This method will be invoked automatically when creating a new Redis instance
       * unless `lazyConnect: true` is passed.
       *
       * When calling this method manually, a Promise is returned, which will
       * be resolved when the connection status is ready.
       */
      connect(callback) {
        const promise = new Promise((resolve, reject) => {
          if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
            reject(new Error("Redis is already connecting/connected"));
            return;
          }
          this.connectionEpoch += 1;
          this.setStatus("connecting");
          const { options } = this;
          this.condition = {
            select: options.db,
            auth: options.username ? [options.username, options.password] : options.password,
            subscriber: false
          };
          const _this = this;
          (0, standard_as_callback_1.default)(this.connector.connect(function(type3, err) {
            _this.silentEmit(type3, err);
          }), function(err, stream) {
            if (err) {
              _this.flushQueue(err);
              _this.silentEmit("error", err);
              reject(err);
              _this.setStatus("end");
              return;
            }
            let CONNECT_EVENT = options.tls ? "secureConnect" : "connect";
            if ("sentinels" in options && options.sentinels && !options.enableTLSForSentinelMode) {
              CONNECT_EVENT = "connect";
            }
            _this.stream = stream;
            if (options.noDelay) {
              stream.setNoDelay(true);
            }
            if (typeof options.keepAlive === "number") {
              if (stream.connecting) {
                stream.once(CONNECT_EVENT, () => {
                  stream.setKeepAlive(true, options.keepAlive);
                });
              } else {
                stream.setKeepAlive(true, options.keepAlive);
              }
            }
            if (stream.connecting) {
              stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
              if (options.connectTimeout) {
                let connectTimeoutCleared = false;
                stream.setTimeout(options.connectTimeout, function() {
                  if (connectTimeoutCleared) {
                    return;
                  }
                  stream.setTimeout(0);
                  stream.destroy();
                  const err2 = new Error("connect ETIMEDOUT");
                  err2.errorno = "ETIMEDOUT";
                  err2.code = "ETIMEDOUT";
                  err2.syscall = "connect";
                  eventHandler.errorHandler(_this)(err2);
                });
                stream.once(CONNECT_EVENT, function() {
                  connectTimeoutCleared = true;
                  stream.setTimeout(0);
                });
              }
            } else if (stream.destroyed) {
              const firstError = _this.connector.firstError;
              if (firstError) {
                process.nextTick(() => {
                  eventHandler.errorHandler(_this)(firstError);
                });
              }
              process.nextTick(eventHandler.closeHandler(_this));
            } else {
              process.nextTick(eventHandler.connectHandler(_this));
            }
            if (!stream.destroyed) {
              stream.once("error", eventHandler.errorHandler(_this));
              stream.once("close", eventHandler.closeHandler(_this));
            }
            const connectionReadyHandler = function() {
              _this.removeListener("close", connectionCloseHandler);
              resolve();
            };
            var connectionCloseHandler = function() {
              _this.removeListener("ready", connectionReadyHandler);
              reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
            };
            _this.once("ready", connectionReadyHandler);
            _this.once("close", connectionCloseHandler);
          });
        });
        return (0, standard_as_callback_1.default)(promise, callback);
      }
      /**
       * Disconnect from Redis.
       *
       * This method closes the connection immediately,
       * and may lose some pending replies that haven't written to client.
       * If you want to wait for the pending replies, use Redis#quit instead.
       */
      disconnect(reconnect = false) {
        if (!reconnect) {
          this.manuallyClosing = true;
        }
        if (this.reconnectTimeout && !reconnect) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
        }
        if (this.status === "wait") {
          eventHandler.closeHandler(this)();
        } else {
          this.connector.disconnect();
        }
      }
      /**
       * Disconnect from Redis.
       *
       * @deprecated
       */
      end() {
        this.disconnect();
      }
      /**
       * Create a new instance with the same options as the current one.
       *
       * @example
       * ```js
       * var redis = new Redis(6380);
       * var anotherRedis = redis.duplicate();
       * ```
       */
      duplicate(override) {
        return new _Redis({ ...this.options, ...override });
      }
      /**
       * Mode of the connection.
       *
       * One of `"normal"`, `"subscriber"`, or `"monitor"`. When the connection is
       * not in `"normal"` mode, certain commands are not allowed.
       */
      get mode() {
        var _a2;
        return this.options.monitor ? "monitor" : ((_a2 = this.condition) === null || _a2 === void 0 ? void 0 : _a2.subscriber) ? "subscriber" : "normal";
      }
      /**
       * Listen for all requests received by the server in real time.
       *
       * This command will create a new connection to Redis and send a
       * MONITOR command via the new connection in order to avoid disturbing
       * the current connection.
       *
       * @param callback The callback function. If omit, a promise will be returned.
       * @example
       * ```js
       * var redis = new Redis();
       * redis.monitor(function (err, monitor) {
       *   // Entering monitoring mode.
       *   monitor.on('monitor', function (time, args, source, database) {
       *     console.log(time + ": " + util.inspect(args));
       *   });
       * });
       *
       * // supports promise as well as other commands
       * redis.monitor().then(function (monitor) {
       *   monitor.on('monitor', function (time, args, source, database) {
       *     console.log(time + ": " + util.inspect(args));
       *   });
       * });
       * ```
       */
      monitor(callback) {
        const monitorInstance = this.duplicate({
          monitor: true,
          lazyConnect: false
        });
        return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {
          monitorInstance.once("error", reject);
          monitorInstance.once("monitoring", function() {
            resolve(monitorInstance);
          });
        }), callback);
      }
      /**
       * Send a command to Redis
       *
       * This method is used internally and in most cases you should not
       * use it directly. If you need to send a command that is not supported
       * by the library, you can use the `call` method:
       *
       * ```js
       * const redis = new Redis();
       *
       * redis.call('set', 'foo', 'bar');
       * // or
       * redis.call(['set', 'foo', 'bar']);
       * ```
       *
       * @ignore
       */
      sendCommand(command, stream) {
        var _a2, _b;
        if (this.status === "wait") {
          this.connect().catch(lodash_1.noop);
        }
        if (this.status === "end") {
          command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
          return command.promise;
        }
        if (((_a2 = this.condition) === null || _a2 === void 0 ? void 0 : _a2.subscriber) && !Command_1.default.checkFlag("VALID_IN_SUBSCRIBER_MODE", command.name)) {
          command.reject(new Error("Connection in subscriber mode, only subscriber commands may be used"));
          return command.promise;
        }
        if (typeof this.options.commandTimeout === "number") {
          command.setTimeout(this.options.commandTimeout);
        }
        let writable = this.status === "ready" || !stream && this.status === "connect" && (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "loading");
        if (!this.stream) {
          writable = false;
        } else if (!this.stream.writable) {
          writable = false;
        } else if (this.stream._writableState && this.stream._writableState.ended) {
          writable = false;
        }
        if (!writable) {
          if (!this.options.enableOfflineQueue) {
            command.reject(new Error("Stream isn't writeable and enableOfflineQueue options is false"));
            return command.promise;
          }
          if (command.name === "quit" && this.offlineQueue.length === 0) {
            this.disconnect();
            command.resolve(Buffer.from("OK"));
            return command.promise;
          }
          if (debug.enabled) {
            debug("queue command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command.name, command.args);
          }
          this.offlineQueue.push({
            command,
            stream,
            select: this.condition.select
          });
        } else {
          if (debug.enabled) {
            debug("write command[%s]: %d -> %s(%o)", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);
          }
          if (stream) {
            if ("isPipeline" in stream && stream.isPipeline) {
              stream.write(command.toWritable(stream.destination.redis.stream));
            } else {
              stream.write(command.toWritable(stream));
            }
          } else {
            this.stream.write(command.toWritable(this.stream));
          }
          this.commandQueue.push({
            command,
            stream,
            select: this.condition.select
          });
          if (Command_1.default.checkFlag("WILL_DISCONNECT", command.name)) {
            this.manuallyClosing = true;
          }
        }
        if (command.name === "select" && (0, utils_1.isInt)(command.args[0])) {
          const db = parseInt(command.args[0], 10);
          if (this.condition.select !== db) {
            this.condition.select = db;
            this.emit("select", db);
            debug("switch to db [%d]", this.condition.select);
          }
        }
        return command.promise;
      }
      scanStream(options) {
        return this.createScanStream("scan", { options });
      }
      scanBufferStream(options) {
        return this.createScanStream("scanBuffer", { options });
      }
      sscanStream(key, options) {
        return this.createScanStream("sscan", { key, options });
      }
      sscanBufferStream(key, options) {
        return this.createScanStream("sscanBuffer", { key, options });
      }
      hscanStream(key, options) {
        return this.createScanStream("hscan", { key, options });
      }
      hscanBufferStream(key, options) {
        return this.createScanStream("hscanBuffer", { key, options });
      }
      zscanStream(key, options) {
        return this.createScanStream("zscan", { key, options });
      }
      zscanBufferStream(key, options) {
        return this.createScanStream("zscanBuffer", { key, options });
      }
      /**
       * Emit only when there's at least one listener.
       *
       * @ignore
       */
      silentEmit(eventName, arg) {
        let error;
        if (eventName === "error") {
          error = arg;
          if (this.status === "end") {
            return;
          }
          if (this.manuallyClosing) {
            if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || // @ts-expect-error
            error.syscall === "connect" || // @ts-expect-error
            error.syscall === "read")) {
              return;
            }
          }
        }
        if (this.listeners(eventName).length > 0) {
          return this.emit.apply(this, arguments);
        }
        if (error && error instanceof Error) {
          console.error("[ioredis] Unhandled error event:", error.stack);
        }
        return false;
      }
      /**
       * @ignore
       */
      recoverFromFatalError(_commandError, err, options) {
        this.flushQueue(err, options);
        this.silentEmit("error", err);
        this.disconnect(true);
      }
      /**
       * @ignore
       */
      handleReconnection(err, item) {
        var _a2;
        let needReconnect = false;
        if (this.options.reconnectOnError) {
          needReconnect = this.options.reconnectOnError(err);
        }
        switch (needReconnect) {
          case 1:
          case true:
            if (this.status !== "reconnecting") {
              this.disconnect(true);
            }
            item.command.reject(err);
            break;
          case 2:
            if (this.status !== "reconnecting") {
              this.disconnect(true);
            }
            if (((_a2 = this.condition) === null || _a2 === void 0 ? void 0 : _a2.select) !== item.select && item.command.name !== "select") {
              this.select(item.select);
            }
            this.sendCommand(item.command);
            break;
          default:
            item.command.reject(err);
        }
      }
      /**
       * Get description of the connection. Used for debugging.
       */
      _getDescription() {
        let description;
        if ("path" in this.options && this.options.path) {
          description = this.options.path;
        } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {
          description = this.stream.remoteAddress + ":" + this.stream.remotePort;
        } else if ("host" in this.options && this.options.host) {
          description = this.options.host + ":" + this.options.port;
        } else {
          description = "";
        }
        if (this.options.connectionName) {
          description += ` (${this.options.connectionName})`;
        }
        return description;
      }
      resetCommandQueue() {
        this.commandQueue = new Deque();
      }
      resetOfflineQueue() {
        this.offlineQueue = new Deque();
      }
      parseOptions(...args) {
        const options = {};
        let isTls = false;
        for (let i = 0; i < args.length; ++i) {
          const arg = args[i];
          if (arg === null || typeof arg === "undefined") {
            continue;
          }
          if (typeof arg === "object") {
            (0, lodash_1.defaults)(options, arg);
          } else if (typeof arg === "string") {
            (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));
            if (arg.startsWith("rediss://")) {
              isTls = true;
            }
          } else if (typeof arg === "number") {
            options.port = arg;
          } else {
            throw new Error("Invalid argument " + arg);
          }
        }
        if (isTls) {
          (0, lodash_1.defaults)(options, { tls: true });
        }
        (0, lodash_1.defaults)(options, _Redis.defaultOptions);
        if (typeof options.port === "string") {
          options.port = parseInt(options.port, 10);
        }
        if (typeof options.db === "string") {
          options.db = parseInt(options.db, 10);
        }
        this.options = (0, utils_1.resolveTLSProfile)(options);
      }
      /**
       * Change instance's status
       */
      setStatus(status, arg) {
        if (debug.enabled) {
          debug("status[%s]: %s -> %s", this._getDescription(), this.status || "[empty]", status);
        }
        this.status = status;
        process.nextTick(this.emit.bind(this, status, arg));
      }
      createScanStream(command, { key, options = {} }) {
        return new ScanStream_1.default({
          objectMode: true,
          key,
          redis: this,
          command,
          ...options
        });
      }
      /**
       * Flush offline queue and command queue with error.
       *
       * @param error The error object to send to the commands
       * @param options options
       */
      flushQueue(error, options) {
        options = (0, lodash_1.defaults)({}, options, {
          offlineQueue: true,
          commandQueue: true
        });
        let item;
        if (options.offlineQueue) {
          while (item = this.offlineQueue.shift()) {
            item.command.reject(error);
          }
        }
        if (options.commandQueue) {
          if (this.commandQueue.length > 0) {
            if (this.stream) {
              this.stream.removeAllListeners("data");
            }
            while (item = this.commandQueue.shift()) {
              item.command.reject(error);
            }
          }
        }
      }
      /**
       * Check whether Redis has finished loading the persistent data and is able to
       * process commands.
       */
      _readyCheck(callback) {
        const _this = this;
        this.info(function(err, res) {
          if (err) {
            if (err.message && err.message.includes("NOPERM")) {
              console.warn(`Skipping the ready check because INFO command fails: "${err.message}". You can disable ready check with "enableReadyCheck". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);
              return callback(null, {});
            }
            return callback(err);
          }
          if (typeof res !== "string") {
            return callback(null, res);
          }
          const info = {};
          const lines = res.split("\r\n");
          for (let i = 0; i < lines.length; ++i) {
            const [fieldName, ...fieldValueParts] = lines[i].split(":");
            const fieldValue = fieldValueParts.join(":");
            if (fieldValue) {
              info[fieldName] = fieldValue;
            }
          }
          if (!info.loading || info.loading === "0") {
            callback(null, info);
          } else {
            const loadingEtaMs = (info.loading_eta_seconds || 1) * 1e3;
            const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;
            debug("Redis server still loading, trying again in " + retryTime + "ms");
            setTimeout(function() {
              _this._readyCheck(callback);
            }, retryTime);
          }
        }).catch(lodash_1.noop);
      }
    };
    Redis2.Cluster = cluster_1.default;
    Redis2.Command = Command_1.default;
    Redis2.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
    (0, applyMixin_1.default)(Redis2, events_1.EventEmitter);
    (0, transaction_1.addTransactionSupport)(Redis2.prototype);
    exports.default = Redis2;
  }
});

// node_modules/ioredis/built/index.js
var require_built3 = __commonJS({
  "node_modules/ioredis/built/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.print = exports.ReplyError = exports.SentinelIterator = exports.SentinelConnector = exports.AbstractConnector = exports.Pipeline = exports.ScanStream = exports.Command = exports.Cluster = exports.Redis = exports.default = void 0;
    exports = module2.exports = require_Redis().default;
    var Redis_1 = require_Redis();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return Redis_1.default;
    } });
    var Redis_2 = require_Redis();
    Object.defineProperty(exports, "Redis", { enumerable: true, get: function() {
      return Redis_2.default;
    } });
    var cluster_1 = require_cluster();
    Object.defineProperty(exports, "Cluster", { enumerable: true, get: function() {
      return cluster_1.default;
    } });
    var Command_1 = require_Command();
    Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
      return Command_1.default;
    } });
    var ScanStream_1 = require_ScanStream();
    Object.defineProperty(exports, "ScanStream", { enumerable: true, get: function() {
      return ScanStream_1.default;
    } });
    var Pipeline_1 = require_Pipeline();
    Object.defineProperty(exports, "Pipeline", { enumerable: true, get: function() {
      return Pipeline_1.default;
    } });
    var AbstractConnector_1 = require_AbstractConnector();
    Object.defineProperty(exports, "AbstractConnector", { enumerable: true, get: function() {
      return AbstractConnector_1.default;
    } });
    var SentinelConnector_1 = require_SentinelConnector();
    Object.defineProperty(exports, "SentinelConnector", { enumerable: true, get: function() {
      return SentinelConnector_1.default;
    } });
    Object.defineProperty(exports, "SentinelIterator", { enumerable: true, get: function() {
      return SentinelConnector_1.SentinelIterator;
    } });
    exports.ReplyError = require_redis_errors().ReplyError;
    Object.defineProperty(exports, "Promise", {
      get() {
        console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.");
        return Promise;
      },
      set(_lib) {
        console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.");
      }
    });
    function print(err, reply) {
      if (err) {
        console.log("Error: " + err);
      } else {
        console.log("Reply: " + reply);
      }
    }
    exports.print = print;
  }
});

// node_modules/showdown/dist/showdown.js
var require_showdown = __commonJS({
  "node_modules/showdown/dist/showdown.js"(exports, module2) {
    (function() {
      function getDefaultOpts(simple) {
        "use strict";
        var defaultOptions = {
          omitExtraWLInCodeBlocks: {
            defaultValue: false,
            describe: "Omit the default extra whiteline added to code blocks",
            type: "boolean"
          },
          noHeaderId: {
            defaultValue: false,
            describe: "Turn on/off generated header id",
            type: "boolean"
          },
          prefixHeaderId: {
            defaultValue: false,
            describe: "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
            type: "string"
          },
          rawPrefixHeaderId: {
            defaultValue: false,
            describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
            type: "boolean"
          },
          ghCompatibleHeaderId: {
            defaultValue: false,
            describe: "Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
            type: "boolean"
          },
          rawHeaderId: {
            defaultValue: false,
            describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,
            type: "boolean"
          },
          headerLevelStart: {
            defaultValue: false,
            describe: "The header blocks level start",
            type: "integer"
          },
          parseImgDimensions: {
            defaultValue: false,
            describe: "Turn on/off image dimension parsing",
            type: "boolean"
          },
          simplifiedAutoLink: {
            defaultValue: false,
            describe: "Turn on/off GFM autolink style",
            type: "boolean"
          },
          excludeTrailingPunctuationFromURLs: {
            defaultValue: false,
            describe: "Excludes trailing punctuation from links generated with autoLinking",
            type: "boolean"
          },
          literalMidWordUnderscores: {
            defaultValue: false,
            describe: "Parse midword underscores as literal underscores",
            type: "boolean"
          },
          literalMidWordAsterisks: {
            defaultValue: false,
            describe: "Parse midword asterisks as literal asterisks",
            type: "boolean"
          },
          strikethrough: {
            defaultValue: false,
            describe: "Turn on/off strikethrough support",
            type: "boolean"
          },
          tables: {
            defaultValue: false,
            describe: "Turn on/off tables support",
            type: "boolean"
          },
          tablesHeaderId: {
            defaultValue: false,
            describe: "Add an id to table headers",
            type: "boolean"
          },
          ghCodeBlocks: {
            defaultValue: true,
            describe: "Turn on/off GFM fenced code blocks support",
            type: "boolean"
          },
          tasklists: {
            defaultValue: false,
            describe: "Turn on/off GFM tasklist support",
            type: "boolean"
          },
          smoothLivePreview: {
            defaultValue: false,
            describe: "Prevents weird effects in live previews due to incomplete input",
            type: "boolean"
          },
          smartIndentationFix: {
            defaultValue: false,
            description: "Tries to smartly fix indentation in es6 strings",
            type: "boolean"
          },
          disableForced4SpacesIndentedSublists: {
            defaultValue: false,
            description: "Disables the requirement of indenting nested sublists by 4 spaces",
            type: "boolean"
          },
          simpleLineBreaks: {
            defaultValue: false,
            description: "Parses simple line breaks as <br> (GFM Style)",
            type: "boolean"
          },
          requireSpaceBeforeHeadingText: {
            defaultValue: false,
            description: "Makes adding a space between `#` and the header text mandatory (GFM Style)",
            type: "boolean"
          },
          ghMentions: {
            defaultValue: false,
            description: "Enables github @mentions",
            type: "boolean"
          },
          ghMentionsLink: {
            defaultValue: "https://github.com/{u}",
            description: "Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
            type: "string"
          },
          encodeEmails: {
            defaultValue: true,
            description: "Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
            type: "boolean"
          },
          openLinksInNewWindow: {
            defaultValue: false,
            description: "Open all links in new windows",
            type: "boolean"
          },
          backslashEscapesHTMLTags: {
            defaultValue: false,
            description: "Support for HTML Tag escaping. ex: <div>foo</div>",
            type: "boolean"
          },
          emoji: {
            defaultValue: false,
            description: "Enable emoji support. Ex: `this is a :smile: emoji`",
            type: "boolean"
          },
          underline: {
            defaultValue: false,
            description: "Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
            type: "boolean"
          },
          completeHTMLDocument: {
            defaultValue: false,
            description: "Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
            type: "boolean"
          },
          metadata: {
            defaultValue: false,
            description: "Enable support for document metadata (defined at the top of the document between `\xAB\xAB\xAB` and `\xBB\xBB\xBB` or between `---` and `---`).",
            type: "boolean"
          },
          splitAdjacentBlockquotes: {
            defaultValue: false,
            description: "Split adjacent blockquote blocks",
            type: "boolean"
          }
        };
        if (simple === false) {
          return JSON.parse(JSON.stringify(defaultOptions));
        }
        var ret = {};
        for (var opt in defaultOptions) {
          if (defaultOptions.hasOwnProperty(opt)) {
            ret[opt] = defaultOptions[opt].defaultValue;
          }
        }
        return ret;
      }
      function allOptionsOn() {
        "use strict";
        var options = getDefaultOpts(true), ret = {};
        for (var opt in options) {
          if (options.hasOwnProperty(opt)) {
            ret[opt] = true;
          }
        }
        return ret;
      }
      var showdown = {}, parsers = {}, extensions = {}, globalOptions = getDefaultOpts(true), setFlavor = "vanilla", flavor = {
        github: {
          omitExtraWLInCodeBlocks: true,
          simplifiedAutoLink: true,
          excludeTrailingPunctuationFromURLs: true,
          literalMidWordUnderscores: true,
          strikethrough: true,
          tables: true,
          tablesHeaderId: true,
          ghCodeBlocks: true,
          tasklists: true,
          disableForced4SpacesIndentedSublists: true,
          simpleLineBreaks: true,
          requireSpaceBeforeHeadingText: true,
          ghCompatibleHeaderId: true,
          ghMentions: true,
          backslashEscapesHTMLTags: true,
          emoji: true,
          splitAdjacentBlockquotes: true
        },
        original: {
          noHeaderId: true,
          ghCodeBlocks: false
        },
        ghost: {
          omitExtraWLInCodeBlocks: true,
          parseImgDimensions: true,
          simplifiedAutoLink: true,
          excludeTrailingPunctuationFromURLs: true,
          literalMidWordUnderscores: true,
          strikethrough: true,
          tables: true,
          tablesHeaderId: true,
          ghCodeBlocks: true,
          tasklists: true,
          smoothLivePreview: true,
          simpleLineBreaks: true,
          requireSpaceBeforeHeadingText: true,
          ghMentions: false,
          encodeEmails: true
        },
        vanilla: getDefaultOpts(true),
        allOn: allOptionsOn()
      };
      showdown.helper = {};
      showdown.extensions = {};
      showdown.setOption = function(key, value) {
        "use strict";
        globalOptions[key] = value;
        return this;
      };
      showdown.getOption = function(key) {
        "use strict";
        return globalOptions[key];
      };
      showdown.getOptions = function() {
        "use strict";
        return globalOptions;
      };
      showdown.resetOptions = function() {
        "use strict";
        globalOptions = getDefaultOpts(true);
      };
      showdown.setFlavor = function(name) {
        "use strict";
        if (!flavor.hasOwnProperty(name)) {
          throw Error(name + " flavor was not found");
        }
        showdown.resetOptions();
        var preset = flavor[name];
        setFlavor = name;
        for (var option in preset) {
          if (preset.hasOwnProperty(option)) {
            globalOptions[option] = preset[option];
          }
        }
      };
      showdown.getFlavor = function() {
        "use strict";
        return setFlavor;
      };
      showdown.getFlavorOptions = function(name) {
        "use strict";
        if (flavor.hasOwnProperty(name)) {
          return flavor[name];
        }
      };
      showdown.getDefaultOptions = function(simple) {
        "use strict";
        return getDefaultOpts(simple);
      };
      showdown.subParser = function(name, func) {
        "use strict";
        if (showdown.helper.isString(name)) {
          if (typeof func !== "undefined") {
            parsers[name] = func;
          } else {
            if (parsers.hasOwnProperty(name)) {
              return parsers[name];
            } else {
              throw Error("SubParser named " + name + " not registered!");
            }
          }
        }
      };
      showdown.extension = function(name, ext) {
        "use strict";
        if (!showdown.helper.isString(name)) {
          throw Error("Extension 'name' must be a string");
        }
        name = showdown.helper.stdExtName(name);
        if (showdown.helper.isUndefined(ext)) {
          if (!extensions.hasOwnProperty(name)) {
            throw Error("Extension named " + name + " is not registered!");
          }
          return extensions[name];
        } else {
          if (typeof ext === "function") {
            ext = ext();
          }
          if (!showdown.helper.isArray(ext)) {
            ext = [ext];
          }
          var validExtension = validate(ext, name);
          if (validExtension.valid) {
            extensions[name] = ext;
          } else {
            throw Error(validExtension.error);
          }
        }
      };
      showdown.getAllExtensions = function() {
        "use strict";
        return extensions;
      };
      showdown.removeExtension = function(name) {
        "use strict";
        delete extensions[name];
      };
      showdown.resetExtensions = function() {
        "use strict";
        extensions = {};
      };
      function validate(extension, name) {
        "use strict";
        var errMsg = name ? "Error in " + name + " extension->" : "Error in unnamed extension", ret = {
          valid: true,
          error: ""
        };
        if (!showdown.helper.isArray(extension)) {
          extension = [extension];
        }
        for (var i = 0; i < extension.length; ++i) {
          var baseMsg = errMsg + " sub-extension " + i + ": ", ext = extension[i];
          if (typeof ext !== "object") {
            ret.valid = false;
            ret.error = baseMsg + "must be an object, but " + typeof ext + " given";
            return ret;
          }
          if (!showdown.helper.isString(ext.type)) {
            ret.valid = false;
            ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + " given";
            return ret;
          }
          var type3 = ext.type = ext.type.toLowerCase();
          if (type3 === "language") {
            type3 = ext.type = "lang";
          }
          if (type3 === "html") {
            type3 = ext.type = "output";
          }
          if (type3 !== "lang" && type3 !== "output" && type3 !== "listener") {
            ret.valid = false;
            ret.error = baseMsg + "type " + type3 + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
            return ret;
          }
          if (type3 === "listener") {
            if (showdown.helper.isUndefined(ext.listeners)) {
              ret.valid = false;
              ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
              return ret;
            }
          } else {
            if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
              ret.valid = false;
              ret.error = baseMsg + type3 + ' extensions must define either a "regex" property or a "filter" method';
              return ret;
            }
          }
          if (ext.listeners) {
            if (typeof ext.listeners !== "object") {
              ret.valid = false;
              ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + " given";
              return ret;
            }
            for (var ln in ext.listeners) {
              if (ext.listeners.hasOwnProperty(ln)) {
                if (typeof ext.listeners[ln] !== "function") {
                  ret.valid = false;
                  ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln + " must be a function but " + typeof ext.listeners[ln] + " given";
                  return ret;
                }
              }
            }
          }
          if (ext.filter) {
            if (typeof ext.filter !== "function") {
              ret.valid = false;
              ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + " given";
              return ret;
            }
          } else if (ext.regex) {
            if (showdown.helper.isString(ext.regex)) {
              ext.regex = new RegExp(ext.regex, "g");
            }
            if (!(ext.regex instanceof RegExp)) {
              ret.valid = false;
              ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + " given";
              return ret;
            }
            if (showdown.helper.isUndefined(ext.replace)) {
              ret.valid = false;
              ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
              return ret;
            }
          }
        }
        return ret;
      }
      showdown.validateExtension = function(ext) {
        "use strict";
        var validateExtension = validate(ext, null);
        if (!validateExtension.valid) {
          console.warn(validateExtension.error);
          return false;
        }
        return true;
      };
      if (!showdown.hasOwnProperty("helper")) {
        showdown.helper = {};
      }
      showdown.helper.isString = function(a) {
        "use strict";
        return typeof a === "string" || a instanceof String;
      };
      showdown.helper.isFunction = function(a) {
        "use strict";
        var getType = {};
        return a && getType.toString.call(a) === "[object Function]";
      };
      showdown.helper.isArray = function(a) {
        "use strict";
        return Array.isArray(a);
      };
      showdown.helper.isUndefined = function(value) {
        "use strict";
        return typeof value === "undefined";
      };
      showdown.helper.forEach = function(obj, callback) {
        "use strict";
        if (showdown.helper.isUndefined(obj)) {
          throw new Error("obj param is required");
        }
        if (showdown.helper.isUndefined(callback)) {
          throw new Error("callback param is required");
        }
        if (!showdown.helper.isFunction(callback)) {
          throw new Error("callback param must be a function/closure");
        }
        if (typeof obj.forEach === "function") {
          obj.forEach(callback);
        } else if (showdown.helper.isArray(obj)) {
          for (var i = 0; i < obj.length; i++) {
            callback(obj[i], i, obj);
          }
        } else if (typeof obj === "object") {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              callback(obj[prop], prop, obj);
            }
          }
        } else {
          throw new Error("obj does not seem to be an array or an iterable object");
        }
      };
      showdown.helper.stdExtName = function(s) {
        "use strict";
        return s.replace(/[_?*+\/\\.^-]/g, "").replace(/\s/g, "").toLowerCase();
      };
      function escapeCharactersCallback(wholeMatch, m1) {
        "use strict";
        var charCodeToEscape = m1.charCodeAt(0);
        return "\xA8E" + charCodeToEscape + "E";
      }
      showdown.helper.escapeCharactersCallback = escapeCharactersCallback;
      showdown.helper.escapeCharacters = function(text, charsToEscape, afterBackslash) {
        "use strict";
        var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";
        if (afterBackslash) {
          regexString = "\\\\" + regexString;
        }
        var regex = new RegExp(regexString, "g");
        text = text.replace(regex, escapeCharactersCallback);
        return text;
      };
      showdown.helper.unescapeHTMLEntities = function(txt) {
        "use strict";
        return txt.replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
      };
      var rgxFindMatchPos = function(str, left, right, flags) {
        "use strict";
        var f2 = flags || "", g = f2.indexOf("g") > -1, x = new RegExp(left + "|" + right, "g" + f2.replace(/g/g, "")), l = new RegExp(left, f2.replace(/g/g, "")), pos = [], t3, s, m, start, end;
        do {
          t3 = 0;
          while (m = x.exec(str)) {
            if (l.test(m[0])) {
              if (!t3++) {
                s = x.lastIndex;
                start = s - m[0].length;
              }
            } else if (t3) {
              if (!--t3) {
                end = m.index + m[0].length;
                var obj = {
                  left: { start, end: s },
                  match: { start: s, end: m.index },
                  right: { start: m.index, end },
                  wholeMatch: { start, end }
                };
                pos.push(obj);
                if (!g) {
                  return pos;
                }
              }
            }
          }
        } while (t3 && (x.lastIndex = s));
        return pos;
      };
      showdown.helper.matchRecursiveRegExp = function(str, left, right, flags) {
        "use strict";
        var matchPos = rgxFindMatchPos(str, left, right, flags), results = [];
        for (var i = 0; i < matchPos.length; ++i) {
          results.push([
            str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
            str.slice(matchPos[i].match.start, matchPos[i].match.end),
            str.slice(matchPos[i].left.start, matchPos[i].left.end),
            str.slice(matchPos[i].right.start, matchPos[i].right.end)
          ]);
        }
        return results;
      };
      showdown.helper.replaceRecursiveRegExp = function(str, replacement, left, right, flags) {
        "use strict";
        if (!showdown.helper.isFunction(replacement)) {
          var repStr = replacement;
          replacement = function() {
            return repStr;
          };
        }
        var matchPos = rgxFindMatchPos(str, left, right, flags), finalStr = str, lng = matchPos.length;
        if (lng > 0) {
          var bits = [];
          if (matchPos[0].wholeMatch.start !== 0) {
            bits.push(str.slice(0, matchPos[0].wholeMatch.start));
          }
          for (var i = 0; i < lng; ++i) {
            bits.push(
              replacement(
                str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
                str.slice(matchPos[i].match.start, matchPos[i].match.end),
                str.slice(matchPos[i].left.start, matchPos[i].left.end),
                str.slice(matchPos[i].right.start, matchPos[i].right.end)
              )
            );
            if (i < lng - 1) {
              bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
            }
          }
          if (matchPos[lng - 1].wholeMatch.end < str.length) {
            bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
          }
          finalStr = bits.join("");
        }
        return finalStr;
      };
      showdown.helper.regexIndexOf = function(str, regex, fromIndex) {
        "use strict";
        if (!showdown.helper.isString(str)) {
          throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
        }
        if (regex instanceof RegExp === false) {
          throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
        }
        var indexOf = str.substring(fromIndex || 0).search(regex);
        return indexOf >= 0 ? indexOf + (fromIndex || 0) : indexOf;
      };
      showdown.helper.splitAtIndex = function(str, index) {
        "use strict";
        if (!showdown.helper.isString(str)) {
          throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
        }
        return [str.substring(0, index), str.substring(index)];
      };
      showdown.helper.encodeEmailAddress = function(mail) {
        "use strict";
        var encode = [
          function(ch) {
            return "&#" + ch.charCodeAt(0) + ";";
          },
          function(ch) {
            return "&#x" + ch.charCodeAt(0).toString(16) + ";";
          },
          function(ch) {
            return ch;
          }
        ];
        mail = mail.replace(/./g, function(ch) {
          if (ch === "@") {
            ch = encode[Math.floor(Math.random() * 2)](ch);
          } else {
            var r = Math.random();
            ch = r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch);
          }
          return ch;
        });
        return mail;
      };
      showdown.helper.padEnd = function padEnd(str, targetLength, padString) {
        "use strict";
        targetLength = targetLength >> 0;
        padString = String(padString || " ");
        if (str.length > targetLength) {
          return String(str);
        } else {
          targetLength = targetLength - str.length;
          if (targetLength > padString.length) {
            padString += padString.repeat(targetLength / padString.length);
          }
          return String(str) + padString.slice(0, targetLength);
        }
      };
      if (typeof console === "undefined") {
        console = {
          warn: function(msg) {
            "use strict";
            alert(msg);
          },
          log: function(msg) {
            "use strict";
            alert(msg);
          },
          error: function(msg) {
            "use strict";
            throw msg;
          }
        };
      }
      showdown.helper.regexes = {
        asteriskDashAndColon: /([*_:~])/g
      };
      showdown.helper.emojis = {
        "+1": "\u{1F44D}",
        "-1": "\u{1F44E}",
        "100": "\u{1F4AF}",
        "1234": "\u{1F522}",
        "1st_place_medal": "\u{1F947}",
        "2nd_place_medal": "\u{1F948}",
        "3rd_place_medal": "\u{1F949}",
        "8ball": "\u{1F3B1}",
        "a": "\u{1F170}\uFE0F",
        "ab": "\u{1F18E}",
        "abc": "\u{1F524}",
        "abcd": "\u{1F521}",
        "accept": "\u{1F251}",
        "aerial_tramway": "\u{1F6A1}",
        "airplane": "\u2708\uFE0F",
        "alarm_clock": "\u23F0",
        "alembic": "\u2697\uFE0F",
        "alien": "\u{1F47D}",
        "ambulance": "\u{1F691}",
        "amphora": "\u{1F3FA}",
        "anchor": "\u2693\uFE0F",
        "angel": "\u{1F47C}",
        "anger": "\u{1F4A2}",
        "angry": "\u{1F620}",
        "anguished": "\u{1F627}",
        "ant": "\u{1F41C}",
        "apple": "\u{1F34E}",
        "aquarius": "\u2652\uFE0F",
        "aries": "\u2648\uFE0F",
        "arrow_backward": "\u25C0\uFE0F",
        "arrow_double_down": "\u23EC",
        "arrow_double_up": "\u23EB",
        "arrow_down": "\u2B07\uFE0F",
        "arrow_down_small": "\u{1F53D}",
        "arrow_forward": "\u25B6\uFE0F",
        "arrow_heading_down": "\u2935\uFE0F",
        "arrow_heading_up": "\u2934\uFE0F",
        "arrow_left": "\u2B05\uFE0F",
        "arrow_lower_left": "\u2199\uFE0F",
        "arrow_lower_right": "\u2198\uFE0F",
        "arrow_right": "\u27A1\uFE0F",
        "arrow_right_hook": "\u21AA\uFE0F",
        "arrow_up": "\u2B06\uFE0F",
        "arrow_up_down": "\u2195\uFE0F",
        "arrow_up_small": "\u{1F53C}",
        "arrow_upper_left": "\u2196\uFE0F",
        "arrow_upper_right": "\u2197\uFE0F",
        "arrows_clockwise": "\u{1F503}",
        "arrows_counterclockwise": "\u{1F504}",
        "art": "\u{1F3A8}",
        "articulated_lorry": "\u{1F69B}",
        "artificial_satellite": "\u{1F6F0}",
        "astonished": "\u{1F632}",
        "athletic_shoe": "\u{1F45F}",
        "atm": "\u{1F3E7}",
        "atom_symbol": "\u269B\uFE0F",
        "avocado": "\u{1F951}",
        "b": "\u{1F171}\uFE0F",
        "baby": "\u{1F476}",
        "baby_bottle": "\u{1F37C}",
        "baby_chick": "\u{1F424}",
        "baby_symbol": "\u{1F6BC}",
        "back": "\u{1F519}",
        "bacon": "\u{1F953}",
        "badminton": "\u{1F3F8}",
        "baggage_claim": "\u{1F6C4}",
        "baguette_bread": "\u{1F956}",
        "balance_scale": "\u2696\uFE0F",
        "balloon": "\u{1F388}",
        "ballot_box": "\u{1F5F3}",
        "ballot_box_with_check": "\u2611\uFE0F",
        "bamboo": "\u{1F38D}",
        "banana": "\u{1F34C}",
        "bangbang": "\u203C\uFE0F",
        "bank": "\u{1F3E6}",
        "bar_chart": "\u{1F4CA}",
        "barber": "\u{1F488}",
        "baseball": "\u26BE\uFE0F",
        "basketball": "\u{1F3C0}",
        "basketball_man": "\u26F9\uFE0F",
        "basketball_woman": "\u26F9\uFE0F&zwj;\u2640\uFE0F",
        "bat": "\u{1F987}",
        "bath": "\u{1F6C0}",
        "bathtub": "\u{1F6C1}",
        "battery": "\u{1F50B}",
        "beach_umbrella": "\u{1F3D6}",
        "bear": "\u{1F43B}",
        "bed": "\u{1F6CF}",
        "bee": "\u{1F41D}",
        "beer": "\u{1F37A}",
        "beers": "\u{1F37B}",
        "beetle": "\u{1F41E}",
        "beginner": "\u{1F530}",
        "bell": "\u{1F514}",
        "bellhop_bell": "\u{1F6CE}",
        "bento": "\u{1F371}",
        "biking_man": "\u{1F6B4}",
        "bike": "\u{1F6B2}",
        "biking_woman": "\u{1F6B4}&zwj;\u2640\uFE0F",
        "bikini": "\u{1F459}",
        "biohazard": "\u2623\uFE0F",
        "bird": "\u{1F426}",
        "birthday": "\u{1F382}",
        "black_circle": "\u26AB\uFE0F",
        "black_flag": "\u{1F3F4}",
        "black_heart": "\u{1F5A4}",
        "black_joker": "\u{1F0CF}",
        "black_large_square": "\u2B1B\uFE0F",
        "black_medium_small_square": "\u25FE\uFE0F",
        "black_medium_square": "\u25FC\uFE0F",
        "black_nib": "\u2712\uFE0F",
        "black_small_square": "\u25AA\uFE0F",
        "black_square_button": "\u{1F532}",
        "blonde_man": "\u{1F471}",
        "blonde_woman": "\u{1F471}&zwj;\u2640\uFE0F",
        "blossom": "\u{1F33C}",
        "blowfish": "\u{1F421}",
        "blue_book": "\u{1F4D8}",
        "blue_car": "\u{1F699}",
        "blue_heart": "\u{1F499}",
        "blush": "\u{1F60A}",
        "boar": "\u{1F417}",
        "boat": "\u26F5\uFE0F",
        "bomb": "\u{1F4A3}",
        "book": "\u{1F4D6}",
        "bookmark": "\u{1F516}",
        "bookmark_tabs": "\u{1F4D1}",
        "books": "\u{1F4DA}",
        "boom": "\u{1F4A5}",
        "boot": "\u{1F462}",
        "bouquet": "\u{1F490}",
        "bowing_man": "\u{1F647}",
        "bow_and_arrow": "\u{1F3F9}",
        "bowing_woman": "\u{1F647}&zwj;\u2640\uFE0F",
        "bowling": "\u{1F3B3}",
        "boxing_glove": "\u{1F94A}",
        "boy": "\u{1F466}",
        "bread": "\u{1F35E}",
        "bride_with_veil": "\u{1F470}",
        "bridge_at_night": "\u{1F309}",
        "briefcase": "\u{1F4BC}",
        "broken_heart": "\u{1F494}",
        "bug": "\u{1F41B}",
        "building_construction": "\u{1F3D7}",
        "bulb": "\u{1F4A1}",
        "bullettrain_front": "\u{1F685}",
        "bullettrain_side": "\u{1F684}",
        "burrito": "\u{1F32F}",
        "bus": "\u{1F68C}",
        "business_suit_levitating": "\u{1F574}",
        "busstop": "\u{1F68F}",
        "bust_in_silhouette": "\u{1F464}",
        "busts_in_silhouette": "\u{1F465}",
        "butterfly": "\u{1F98B}",
        "cactus": "\u{1F335}",
        "cake": "\u{1F370}",
        "calendar": "\u{1F4C6}",
        "call_me_hand": "\u{1F919}",
        "calling": "\u{1F4F2}",
        "camel": "\u{1F42B}",
        "camera": "\u{1F4F7}",
        "camera_flash": "\u{1F4F8}",
        "camping": "\u{1F3D5}",
        "cancer": "\u264B\uFE0F",
        "candle": "\u{1F56F}",
        "candy": "\u{1F36C}",
        "canoe": "\u{1F6F6}",
        "capital_abcd": "\u{1F520}",
        "capricorn": "\u2651\uFE0F",
        "car": "\u{1F697}",
        "card_file_box": "\u{1F5C3}",
        "card_index": "\u{1F4C7}",
        "card_index_dividers": "\u{1F5C2}",
        "carousel_horse": "\u{1F3A0}",
        "carrot": "\u{1F955}",
        "cat": "\u{1F431}",
        "cat2": "\u{1F408}",
        "cd": "\u{1F4BF}",
        "chains": "\u26D3",
        "champagne": "\u{1F37E}",
        "chart": "\u{1F4B9}",
        "chart_with_downwards_trend": "\u{1F4C9}",
        "chart_with_upwards_trend": "\u{1F4C8}",
        "checkered_flag": "\u{1F3C1}",
        "cheese": "\u{1F9C0}",
        "cherries": "\u{1F352}",
        "cherry_blossom": "\u{1F338}",
        "chestnut": "\u{1F330}",
        "chicken": "\u{1F414}",
        "children_crossing": "\u{1F6B8}",
        "chipmunk": "\u{1F43F}",
        "chocolate_bar": "\u{1F36B}",
        "christmas_tree": "\u{1F384}",
        "church": "\u26EA\uFE0F",
        "cinema": "\u{1F3A6}",
        "circus_tent": "\u{1F3AA}",
        "city_sunrise": "\u{1F307}",
        "city_sunset": "\u{1F306}",
        "cityscape": "\u{1F3D9}",
        "cl": "\u{1F191}",
        "clamp": "\u{1F5DC}",
        "clap": "\u{1F44F}",
        "clapper": "\u{1F3AC}",
        "classical_building": "\u{1F3DB}",
        "clinking_glasses": "\u{1F942}",
        "clipboard": "\u{1F4CB}",
        "clock1": "\u{1F550}",
        "clock10": "\u{1F559}",
        "clock1030": "\u{1F565}",
        "clock11": "\u{1F55A}",
        "clock1130": "\u{1F566}",
        "clock12": "\u{1F55B}",
        "clock1230": "\u{1F567}",
        "clock130": "\u{1F55C}",
        "clock2": "\u{1F551}",
        "clock230": "\u{1F55D}",
        "clock3": "\u{1F552}",
        "clock330": "\u{1F55E}",
        "clock4": "\u{1F553}",
        "clock430": "\u{1F55F}",
        "clock5": "\u{1F554}",
        "clock530": "\u{1F560}",
        "clock6": "\u{1F555}",
        "clock630": "\u{1F561}",
        "clock7": "\u{1F556}",
        "clock730": "\u{1F562}",
        "clock8": "\u{1F557}",
        "clock830": "\u{1F563}",
        "clock9": "\u{1F558}",
        "clock930": "\u{1F564}",
        "closed_book": "\u{1F4D5}",
        "closed_lock_with_key": "\u{1F510}",
        "closed_umbrella": "\u{1F302}",
        "cloud": "\u2601\uFE0F",
        "cloud_with_lightning": "\u{1F329}",
        "cloud_with_lightning_and_rain": "\u26C8",
        "cloud_with_rain": "\u{1F327}",
        "cloud_with_snow": "\u{1F328}",
        "clown_face": "\u{1F921}",
        "clubs": "\u2663\uFE0F",
        "cocktail": "\u{1F378}",
        "coffee": "\u2615\uFE0F",
        "coffin": "\u26B0\uFE0F",
        "cold_sweat": "\u{1F630}",
        "comet": "\u2604\uFE0F",
        "computer": "\u{1F4BB}",
        "computer_mouse": "\u{1F5B1}",
        "confetti_ball": "\u{1F38A}",
        "confounded": "\u{1F616}",
        "confused": "\u{1F615}",
        "congratulations": "\u3297\uFE0F",
        "construction": "\u{1F6A7}",
        "construction_worker_man": "\u{1F477}",
        "construction_worker_woman": "\u{1F477}&zwj;\u2640\uFE0F",
        "control_knobs": "\u{1F39B}",
        "convenience_store": "\u{1F3EA}",
        "cookie": "\u{1F36A}",
        "cool": "\u{1F192}",
        "policeman": "\u{1F46E}",
        "copyright": "\xA9\uFE0F",
        "corn": "\u{1F33D}",
        "couch_and_lamp": "\u{1F6CB}",
        "couple": "\u{1F46B}",
        "couple_with_heart_woman_man": "\u{1F491}",
        "couple_with_heart_man_man": "\u{1F468}&zwj;\u2764\uFE0F&zwj;\u{1F468}",
        "couple_with_heart_woman_woman": "\u{1F469}&zwj;\u2764\uFE0F&zwj;\u{1F469}",
        "couplekiss_man_man": "\u{1F468}&zwj;\u2764\uFE0F&zwj;\u{1F48B}&zwj;\u{1F468}",
        "couplekiss_man_woman": "\u{1F48F}",
        "couplekiss_woman_woman": "\u{1F469}&zwj;\u2764\uFE0F&zwj;\u{1F48B}&zwj;\u{1F469}",
        "cow": "\u{1F42E}",
        "cow2": "\u{1F404}",
        "cowboy_hat_face": "\u{1F920}",
        "crab": "\u{1F980}",
        "crayon": "\u{1F58D}",
        "credit_card": "\u{1F4B3}",
        "crescent_moon": "\u{1F319}",
        "cricket": "\u{1F3CF}",
        "crocodile": "\u{1F40A}",
        "croissant": "\u{1F950}",
        "crossed_fingers": "\u{1F91E}",
        "crossed_flags": "\u{1F38C}",
        "crossed_swords": "\u2694\uFE0F",
        "crown": "\u{1F451}",
        "cry": "\u{1F622}",
        "crying_cat_face": "\u{1F63F}",
        "crystal_ball": "\u{1F52E}",
        "cucumber": "\u{1F952}",
        "cupid": "\u{1F498}",
        "curly_loop": "\u27B0",
        "currency_exchange": "\u{1F4B1}",
        "curry": "\u{1F35B}",
        "custard": "\u{1F36E}",
        "customs": "\u{1F6C3}",
        "cyclone": "\u{1F300}",
        "dagger": "\u{1F5E1}",
        "dancer": "\u{1F483}",
        "dancing_women": "\u{1F46F}",
        "dancing_men": "\u{1F46F}&zwj;\u2642\uFE0F",
        "dango": "\u{1F361}",
        "dark_sunglasses": "\u{1F576}",
        "dart": "\u{1F3AF}",
        "dash": "\u{1F4A8}",
        "date": "\u{1F4C5}",
        "deciduous_tree": "\u{1F333}",
        "deer": "\u{1F98C}",
        "department_store": "\u{1F3EC}",
        "derelict_house": "\u{1F3DA}",
        "desert": "\u{1F3DC}",
        "desert_island": "\u{1F3DD}",
        "desktop_computer": "\u{1F5A5}",
        "male_detective": "\u{1F575}\uFE0F",
        "diamond_shape_with_a_dot_inside": "\u{1F4A0}",
        "diamonds": "\u2666\uFE0F",
        "disappointed": "\u{1F61E}",
        "disappointed_relieved": "\u{1F625}",
        "dizzy": "\u{1F4AB}",
        "dizzy_face": "\u{1F635}",
        "do_not_litter": "\u{1F6AF}",
        "dog": "\u{1F436}",
        "dog2": "\u{1F415}",
        "dollar": "\u{1F4B5}",
        "dolls": "\u{1F38E}",
        "dolphin": "\u{1F42C}",
        "door": "\u{1F6AA}",
        "doughnut": "\u{1F369}",
        "dove": "\u{1F54A}",
        "dragon": "\u{1F409}",
        "dragon_face": "\u{1F432}",
        "dress": "\u{1F457}",
        "dromedary_camel": "\u{1F42A}",
        "drooling_face": "\u{1F924}",
        "droplet": "\u{1F4A7}",
        "drum": "\u{1F941}",
        "duck": "\u{1F986}",
        "dvd": "\u{1F4C0}",
        "e-mail": "\u{1F4E7}",
        "eagle": "\u{1F985}",
        "ear": "\u{1F442}",
        "ear_of_rice": "\u{1F33E}",
        "earth_africa": "\u{1F30D}",
        "earth_americas": "\u{1F30E}",
        "earth_asia": "\u{1F30F}",
        "egg": "\u{1F95A}",
        "eggplant": "\u{1F346}",
        "eight_pointed_black_star": "\u2734\uFE0F",
        "eight_spoked_asterisk": "\u2733\uFE0F",
        "electric_plug": "\u{1F50C}",
        "elephant": "\u{1F418}",
        "email": "\u2709\uFE0F",
        "end": "\u{1F51A}",
        "envelope_with_arrow": "\u{1F4E9}",
        "euro": "\u{1F4B6}",
        "european_castle": "\u{1F3F0}",
        "european_post_office": "\u{1F3E4}",
        "evergreen_tree": "\u{1F332}",
        "exclamation": "\u2757\uFE0F",
        "expressionless": "\u{1F611}",
        "eye": "\u{1F441}",
        "eye_speech_bubble": "\u{1F441}&zwj;\u{1F5E8}",
        "eyeglasses": "\u{1F453}",
        "eyes": "\u{1F440}",
        "face_with_head_bandage": "\u{1F915}",
        "face_with_thermometer": "\u{1F912}",
        "fist_oncoming": "\u{1F44A}",
        "factory": "\u{1F3ED}",
        "fallen_leaf": "\u{1F342}",
        "family_man_woman_boy": "\u{1F46A}",
        "family_man_boy": "\u{1F468}&zwj;\u{1F466}",
        "family_man_boy_boy": "\u{1F468}&zwj;\u{1F466}&zwj;\u{1F466}",
        "family_man_girl": "\u{1F468}&zwj;\u{1F467}",
        "family_man_girl_boy": "\u{1F468}&zwj;\u{1F467}&zwj;\u{1F466}",
        "family_man_girl_girl": "\u{1F468}&zwj;\u{1F467}&zwj;\u{1F467}",
        "family_man_man_boy": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F466}",
        "family_man_man_boy_boy": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F466}&zwj;\u{1F466}",
        "family_man_man_girl": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F467}",
        "family_man_man_girl_boy": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F467}&zwj;\u{1F466}",
        "family_man_man_girl_girl": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F467}&zwj;\u{1F467}",
        "family_man_woman_boy_boy": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F466}&zwj;\u{1F466}",
        "family_man_woman_girl": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F467}",
        "family_man_woman_girl_boy": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F466}",
        "family_man_woman_girl_girl": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F467}",
        "family_woman_boy": "\u{1F469}&zwj;\u{1F466}",
        "family_woman_boy_boy": "\u{1F469}&zwj;\u{1F466}&zwj;\u{1F466}",
        "family_woman_girl": "\u{1F469}&zwj;\u{1F467}",
        "family_woman_girl_boy": "\u{1F469}&zwj;\u{1F467}&zwj;\u{1F466}",
        "family_woman_girl_girl": "\u{1F469}&zwj;\u{1F467}&zwj;\u{1F467}",
        "family_woman_woman_boy": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F466}",
        "family_woman_woman_boy_boy": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F466}&zwj;\u{1F466}",
        "family_woman_woman_girl": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F467}",
        "family_woman_woman_girl_boy": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F466}",
        "family_woman_woman_girl_girl": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F467}",
        "fast_forward": "\u23E9",
        "fax": "\u{1F4E0}",
        "fearful": "\u{1F628}",
        "feet": "\u{1F43E}",
        "female_detective": "\u{1F575}\uFE0F&zwj;\u2640\uFE0F",
        "ferris_wheel": "\u{1F3A1}",
        "ferry": "\u26F4",
        "field_hockey": "\u{1F3D1}",
        "file_cabinet": "\u{1F5C4}",
        "file_folder": "\u{1F4C1}",
        "film_projector": "\u{1F4FD}",
        "film_strip": "\u{1F39E}",
        "fire": "\u{1F525}",
        "fire_engine": "\u{1F692}",
        "fireworks": "\u{1F386}",
        "first_quarter_moon": "\u{1F313}",
        "first_quarter_moon_with_face": "\u{1F31B}",
        "fish": "\u{1F41F}",
        "fish_cake": "\u{1F365}",
        "fishing_pole_and_fish": "\u{1F3A3}",
        "fist_raised": "\u270A",
        "fist_left": "\u{1F91B}",
        "fist_right": "\u{1F91C}",
        "flags": "\u{1F38F}",
        "flashlight": "\u{1F526}",
        "fleur_de_lis": "\u269C\uFE0F",
        "flight_arrival": "\u{1F6EC}",
        "flight_departure": "\u{1F6EB}",
        "floppy_disk": "\u{1F4BE}",
        "flower_playing_cards": "\u{1F3B4}",
        "flushed": "\u{1F633}",
        "fog": "\u{1F32B}",
        "foggy": "\u{1F301}",
        "football": "\u{1F3C8}",
        "footprints": "\u{1F463}",
        "fork_and_knife": "\u{1F374}",
        "fountain": "\u26F2\uFE0F",
        "fountain_pen": "\u{1F58B}",
        "four_leaf_clover": "\u{1F340}",
        "fox_face": "\u{1F98A}",
        "framed_picture": "\u{1F5BC}",
        "free": "\u{1F193}",
        "fried_egg": "\u{1F373}",
        "fried_shrimp": "\u{1F364}",
        "fries": "\u{1F35F}",
        "frog": "\u{1F438}",
        "frowning": "\u{1F626}",
        "frowning_face": "\u2639\uFE0F",
        "frowning_man": "\u{1F64D}&zwj;\u2642\uFE0F",
        "frowning_woman": "\u{1F64D}",
        "middle_finger": "\u{1F595}",
        "fuelpump": "\u26FD\uFE0F",
        "full_moon": "\u{1F315}",
        "full_moon_with_face": "\u{1F31D}",
        "funeral_urn": "\u26B1\uFE0F",
        "game_die": "\u{1F3B2}",
        "gear": "\u2699\uFE0F",
        "gem": "\u{1F48E}",
        "gemini": "\u264A\uFE0F",
        "ghost": "\u{1F47B}",
        "gift": "\u{1F381}",
        "gift_heart": "\u{1F49D}",
        "girl": "\u{1F467}",
        "globe_with_meridians": "\u{1F310}",
        "goal_net": "\u{1F945}",
        "goat": "\u{1F410}",
        "golf": "\u26F3\uFE0F",
        "golfing_man": "\u{1F3CC}\uFE0F",
        "golfing_woman": "\u{1F3CC}\uFE0F&zwj;\u2640\uFE0F",
        "gorilla": "\u{1F98D}",
        "grapes": "\u{1F347}",
        "green_apple": "\u{1F34F}",
        "green_book": "\u{1F4D7}",
        "green_heart": "\u{1F49A}",
        "green_salad": "\u{1F957}",
        "grey_exclamation": "\u2755",
        "grey_question": "\u2754",
        "grimacing": "\u{1F62C}",
        "grin": "\u{1F601}",
        "grinning": "\u{1F600}",
        "guardsman": "\u{1F482}",
        "guardswoman": "\u{1F482}&zwj;\u2640\uFE0F",
        "guitar": "\u{1F3B8}",
        "gun": "\u{1F52B}",
        "haircut_woman": "\u{1F487}",
        "haircut_man": "\u{1F487}&zwj;\u2642\uFE0F",
        "hamburger": "\u{1F354}",
        "hammer": "\u{1F528}",
        "hammer_and_pick": "\u2692",
        "hammer_and_wrench": "\u{1F6E0}",
        "hamster": "\u{1F439}",
        "hand": "\u270B",
        "handbag": "\u{1F45C}",
        "handshake": "\u{1F91D}",
        "hankey": "\u{1F4A9}",
        "hatched_chick": "\u{1F425}",
        "hatching_chick": "\u{1F423}",
        "headphones": "\u{1F3A7}",
        "hear_no_evil": "\u{1F649}",
        "heart": "\u2764\uFE0F",
        "heart_decoration": "\u{1F49F}",
        "heart_eyes": "\u{1F60D}",
        "heart_eyes_cat": "\u{1F63B}",
        "heartbeat": "\u{1F493}",
        "heartpulse": "\u{1F497}",
        "hearts": "\u2665\uFE0F",
        "heavy_check_mark": "\u2714\uFE0F",
        "heavy_division_sign": "\u2797",
        "heavy_dollar_sign": "\u{1F4B2}",
        "heavy_heart_exclamation": "\u2763\uFE0F",
        "heavy_minus_sign": "\u2796",
        "heavy_multiplication_x": "\u2716\uFE0F",
        "heavy_plus_sign": "\u2795",
        "helicopter": "\u{1F681}",
        "herb": "\u{1F33F}",
        "hibiscus": "\u{1F33A}",
        "high_brightness": "\u{1F506}",
        "high_heel": "\u{1F460}",
        "hocho": "\u{1F52A}",
        "hole": "\u{1F573}",
        "honey_pot": "\u{1F36F}",
        "horse": "\u{1F434}",
        "horse_racing": "\u{1F3C7}",
        "hospital": "\u{1F3E5}",
        "hot_pepper": "\u{1F336}",
        "hotdog": "\u{1F32D}",
        "hotel": "\u{1F3E8}",
        "hotsprings": "\u2668\uFE0F",
        "hourglass": "\u231B\uFE0F",
        "hourglass_flowing_sand": "\u23F3",
        "house": "\u{1F3E0}",
        "house_with_garden": "\u{1F3E1}",
        "houses": "\u{1F3D8}",
        "hugs": "\u{1F917}",
        "hushed": "\u{1F62F}",
        "ice_cream": "\u{1F368}",
        "ice_hockey": "\u{1F3D2}",
        "ice_skate": "\u26F8",
        "icecream": "\u{1F366}",
        "id": "\u{1F194}",
        "ideograph_advantage": "\u{1F250}",
        "imp": "\u{1F47F}",
        "inbox_tray": "\u{1F4E5}",
        "incoming_envelope": "\u{1F4E8}",
        "tipping_hand_woman": "\u{1F481}",
        "information_source": "\u2139\uFE0F",
        "innocent": "\u{1F607}",
        "interrobang": "\u2049\uFE0F",
        "iphone": "\u{1F4F1}",
        "izakaya_lantern": "\u{1F3EE}",
        "jack_o_lantern": "\u{1F383}",
        "japan": "\u{1F5FE}",
        "japanese_castle": "\u{1F3EF}",
        "japanese_goblin": "\u{1F47A}",
        "japanese_ogre": "\u{1F479}",
        "jeans": "\u{1F456}",
        "joy": "\u{1F602}",
        "joy_cat": "\u{1F639}",
        "joystick": "\u{1F579}",
        "kaaba": "\u{1F54B}",
        "key": "\u{1F511}",
        "keyboard": "\u2328\uFE0F",
        "keycap_ten": "\u{1F51F}",
        "kick_scooter": "\u{1F6F4}",
        "kimono": "\u{1F458}",
        "kiss": "\u{1F48B}",
        "kissing": "\u{1F617}",
        "kissing_cat": "\u{1F63D}",
        "kissing_closed_eyes": "\u{1F61A}",
        "kissing_heart": "\u{1F618}",
        "kissing_smiling_eyes": "\u{1F619}",
        "kiwi_fruit": "\u{1F95D}",
        "koala": "\u{1F428}",
        "koko": "\u{1F201}",
        "label": "\u{1F3F7}",
        "large_blue_circle": "\u{1F535}",
        "large_blue_diamond": "\u{1F537}",
        "large_orange_diamond": "\u{1F536}",
        "last_quarter_moon": "\u{1F317}",
        "last_quarter_moon_with_face": "\u{1F31C}",
        "latin_cross": "\u271D\uFE0F",
        "laughing": "\u{1F606}",
        "leaves": "\u{1F343}",
        "ledger": "\u{1F4D2}",
        "left_luggage": "\u{1F6C5}",
        "left_right_arrow": "\u2194\uFE0F",
        "leftwards_arrow_with_hook": "\u21A9\uFE0F",
        "lemon": "\u{1F34B}",
        "leo": "\u264C\uFE0F",
        "leopard": "\u{1F406}",
        "level_slider": "\u{1F39A}",
        "libra": "\u264E\uFE0F",
        "light_rail": "\u{1F688}",
        "link": "\u{1F517}",
        "lion": "\u{1F981}",
        "lips": "\u{1F444}",
        "lipstick": "\u{1F484}",
        "lizard": "\u{1F98E}",
        "lock": "\u{1F512}",
        "lock_with_ink_pen": "\u{1F50F}",
        "lollipop": "\u{1F36D}",
        "loop": "\u27BF",
        "loud_sound": "\u{1F50A}",
        "loudspeaker": "\u{1F4E2}",
        "love_hotel": "\u{1F3E9}",
        "love_letter": "\u{1F48C}",
        "low_brightness": "\u{1F505}",
        "lying_face": "\u{1F925}",
        "m": "\u24C2\uFE0F",
        "mag": "\u{1F50D}",
        "mag_right": "\u{1F50E}",
        "mahjong": "\u{1F004}\uFE0F",
        "mailbox": "\u{1F4EB}",
        "mailbox_closed": "\u{1F4EA}",
        "mailbox_with_mail": "\u{1F4EC}",
        "mailbox_with_no_mail": "\u{1F4ED}",
        "man": "\u{1F468}",
        "man_artist": "\u{1F468}&zwj;\u{1F3A8}",
        "man_astronaut": "\u{1F468}&zwj;\u{1F680}",
        "man_cartwheeling": "\u{1F938}&zwj;\u2642\uFE0F",
        "man_cook": "\u{1F468}&zwj;\u{1F373}",
        "man_dancing": "\u{1F57A}",
        "man_facepalming": "\u{1F926}&zwj;\u2642\uFE0F",
        "man_factory_worker": "\u{1F468}&zwj;\u{1F3ED}",
        "man_farmer": "\u{1F468}&zwj;\u{1F33E}",
        "man_firefighter": "\u{1F468}&zwj;\u{1F692}",
        "man_health_worker": "\u{1F468}&zwj;\u2695\uFE0F",
        "man_in_tuxedo": "\u{1F935}",
        "man_judge": "\u{1F468}&zwj;\u2696\uFE0F",
        "man_juggling": "\u{1F939}&zwj;\u2642\uFE0F",
        "man_mechanic": "\u{1F468}&zwj;\u{1F527}",
        "man_office_worker": "\u{1F468}&zwj;\u{1F4BC}",
        "man_pilot": "\u{1F468}&zwj;\u2708\uFE0F",
        "man_playing_handball": "\u{1F93E}&zwj;\u2642\uFE0F",
        "man_playing_water_polo": "\u{1F93D}&zwj;\u2642\uFE0F",
        "man_scientist": "\u{1F468}&zwj;\u{1F52C}",
        "man_shrugging": "\u{1F937}&zwj;\u2642\uFE0F",
        "man_singer": "\u{1F468}&zwj;\u{1F3A4}",
        "man_student": "\u{1F468}&zwj;\u{1F393}",
        "man_teacher": "\u{1F468}&zwj;\u{1F3EB}",
        "man_technologist": "\u{1F468}&zwj;\u{1F4BB}",
        "man_with_gua_pi_mao": "\u{1F472}",
        "man_with_turban": "\u{1F473}",
        "tangerine": "\u{1F34A}",
        "mans_shoe": "\u{1F45E}",
        "mantelpiece_clock": "\u{1F570}",
        "maple_leaf": "\u{1F341}",
        "martial_arts_uniform": "\u{1F94B}",
        "mask": "\u{1F637}",
        "massage_woman": "\u{1F486}",
        "massage_man": "\u{1F486}&zwj;\u2642\uFE0F",
        "meat_on_bone": "\u{1F356}",
        "medal_military": "\u{1F396}",
        "medal_sports": "\u{1F3C5}",
        "mega": "\u{1F4E3}",
        "melon": "\u{1F348}",
        "memo": "\u{1F4DD}",
        "men_wrestling": "\u{1F93C}&zwj;\u2642\uFE0F",
        "menorah": "\u{1F54E}",
        "mens": "\u{1F6B9}",
        "metal": "\u{1F918}",
        "metro": "\u{1F687}",
        "microphone": "\u{1F3A4}",
        "microscope": "\u{1F52C}",
        "milk_glass": "\u{1F95B}",
        "milky_way": "\u{1F30C}",
        "minibus": "\u{1F690}",
        "minidisc": "\u{1F4BD}",
        "mobile_phone_off": "\u{1F4F4}",
        "money_mouth_face": "\u{1F911}",
        "money_with_wings": "\u{1F4B8}",
        "moneybag": "\u{1F4B0}",
        "monkey": "\u{1F412}",
        "monkey_face": "\u{1F435}",
        "monorail": "\u{1F69D}",
        "moon": "\u{1F314}",
        "mortar_board": "\u{1F393}",
        "mosque": "\u{1F54C}",
        "motor_boat": "\u{1F6E5}",
        "motor_scooter": "\u{1F6F5}",
        "motorcycle": "\u{1F3CD}",
        "motorway": "\u{1F6E3}",
        "mount_fuji": "\u{1F5FB}",
        "mountain": "\u26F0",
        "mountain_biking_man": "\u{1F6B5}",
        "mountain_biking_woman": "\u{1F6B5}&zwj;\u2640\uFE0F",
        "mountain_cableway": "\u{1F6A0}",
        "mountain_railway": "\u{1F69E}",
        "mountain_snow": "\u{1F3D4}",
        "mouse": "\u{1F42D}",
        "mouse2": "\u{1F401}",
        "movie_camera": "\u{1F3A5}",
        "moyai": "\u{1F5FF}",
        "mrs_claus": "\u{1F936}",
        "muscle": "\u{1F4AA}",
        "mushroom": "\u{1F344}",
        "musical_keyboard": "\u{1F3B9}",
        "musical_note": "\u{1F3B5}",
        "musical_score": "\u{1F3BC}",
        "mute": "\u{1F507}",
        "nail_care": "\u{1F485}",
        "name_badge": "\u{1F4DB}",
        "national_park": "\u{1F3DE}",
        "nauseated_face": "\u{1F922}",
        "necktie": "\u{1F454}",
        "negative_squared_cross_mark": "\u274E",
        "nerd_face": "\u{1F913}",
        "neutral_face": "\u{1F610}",
        "new": "\u{1F195}",
        "new_moon": "\u{1F311}",
        "new_moon_with_face": "\u{1F31A}",
        "newspaper": "\u{1F4F0}",
        "newspaper_roll": "\u{1F5DE}",
        "next_track_button": "\u23ED",
        "ng": "\u{1F196}",
        "no_good_man": "\u{1F645}&zwj;\u2642\uFE0F",
        "no_good_woman": "\u{1F645}",
        "night_with_stars": "\u{1F303}",
        "no_bell": "\u{1F515}",
        "no_bicycles": "\u{1F6B3}",
        "no_entry": "\u26D4\uFE0F",
        "no_entry_sign": "\u{1F6AB}",
        "no_mobile_phones": "\u{1F4F5}",
        "no_mouth": "\u{1F636}",
        "no_pedestrians": "\u{1F6B7}",
        "no_smoking": "\u{1F6AD}",
        "non-potable_water": "\u{1F6B1}",
        "nose": "\u{1F443}",
        "notebook": "\u{1F4D3}",
        "notebook_with_decorative_cover": "\u{1F4D4}",
        "notes": "\u{1F3B6}",
        "nut_and_bolt": "\u{1F529}",
        "o": "\u2B55\uFE0F",
        "o2": "\u{1F17E}\uFE0F",
        "ocean": "\u{1F30A}",
        "octopus": "\u{1F419}",
        "oden": "\u{1F362}",
        "office": "\u{1F3E2}",
        "oil_drum": "\u{1F6E2}",
        "ok": "\u{1F197}",
        "ok_hand": "\u{1F44C}",
        "ok_man": "\u{1F646}&zwj;\u2642\uFE0F",
        "ok_woman": "\u{1F646}",
        "old_key": "\u{1F5DD}",
        "older_man": "\u{1F474}",
        "older_woman": "\u{1F475}",
        "om": "\u{1F549}",
        "on": "\u{1F51B}",
        "oncoming_automobile": "\u{1F698}",
        "oncoming_bus": "\u{1F68D}",
        "oncoming_police_car": "\u{1F694}",
        "oncoming_taxi": "\u{1F696}",
        "open_file_folder": "\u{1F4C2}",
        "open_hands": "\u{1F450}",
        "open_mouth": "\u{1F62E}",
        "open_umbrella": "\u2602\uFE0F",
        "ophiuchus": "\u26CE",
        "orange_book": "\u{1F4D9}",
        "orthodox_cross": "\u2626\uFE0F",
        "outbox_tray": "\u{1F4E4}",
        "owl": "\u{1F989}",
        "ox": "\u{1F402}",
        "package": "\u{1F4E6}",
        "page_facing_up": "\u{1F4C4}",
        "page_with_curl": "\u{1F4C3}",
        "pager": "\u{1F4DF}",
        "paintbrush": "\u{1F58C}",
        "palm_tree": "\u{1F334}",
        "pancakes": "\u{1F95E}",
        "panda_face": "\u{1F43C}",
        "paperclip": "\u{1F4CE}",
        "paperclips": "\u{1F587}",
        "parasol_on_ground": "\u26F1",
        "parking": "\u{1F17F}\uFE0F",
        "part_alternation_mark": "\u303D\uFE0F",
        "partly_sunny": "\u26C5\uFE0F",
        "passenger_ship": "\u{1F6F3}",
        "passport_control": "\u{1F6C2}",
        "pause_button": "\u23F8",
        "peace_symbol": "\u262E\uFE0F",
        "peach": "\u{1F351}",
        "peanuts": "\u{1F95C}",
        "pear": "\u{1F350}",
        "pen": "\u{1F58A}",
        "pencil2": "\u270F\uFE0F",
        "penguin": "\u{1F427}",
        "pensive": "\u{1F614}",
        "performing_arts": "\u{1F3AD}",
        "persevere": "\u{1F623}",
        "person_fencing": "\u{1F93A}",
        "pouting_woman": "\u{1F64E}",
        "phone": "\u260E\uFE0F",
        "pick": "\u26CF",
        "pig": "\u{1F437}",
        "pig2": "\u{1F416}",
        "pig_nose": "\u{1F43D}",
        "pill": "\u{1F48A}",
        "pineapple": "\u{1F34D}",
        "ping_pong": "\u{1F3D3}",
        "pisces": "\u2653\uFE0F",
        "pizza": "\u{1F355}",
        "place_of_worship": "\u{1F6D0}",
        "plate_with_cutlery": "\u{1F37D}",
        "play_or_pause_button": "\u23EF",
        "point_down": "\u{1F447}",
        "point_left": "\u{1F448}",
        "point_right": "\u{1F449}",
        "point_up": "\u261D\uFE0F",
        "point_up_2": "\u{1F446}",
        "police_car": "\u{1F693}",
        "policewoman": "\u{1F46E}&zwj;\u2640\uFE0F",
        "poodle": "\u{1F429}",
        "popcorn": "\u{1F37F}",
        "post_office": "\u{1F3E3}",
        "postal_horn": "\u{1F4EF}",
        "postbox": "\u{1F4EE}",
        "potable_water": "\u{1F6B0}",
        "potato": "\u{1F954}",
        "pouch": "\u{1F45D}",
        "poultry_leg": "\u{1F357}",
        "pound": "\u{1F4B7}",
        "rage": "\u{1F621}",
        "pouting_cat": "\u{1F63E}",
        "pouting_man": "\u{1F64E}&zwj;\u2642\uFE0F",
        "pray": "\u{1F64F}",
        "prayer_beads": "\u{1F4FF}",
        "pregnant_woman": "\u{1F930}",
        "previous_track_button": "\u23EE",
        "prince": "\u{1F934}",
        "princess": "\u{1F478}",
        "printer": "\u{1F5A8}",
        "purple_heart": "\u{1F49C}",
        "purse": "\u{1F45B}",
        "pushpin": "\u{1F4CC}",
        "put_litter_in_its_place": "\u{1F6AE}",
        "question": "\u2753",
        "rabbit": "\u{1F430}",
        "rabbit2": "\u{1F407}",
        "racehorse": "\u{1F40E}",
        "racing_car": "\u{1F3CE}",
        "radio": "\u{1F4FB}",
        "radio_button": "\u{1F518}",
        "radioactive": "\u2622\uFE0F",
        "railway_car": "\u{1F683}",
        "railway_track": "\u{1F6E4}",
        "rainbow": "\u{1F308}",
        "rainbow_flag": "\u{1F3F3}\uFE0F&zwj;\u{1F308}",
        "raised_back_of_hand": "\u{1F91A}",
        "raised_hand_with_fingers_splayed": "\u{1F590}",
        "raised_hands": "\u{1F64C}",
        "raising_hand_woman": "\u{1F64B}",
        "raising_hand_man": "\u{1F64B}&zwj;\u2642\uFE0F",
        "ram": "\u{1F40F}",
        "ramen": "\u{1F35C}",
        "rat": "\u{1F400}",
        "record_button": "\u23FA",
        "recycle": "\u267B\uFE0F",
        "red_circle": "\u{1F534}",
        "registered": "\xAE\uFE0F",
        "relaxed": "\u263A\uFE0F",
        "relieved": "\u{1F60C}",
        "reminder_ribbon": "\u{1F397}",
        "repeat": "\u{1F501}",
        "repeat_one": "\u{1F502}",
        "rescue_worker_helmet": "\u26D1",
        "restroom": "\u{1F6BB}",
        "revolving_hearts": "\u{1F49E}",
        "rewind": "\u23EA",
        "rhinoceros": "\u{1F98F}",
        "ribbon": "\u{1F380}",
        "rice": "\u{1F35A}",
        "rice_ball": "\u{1F359}",
        "rice_cracker": "\u{1F358}",
        "rice_scene": "\u{1F391}",
        "right_anger_bubble": "\u{1F5EF}",
        "ring": "\u{1F48D}",
        "robot": "\u{1F916}",
        "rocket": "\u{1F680}",
        "rofl": "\u{1F923}",
        "roll_eyes": "\u{1F644}",
        "roller_coaster": "\u{1F3A2}",
        "rooster": "\u{1F413}",
        "rose": "\u{1F339}",
        "rosette": "\u{1F3F5}",
        "rotating_light": "\u{1F6A8}",
        "round_pushpin": "\u{1F4CD}",
        "rowing_man": "\u{1F6A3}",
        "rowing_woman": "\u{1F6A3}&zwj;\u2640\uFE0F",
        "rugby_football": "\u{1F3C9}",
        "running_man": "\u{1F3C3}",
        "running_shirt_with_sash": "\u{1F3BD}",
        "running_woman": "\u{1F3C3}&zwj;\u2640\uFE0F",
        "sa": "\u{1F202}\uFE0F",
        "sagittarius": "\u2650\uFE0F",
        "sake": "\u{1F376}",
        "sandal": "\u{1F461}",
        "santa": "\u{1F385}",
        "satellite": "\u{1F4E1}",
        "saxophone": "\u{1F3B7}",
        "school": "\u{1F3EB}",
        "school_satchel": "\u{1F392}",
        "scissors": "\u2702\uFE0F",
        "scorpion": "\u{1F982}",
        "scorpius": "\u264F\uFE0F",
        "scream": "\u{1F631}",
        "scream_cat": "\u{1F640}",
        "scroll": "\u{1F4DC}",
        "seat": "\u{1F4BA}",
        "secret": "\u3299\uFE0F",
        "see_no_evil": "\u{1F648}",
        "seedling": "\u{1F331}",
        "selfie": "\u{1F933}",
        "shallow_pan_of_food": "\u{1F958}",
        "shamrock": "\u2618\uFE0F",
        "shark": "\u{1F988}",
        "shaved_ice": "\u{1F367}",
        "sheep": "\u{1F411}",
        "shell": "\u{1F41A}",
        "shield": "\u{1F6E1}",
        "shinto_shrine": "\u26E9",
        "ship": "\u{1F6A2}",
        "shirt": "\u{1F455}",
        "shopping": "\u{1F6CD}",
        "shopping_cart": "\u{1F6D2}",
        "shower": "\u{1F6BF}",
        "shrimp": "\u{1F990}",
        "signal_strength": "\u{1F4F6}",
        "six_pointed_star": "\u{1F52F}",
        "ski": "\u{1F3BF}",
        "skier": "\u26F7",
        "skull": "\u{1F480}",
        "skull_and_crossbones": "\u2620\uFE0F",
        "sleeping": "\u{1F634}",
        "sleeping_bed": "\u{1F6CC}",
        "sleepy": "\u{1F62A}",
        "slightly_frowning_face": "\u{1F641}",
        "slightly_smiling_face": "\u{1F642}",
        "slot_machine": "\u{1F3B0}",
        "small_airplane": "\u{1F6E9}",
        "small_blue_diamond": "\u{1F539}",
        "small_orange_diamond": "\u{1F538}",
        "small_red_triangle": "\u{1F53A}",
        "small_red_triangle_down": "\u{1F53B}",
        "smile": "\u{1F604}",
        "smile_cat": "\u{1F638}",
        "smiley": "\u{1F603}",
        "smiley_cat": "\u{1F63A}",
        "smiling_imp": "\u{1F608}",
        "smirk": "\u{1F60F}",
        "smirk_cat": "\u{1F63C}",
        "smoking": "\u{1F6AC}",
        "snail": "\u{1F40C}",
        "snake": "\u{1F40D}",
        "sneezing_face": "\u{1F927}",
        "snowboarder": "\u{1F3C2}",
        "snowflake": "\u2744\uFE0F",
        "snowman": "\u26C4\uFE0F",
        "snowman_with_snow": "\u2603\uFE0F",
        "sob": "\u{1F62D}",
        "soccer": "\u26BD\uFE0F",
        "soon": "\u{1F51C}",
        "sos": "\u{1F198}",
        "sound": "\u{1F509}",
        "space_invader": "\u{1F47E}",
        "spades": "\u2660\uFE0F",
        "spaghetti": "\u{1F35D}",
        "sparkle": "\u2747\uFE0F",
        "sparkler": "\u{1F387}",
        "sparkles": "\u2728",
        "sparkling_heart": "\u{1F496}",
        "speak_no_evil": "\u{1F64A}",
        "speaker": "\u{1F508}",
        "speaking_head": "\u{1F5E3}",
        "speech_balloon": "\u{1F4AC}",
        "speedboat": "\u{1F6A4}",
        "spider": "\u{1F577}",
        "spider_web": "\u{1F578}",
        "spiral_calendar": "\u{1F5D3}",
        "spiral_notepad": "\u{1F5D2}",
        "spoon": "\u{1F944}",
        "squid": "\u{1F991}",
        "stadium": "\u{1F3DF}",
        "star": "\u2B50\uFE0F",
        "star2": "\u{1F31F}",
        "star_and_crescent": "\u262A\uFE0F",
        "star_of_david": "\u2721\uFE0F",
        "stars": "\u{1F320}",
        "station": "\u{1F689}",
        "statue_of_liberty": "\u{1F5FD}",
        "steam_locomotive": "\u{1F682}",
        "stew": "\u{1F372}",
        "stop_button": "\u23F9",
        "stop_sign": "\u{1F6D1}",
        "stopwatch": "\u23F1",
        "straight_ruler": "\u{1F4CF}",
        "strawberry": "\u{1F353}",
        "stuck_out_tongue": "\u{1F61B}",
        "stuck_out_tongue_closed_eyes": "\u{1F61D}",
        "stuck_out_tongue_winking_eye": "\u{1F61C}",
        "studio_microphone": "\u{1F399}",
        "stuffed_flatbread": "\u{1F959}",
        "sun_behind_large_cloud": "\u{1F325}",
        "sun_behind_rain_cloud": "\u{1F326}",
        "sun_behind_small_cloud": "\u{1F324}",
        "sun_with_face": "\u{1F31E}",
        "sunflower": "\u{1F33B}",
        "sunglasses": "\u{1F60E}",
        "sunny": "\u2600\uFE0F",
        "sunrise": "\u{1F305}",
        "sunrise_over_mountains": "\u{1F304}",
        "surfing_man": "\u{1F3C4}",
        "surfing_woman": "\u{1F3C4}&zwj;\u2640\uFE0F",
        "sushi": "\u{1F363}",
        "suspension_railway": "\u{1F69F}",
        "sweat": "\u{1F613}",
        "sweat_drops": "\u{1F4A6}",
        "sweat_smile": "\u{1F605}",
        "sweet_potato": "\u{1F360}",
        "swimming_man": "\u{1F3CA}",
        "swimming_woman": "\u{1F3CA}&zwj;\u2640\uFE0F",
        "symbols": "\u{1F523}",
        "synagogue": "\u{1F54D}",
        "syringe": "\u{1F489}",
        "taco": "\u{1F32E}",
        "tada": "\u{1F389}",
        "tanabata_tree": "\u{1F38B}",
        "taurus": "\u2649\uFE0F",
        "taxi": "\u{1F695}",
        "tea": "\u{1F375}",
        "telephone_receiver": "\u{1F4DE}",
        "telescope": "\u{1F52D}",
        "tennis": "\u{1F3BE}",
        "tent": "\u26FA\uFE0F",
        "thermometer": "\u{1F321}",
        "thinking": "\u{1F914}",
        "thought_balloon": "\u{1F4AD}",
        "ticket": "\u{1F3AB}",
        "tickets": "\u{1F39F}",
        "tiger": "\u{1F42F}",
        "tiger2": "\u{1F405}",
        "timer_clock": "\u23F2",
        "tipping_hand_man": "\u{1F481}&zwj;\u2642\uFE0F",
        "tired_face": "\u{1F62B}",
        "tm": "\u2122\uFE0F",
        "toilet": "\u{1F6BD}",
        "tokyo_tower": "\u{1F5FC}",
        "tomato": "\u{1F345}",
        "tongue": "\u{1F445}",
        "top": "\u{1F51D}",
        "tophat": "\u{1F3A9}",
        "tornado": "\u{1F32A}",
        "trackball": "\u{1F5B2}",
        "tractor": "\u{1F69C}",
        "traffic_light": "\u{1F6A5}",
        "train": "\u{1F68B}",
        "train2": "\u{1F686}",
        "tram": "\u{1F68A}",
        "triangular_flag_on_post": "\u{1F6A9}",
        "triangular_ruler": "\u{1F4D0}",
        "trident": "\u{1F531}",
        "triumph": "\u{1F624}",
        "trolleybus": "\u{1F68E}",
        "trophy": "\u{1F3C6}",
        "tropical_drink": "\u{1F379}",
        "tropical_fish": "\u{1F420}",
        "truck": "\u{1F69A}",
        "trumpet": "\u{1F3BA}",
        "tulip": "\u{1F337}",
        "tumbler_glass": "\u{1F943}",
        "turkey": "\u{1F983}",
        "turtle": "\u{1F422}",
        "tv": "\u{1F4FA}",
        "twisted_rightwards_arrows": "\u{1F500}",
        "two_hearts": "\u{1F495}",
        "two_men_holding_hands": "\u{1F46C}",
        "two_women_holding_hands": "\u{1F46D}",
        "u5272": "\u{1F239}",
        "u5408": "\u{1F234}",
        "u55b6": "\u{1F23A}",
        "u6307": "\u{1F22F}\uFE0F",
        "u6708": "\u{1F237}\uFE0F",
        "u6709": "\u{1F236}",
        "u6e80": "\u{1F235}",
        "u7121": "\u{1F21A}\uFE0F",
        "u7533": "\u{1F238}",
        "u7981": "\u{1F232}",
        "u7a7a": "\u{1F233}",
        "umbrella": "\u2614\uFE0F",
        "unamused": "\u{1F612}",
        "underage": "\u{1F51E}",
        "unicorn": "\u{1F984}",
        "unlock": "\u{1F513}",
        "up": "\u{1F199}",
        "upside_down_face": "\u{1F643}",
        "v": "\u270C\uFE0F",
        "vertical_traffic_light": "\u{1F6A6}",
        "vhs": "\u{1F4FC}",
        "vibration_mode": "\u{1F4F3}",
        "video_camera": "\u{1F4F9}",
        "video_game": "\u{1F3AE}",
        "violin": "\u{1F3BB}",
        "virgo": "\u264D\uFE0F",
        "volcano": "\u{1F30B}",
        "volleyball": "\u{1F3D0}",
        "vs": "\u{1F19A}",
        "vulcan_salute": "\u{1F596}",
        "walking_man": "\u{1F6B6}",
        "walking_woman": "\u{1F6B6}&zwj;\u2640\uFE0F",
        "waning_crescent_moon": "\u{1F318}",
        "waning_gibbous_moon": "\u{1F316}",
        "warning": "\u26A0\uFE0F",
        "wastebasket": "\u{1F5D1}",
        "watch": "\u231A\uFE0F",
        "water_buffalo": "\u{1F403}",
        "watermelon": "\u{1F349}",
        "wave": "\u{1F44B}",
        "wavy_dash": "\u3030\uFE0F",
        "waxing_crescent_moon": "\u{1F312}",
        "wc": "\u{1F6BE}",
        "weary": "\u{1F629}",
        "wedding": "\u{1F492}",
        "weight_lifting_man": "\u{1F3CB}\uFE0F",
        "weight_lifting_woman": "\u{1F3CB}\uFE0F&zwj;\u2640\uFE0F",
        "whale": "\u{1F433}",
        "whale2": "\u{1F40B}",
        "wheel_of_dharma": "\u2638\uFE0F",
        "wheelchair": "\u267F\uFE0F",
        "white_check_mark": "\u2705",
        "white_circle": "\u26AA\uFE0F",
        "white_flag": "\u{1F3F3}\uFE0F",
        "white_flower": "\u{1F4AE}",
        "white_large_square": "\u2B1C\uFE0F",
        "white_medium_small_square": "\u25FD\uFE0F",
        "white_medium_square": "\u25FB\uFE0F",
        "white_small_square": "\u25AB\uFE0F",
        "white_square_button": "\u{1F533}",
        "wilted_flower": "\u{1F940}",
        "wind_chime": "\u{1F390}",
        "wind_face": "\u{1F32C}",
        "wine_glass": "\u{1F377}",
        "wink": "\u{1F609}",
        "wolf": "\u{1F43A}",
        "woman": "\u{1F469}",
        "woman_artist": "\u{1F469}&zwj;\u{1F3A8}",
        "woman_astronaut": "\u{1F469}&zwj;\u{1F680}",
        "woman_cartwheeling": "\u{1F938}&zwj;\u2640\uFE0F",
        "woman_cook": "\u{1F469}&zwj;\u{1F373}",
        "woman_facepalming": "\u{1F926}&zwj;\u2640\uFE0F",
        "woman_factory_worker": "\u{1F469}&zwj;\u{1F3ED}",
        "woman_farmer": "\u{1F469}&zwj;\u{1F33E}",
        "woman_firefighter": "\u{1F469}&zwj;\u{1F692}",
        "woman_health_worker": "\u{1F469}&zwj;\u2695\uFE0F",
        "woman_judge": "\u{1F469}&zwj;\u2696\uFE0F",
        "woman_juggling": "\u{1F939}&zwj;\u2640\uFE0F",
        "woman_mechanic": "\u{1F469}&zwj;\u{1F527}",
        "woman_office_worker": "\u{1F469}&zwj;\u{1F4BC}",
        "woman_pilot": "\u{1F469}&zwj;\u2708\uFE0F",
        "woman_playing_handball": "\u{1F93E}&zwj;\u2640\uFE0F",
        "woman_playing_water_polo": "\u{1F93D}&zwj;\u2640\uFE0F",
        "woman_scientist": "\u{1F469}&zwj;\u{1F52C}",
        "woman_shrugging": "\u{1F937}&zwj;\u2640\uFE0F",
        "woman_singer": "\u{1F469}&zwj;\u{1F3A4}",
        "woman_student": "\u{1F469}&zwj;\u{1F393}",
        "woman_teacher": "\u{1F469}&zwj;\u{1F3EB}",
        "woman_technologist": "\u{1F469}&zwj;\u{1F4BB}",
        "woman_with_turban": "\u{1F473}&zwj;\u2640\uFE0F",
        "womans_clothes": "\u{1F45A}",
        "womans_hat": "\u{1F452}",
        "women_wrestling": "\u{1F93C}&zwj;\u2640\uFE0F",
        "womens": "\u{1F6BA}",
        "world_map": "\u{1F5FA}",
        "worried": "\u{1F61F}",
        "wrench": "\u{1F527}",
        "writing_hand": "\u270D\uFE0F",
        "x": "\u274C",
        "yellow_heart": "\u{1F49B}",
        "yen": "\u{1F4B4}",
        "yin_yang": "\u262F\uFE0F",
        "yum": "\u{1F60B}",
        "zap": "\u26A1\uFE0F",
        "zipper_mouth_face": "\u{1F910}",
        "zzz": "\u{1F4A4}",
        /* special emojis :P */
        "octocat": '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
        "showdown": `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>`
      };
      showdown.Converter = function(converterOptions) {
        "use strict";
        var options = {}, langExtensions = [], outputModifiers = [], listeners = {}, setConvFlavor = setFlavor, metadata = {
          parsed: {},
          raw: "",
          format: ""
        };
        _constructor();
        function _constructor() {
          converterOptions = converterOptions || {};
          for (var gOpt in globalOptions) {
            if (globalOptions.hasOwnProperty(gOpt)) {
              options[gOpt] = globalOptions[gOpt];
            }
          }
          if (typeof converterOptions === "object") {
            for (var opt in converterOptions) {
              if (converterOptions.hasOwnProperty(opt)) {
                options[opt] = converterOptions[opt];
              }
            }
          } else {
            throw Error("Converter expects the passed parameter to be an object, but " + typeof converterOptions + " was passed instead.");
          }
          if (options.extensions) {
            showdown.helper.forEach(options.extensions, _parseExtension);
          }
        }
        function _parseExtension(ext, name) {
          name = name || null;
          if (showdown.helper.isString(ext)) {
            ext = showdown.helper.stdExtName(ext);
            name = ext;
            if (showdown.extensions[ext]) {
              console.warn("DEPRECATION WARNING: " + ext + " is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!");
              legacyExtensionLoading(showdown.extensions[ext], ext);
              return;
            } else if (!showdown.helper.isUndefined(extensions[ext])) {
              ext = extensions[ext];
            } else {
              throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
            }
          }
          if (typeof ext === "function") {
            ext = ext();
          }
          if (!showdown.helper.isArray(ext)) {
            ext = [ext];
          }
          var validExt = validate(ext, name);
          if (!validExt.valid) {
            throw Error(validExt.error);
          }
          for (var i = 0; i < ext.length; ++i) {
            switch (ext[i].type) {
              case "lang":
                langExtensions.push(ext[i]);
                break;
              case "output":
                outputModifiers.push(ext[i]);
                break;
            }
            if (ext[i].hasOwnProperty("listeners")) {
              for (var ln in ext[i].listeners) {
                if (ext[i].listeners.hasOwnProperty(ln)) {
                  listen(ln, ext[i].listeners[ln]);
                }
              }
            }
          }
        }
        function legacyExtensionLoading(ext, name) {
          if (typeof ext === "function") {
            ext = ext(new showdown.Converter());
          }
          if (!showdown.helper.isArray(ext)) {
            ext = [ext];
          }
          var valid = validate(ext, name);
          if (!valid.valid) {
            throw Error(valid.error);
          }
          for (var i = 0; i < ext.length; ++i) {
            switch (ext[i].type) {
              case "lang":
                langExtensions.push(ext[i]);
                break;
              case "output":
                outputModifiers.push(ext[i]);
                break;
              default:
                throw Error("Extension loader error: Type unrecognized!!!");
            }
          }
        }
        function listen(name, callback) {
          if (!showdown.helper.isString(name)) {
            throw Error("Invalid argument in converter.listen() method: name must be a string, but " + typeof name + " given");
          }
          if (typeof callback !== "function") {
            throw Error("Invalid argument in converter.listen() method: callback must be a function, but " + typeof callback + " given");
          }
          if (!listeners.hasOwnProperty(name)) {
            listeners[name] = [];
          }
          listeners[name].push(callback);
        }
        function rTrimInputText(text) {
          var rsp = text.match(/^\s*/)[0].length, rgx = new RegExp("^\\s{0," + rsp + "}", "gm");
          return text.replace(rgx, "");
        }
        this._dispatch = function dispatch(evtName, text, options2, globals) {
          if (listeners.hasOwnProperty(evtName)) {
            for (var ei = 0; ei < listeners[evtName].length; ++ei) {
              var nText = listeners[evtName][ei](evtName, text, this, options2, globals);
              if (nText && typeof nText !== "undefined") {
                text = nText;
              }
            }
          }
          return text;
        };
        this.listen = function(name, callback) {
          listen(name, callback);
          return this;
        };
        this.makeHtml = function(text) {
          if (!text) {
            return text;
          }
          var globals = {
            gHtmlBlocks: [],
            gHtmlMdBlocks: [],
            gHtmlSpans: [],
            gUrls: {},
            gTitles: {},
            gDimensions: {},
            gListLevel: 0,
            hashLinkCounts: {},
            langExtensions,
            outputModifiers,
            converter: this,
            ghCodeBlocks: [],
            metadata: {
              parsed: {},
              raw: "",
              format: ""
            }
          };
          text = text.replace(//g, "\xA8T");
          text = text.replace(/\$/g, "\xA8D");
          text = text.replace(/\r\n/g, "\n");
          text = text.replace(/\r/g, "\n");
          text = text.replace(/\u00A0/g, "&nbsp;");
          if (options.smartIndentationFix) {
            text = rTrimInputText(text);
          }
          text = "\n\n" + text + "\n\n";
          text = showdown.subParser("detab")(text, options, globals);
          text = text.replace(/^[ \t]+$/mg, "");
          showdown.helper.forEach(langExtensions, function(ext) {
            text = showdown.subParser("runExtension")(ext, text, options, globals);
          });
          text = showdown.subParser("metadata")(text, options, globals);
          text = showdown.subParser("hashPreCodeTags")(text, options, globals);
          text = showdown.subParser("githubCodeBlocks")(text, options, globals);
          text = showdown.subParser("hashHTMLBlocks")(text, options, globals);
          text = showdown.subParser("hashCodeTags")(text, options, globals);
          text = showdown.subParser("stripLinkDefinitions")(text, options, globals);
          text = showdown.subParser("blockGamut")(text, options, globals);
          text = showdown.subParser("unhashHTMLSpans")(text, options, globals);
          text = showdown.subParser("unescapeSpecialChars")(text, options, globals);
          text = text.replace(/D/g, "$$");
          text = text.replace(/T/g, "\xA8");
          text = showdown.subParser("completeHTMLDocument")(text, options, globals);
          showdown.helper.forEach(outputModifiers, function(ext) {
            text = showdown.subParser("runExtension")(ext, text, options, globals);
          });
          metadata = globals.metadata;
          return text;
        };
        this.makeMarkdown = this.makeMd = function(src, HTMLParser) {
          src = src.replace(/\r\n/g, "\n");
          src = src.replace(/\r/g, "\n");
          src = src.replace(/>[ \t]+</, ">\xA8NBSP;<");
          if (!HTMLParser) {
            if (window && window.document) {
              HTMLParser = window.document;
            } else {
              throw new Error("HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM");
            }
          }
          var doc = HTMLParser.createElement("div");
          doc.innerHTML = src;
          var globals = {
            preList: substitutePreCodeTags(doc)
          };
          clean(doc);
          var nodes = doc.childNodes, mdDoc = "";
          for (var i = 0; i < nodes.length; i++) {
            mdDoc += showdown.subParser("makeMarkdown.node")(nodes[i], globals);
          }
          function clean(node) {
            for (var n = 0; n < node.childNodes.length; ++n) {
              var child = node.childNodes[n];
              if (child.nodeType === 3) {
                if (!/\S/.test(child.nodeValue)) {
                  node.removeChild(child);
                  --n;
                } else {
                  child.nodeValue = child.nodeValue.split("\n").join(" ");
                  child.nodeValue = child.nodeValue.replace(/(\s)+/g, "$1");
                }
              } else if (child.nodeType === 1) {
                clean(child);
              }
            }
          }
          function substitutePreCodeTags(doc2) {
            var pres = doc2.querySelectorAll("pre"), presPH = [];
            for (var i2 = 0; i2 < pres.length; ++i2) {
              if (pres[i2].childElementCount === 1 && pres[i2].firstChild.tagName.toLowerCase() === "code") {
                var content = pres[i2].firstChild.innerHTML.trim(), language = pres[i2].firstChild.getAttribute("data-language") || "";
                if (language === "") {
                  var classes = pres[i2].firstChild.className.split(" ");
                  for (var c = 0; c < classes.length; ++c) {
                    var matches = classes[c].match(/^language-(.+)$/);
                    if (matches !== null) {
                      language = matches[1];
                      break;
                    }
                  }
                }
                content = showdown.helper.unescapeHTMLEntities(content);
                presPH.push(content);
                pres[i2].outerHTML = '<precode language="' + language + '" precodenum="' + i2.toString() + '"></precode>';
              } else {
                presPH.push(pres[i2].innerHTML);
                pres[i2].innerHTML = "";
                pres[i2].setAttribute("prenum", i2.toString());
              }
            }
            return presPH;
          }
          return mdDoc;
        };
        this.setOption = function(key, value) {
          options[key] = value;
        };
        this.getOption = function(key) {
          return options[key];
        };
        this.getOptions = function() {
          return options;
        };
        this.addExtension = function(extension, name) {
          name = name || null;
          _parseExtension(extension, name);
        };
        this.useExtension = function(extensionName) {
          _parseExtension(extensionName);
        };
        this.setFlavor = function(name) {
          if (!flavor.hasOwnProperty(name)) {
            throw Error(name + " flavor was not found");
          }
          var preset = flavor[name];
          setConvFlavor = name;
          for (var option in preset) {
            if (preset.hasOwnProperty(option)) {
              options[option] = preset[option];
            }
          }
        };
        this.getFlavor = function() {
          return setConvFlavor;
        };
        this.removeExtension = function(extension) {
          if (!showdown.helper.isArray(extension)) {
            extension = [extension];
          }
          for (var a = 0; a < extension.length; ++a) {
            var ext = extension[a];
            for (var i = 0; i < langExtensions.length; ++i) {
              if (langExtensions[i] === ext) {
                langExtensions[i].splice(i, 1);
              }
            }
            for (var ii = 0; ii < outputModifiers.length; ++i) {
              if (outputModifiers[ii] === ext) {
                outputModifiers[ii].splice(i, 1);
              }
            }
          }
        };
        this.getAllExtensions = function() {
          return {
            language: langExtensions,
            output: outputModifiers
          };
        };
        this.getMetadata = function(raw) {
          if (raw) {
            return metadata.raw;
          } else {
            return metadata.parsed;
          }
        };
        this.getMetadataFormat = function() {
          return metadata.format;
        };
        this._setMetadataPair = function(key, value) {
          metadata.parsed[key] = value;
        };
        this._setMetadataFormat = function(format) {
          metadata.format = format;
        };
        this._setMetadataRaw = function(raw) {
          metadata.raw = raw;
        };
      };
      showdown.subParser("anchors", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("anchors.before", text, options, globals);
        var writeAnchorTag = function(wholeMatch, linkText, linkId, url, m5, m6, title) {
          if (showdown.helper.isUndefined(title)) {
            title = "";
          }
          linkId = linkId.toLowerCase();
          if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
            url = "";
          } else if (!url) {
            if (!linkId) {
              linkId = linkText.toLowerCase().replace(/ ?\n/g, " ");
            }
            url = "#" + linkId;
            if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
              url = globals.gUrls[linkId];
              if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
                title = globals.gTitles[linkId];
              }
            } else {
              return wholeMatch;
            }
          }
          url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
          var result = '<a href="' + url + '"';
          if (title !== "" && title !== null) {
            title = title.replace(/"/g, "&quot;");
            title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
            result += ' title="' + title + '"';
          }
          if (options.openLinksInNewWindow && !/^#/.test(url)) {
            result += ' rel="noopener noreferrer" target="\xA8E95Eblank"';
          }
          result += ">" + linkText + "</a>";
          return result;
        };
        text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);
        text = text.replace(
          /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
          writeAnchorTag
        );
        text = text.replace(
          /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
          writeAnchorTag
        );
        text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);
        if (options.ghMentions) {
          text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function(wm, st, escape2, mentions, username) {
            if (escape2 === "\\") {
              return st + mentions;
            }
            if (!showdown.helper.isString(options.ghMentionsLink)) {
              throw new Error("ghMentionsLink option must be a string");
            }
            var lnk = options.ghMentionsLink.replace(/\{u}/g, username), target = "";
            if (options.openLinksInNewWindow) {
              target = ' rel="noopener noreferrer" target="\xA8E95Eblank"';
            }
            return st + '<a href="' + lnk + '"' + target + ">" + mentions + "</a>";
          });
        }
        text = globals.converter._dispatch("anchors.after", text, options, globals);
        return text;
      });
      var simpleURLRegex = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi, simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi, delimUrlRegex = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi, simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi, delimMailRegex = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi, replaceLink = function(options) {
        "use strict";
        return function(wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
          link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
          var lnkTxt = link, append = "", target = "", lmc = leadingMagicChars || "", tmc = trailingMagicChars || "";
          if (/^www\./i.test(link)) {
            link = link.replace(/^www\./i, "http://www.");
          }
          if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
            append = trailingPunctuation;
          }
          if (options.openLinksInNewWindow) {
            target = ' rel="noopener noreferrer" target="\xA8E95Eblank"';
          }
          return lmc + '<a href="' + link + '"' + target + ">" + lnkTxt + "</a>" + append + tmc;
        };
      }, replaceMail = function(options, globals) {
        "use strict";
        return function(wholeMatch, b, mail) {
          var href = "mailto:";
          b = b || "";
          mail = showdown.subParser("unescapeSpecialChars")(mail, options, globals);
          if (options.encodeEmails) {
            href = showdown.helper.encodeEmailAddress(href + mail);
            mail = showdown.helper.encodeEmailAddress(mail);
          } else {
            href = href + mail;
          }
          return b + '<a href="' + href + '">' + mail + "</a>";
        };
      };
      showdown.subParser("autoLinks", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("autoLinks.before", text, options, globals);
        text = text.replace(delimUrlRegex, replaceLink(options));
        text = text.replace(delimMailRegex, replaceMail(options, globals));
        text = globals.converter._dispatch("autoLinks.after", text, options, globals);
        return text;
      });
      showdown.subParser("simplifiedAutoLinks", function(text, options, globals) {
        "use strict";
        if (!options.simplifiedAutoLink) {
          return text;
        }
        text = globals.converter._dispatch("simplifiedAutoLinks.before", text, options, globals);
        if (options.excludeTrailingPunctuationFromURLs) {
          text = text.replace(simpleURLRegex2, replaceLink(options));
        } else {
          text = text.replace(simpleURLRegex, replaceLink(options));
        }
        text = text.replace(simpleMailRegex, replaceMail(options, globals));
        text = globals.converter._dispatch("simplifiedAutoLinks.after", text, options, globals);
        return text;
      });
      showdown.subParser("blockGamut", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("blockGamut.before", text, options, globals);
        text = showdown.subParser("blockQuotes")(text, options, globals);
        text = showdown.subParser("headers")(text, options, globals);
        text = showdown.subParser("horizontalRule")(text, options, globals);
        text = showdown.subParser("lists")(text, options, globals);
        text = showdown.subParser("codeBlocks")(text, options, globals);
        text = showdown.subParser("tables")(text, options, globals);
        text = showdown.subParser("hashHTMLBlocks")(text, options, globals);
        text = showdown.subParser("paragraphs")(text, options, globals);
        text = globals.converter._dispatch("blockGamut.after", text, options, globals);
        return text;
      });
      showdown.subParser("blockQuotes", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("blockQuotes.before", text, options, globals);
        text = text + "\n\n";
        var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
        if (options.splitAdjacentBlockquotes) {
          rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
        }
        text = text.replace(rgx, function(bq) {
          bq = bq.replace(/^[ \t]*>[ \t]?/gm, "");
          bq = bq.replace(/0/g, "");
          bq = bq.replace(/^[ \t]+$/gm, "");
          bq = showdown.subParser("githubCodeBlocks")(bq, options, globals);
          bq = showdown.subParser("blockGamut")(bq, options, globals);
          bq = bq.replace(/(^|\n)/g, "$1  ");
          bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function(wholeMatch, m1) {
            var pre = m1;
            pre = pre.replace(/^  /mg, "\xA80");
            pre = pre.replace(/0/g, "");
            return pre;
          });
          return showdown.subParser("hashBlock")("<blockquote>\n" + bq + "\n</blockquote>", options, globals);
        });
        text = globals.converter._dispatch("blockQuotes.after", text, options, globals);
        return text;
      });
      showdown.subParser("codeBlocks", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("codeBlocks.before", text, options, globals);
        text += "\xA80";
        var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g;
        text = text.replace(pattern, function(wholeMatch, m1, m2) {
          var codeblock = m1, nextChar = m2, end = "\n";
          codeblock = showdown.subParser("outdent")(codeblock, options, globals);
          codeblock = showdown.subParser("encodeCode")(codeblock, options, globals);
          codeblock = showdown.subParser("detab")(codeblock, options, globals);
          codeblock = codeblock.replace(/^\n+/g, "");
          codeblock = codeblock.replace(/\n+$/g, "");
          if (options.omitExtraWLInCodeBlocks) {
            end = "";
          }
          codeblock = "<pre><code>" + codeblock + end + "</code></pre>";
          return showdown.subParser("hashBlock")(codeblock, options, globals) + nextChar;
        });
        text = text.replace(/0/, "");
        text = globals.converter._dispatch("codeBlocks.after", text, options, globals);
        return text;
      });
      showdown.subParser("codeSpans", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("codeSpans.before", text, options, globals);
        if (typeof text === "undefined") {
          text = "";
        }
        text = text.replace(
          /(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
          function(wholeMatch, m1, m2, m3) {
            var c = m3;
            c = c.replace(/^([ \t]*)/g, "");
            c = c.replace(/[ \t]*$/g, "");
            c = showdown.subParser("encodeCode")(c, options, globals);
            c = m1 + "<code>" + c + "</code>";
            c = showdown.subParser("hashHTMLSpans")(c, options, globals);
            return c;
          }
        );
        text = globals.converter._dispatch("codeSpans.after", text, options, globals);
        return text;
      });
      showdown.subParser("completeHTMLDocument", function(text, options, globals) {
        "use strict";
        if (!options.completeHTMLDocument) {
          return text;
        }
        text = globals.converter._dispatch("completeHTMLDocument.before", text, options, globals);
        var doctype = "html", doctypeParsed = "<!DOCTYPE HTML>\n", title = "", charset = '<meta charset="utf-8">\n', lang = "", metadata = "";
        if (typeof globals.metadata.parsed.doctype !== "undefined") {
          doctypeParsed = "<!DOCTYPE " + globals.metadata.parsed.doctype + ">\n";
          doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
          if (doctype === "html" || doctype === "html5") {
            charset = '<meta charset="utf-8">';
          }
        }
        for (var meta in globals.metadata.parsed) {
          if (globals.metadata.parsed.hasOwnProperty(meta)) {
            switch (meta.toLowerCase()) {
              case "doctype":
                break;
              case "title":
                title = "<title>" + globals.metadata.parsed.title + "</title>\n";
                break;
              case "charset":
                if (doctype === "html" || doctype === "html5") {
                  charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
                } else {
                  charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
                }
                break;
              case "language":
              case "lang":
                lang = ' lang="' + globals.metadata.parsed[meta] + '"';
                metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
                break;
              default:
                metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
            }
          }
        }
        text = doctypeParsed + "<html" + lang + ">\n<head>\n" + title + charset + metadata + "</head>\n<body>\n" + text.trim() + "\n</body>\n</html>";
        text = globals.converter._dispatch("completeHTMLDocument.after", text, options, globals);
        return text;
      });
      showdown.subParser("detab", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("detab.before", text, options, globals);
        text = text.replace(/\t(?=\t)/g, "    ");
        text = text.replace(/\t/g, "\xA8A\xA8B");
        text = text.replace(/B(.+?)A/g, function(wholeMatch, m1) {
          var leadingText = m1, numSpaces = 4 - leadingText.length % 4;
          for (var i = 0; i < numSpaces; i++) {
            leadingText += " ";
          }
          return leadingText;
        });
        text = text.replace(/A/g, "    ");
        text = text.replace(/B/g, "");
        text = globals.converter._dispatch("detab.after", text, options, globals);
        return text;
      });
      showdown.subParser("ellipsis", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("ellipsis.before", text, options, globals);
        text = text.replace(/\.\.\./g, "\u2026");
        text = globals.converter._dispatch("ellipsis.after", text, options, globals);
        return text;
      });
      showdown.subParser("emoji", function(text, options, globals) {
        "use strict";
        if (!options.emoji) {
          return text;
        }
        text = globals.converter._dispatch("emoji.before", text, options, globals);
        var emojiRgx = /:([\S]+?):/g;
        text = text.replace(emojiRgx, function(wm, emojiCode) {
          if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
            return showdown.helper.emojis[emojiCode];
          }
          return wm;
        });
        text = globals.converter._dispatch("emoji.after", text, options, globals);
        return text;
      });
      showdown.subParser("encodeAmpsAndAngles", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("encodeAmpsAndAngles.before", text, options, globals);
        text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;");
        text = text.replace(/<(?![a-z\/?$!])/gi, "&lt;");
        text = text.replace(/</g, "&lt;");
        text = text.replace(/>/g, "&gt;");
        text = globals.converter._dispatch("encodeAmpsAndAngles.after", text, options, globals);
        return text;
      });
      showdown.subParser("encodeBackslashEscapes", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("encodeBackslashEscapes.before", text, options, globals);
        text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
        text = text.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);
        text = globals.converter._dispatch("encodeBackslashEscapes.after", text, options, globals);
        return text;
      });
      showdown.subParser("encodeCode", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("encodeCode.before", text, options, globals);
        text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);
        text = globals.converter._dispatch("encodeCode.after", text, options, globals);
        return text;
      });
      showdown.subParser("escapeSpecialCharsWithinTagAttributes", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("escapeSpecialCharsWithinTagAttributes.before", text, options, globals);
        var tags = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi, comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;
        text = text.replace(tags, function(wholeMatch) {
          return wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`").replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
        });
        text = text.replace(comments, function(wholeMatch) {
          return wholeMatch.replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
        });
        text = globals.converter._dispatch("escapeSpecialCharsWithinTagAttributes.after", text, options, globals);
        return text;
      });
      showdown.subParser("githubCodeBlocks", function(text, options, globals) {
        "use strict";
        if (!options.ghCodeBlocks) {
          return text;
        }
        text = globals.converter._dispatch("githubCodeBlocks.before", text, options, globals);
        text += "\xA80";
        text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function(wholeMatch, delim, language, codeblock) {
          var end = options.omitExtraWLInCodeBlocks ? "" : "\n";
          codeblock = showdown.subParser("encodeCode")(codeblock, options, globals);
          codeblock = showdown.subParser("detab")(codeblock, options, globals);
          codeblock = codeblock.replace(/^\n+/g, "");
          codeblock = codeblock.replace(/\n+$/g, "");
          codeblock = "<pre><code" + (language ? ' class="' + language + " language-" + language + '"' : "") + ">" + codeblock + end + "</code></pre>";
          codeblock = showdown.subParser("hashBlock")(codeblock, options, globals);
          return "\n\n\xA8G" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
        });
        text = text.replace(/0/, "");
        return globals.converter._dispatch("githubCodeBlocks.after", text, options, globals);
      });
      showdown.subParser("hashBlock", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashBlock.before", text, options, globals);
        text = text.replace(/(^\n+|\n+$)/g, "");
        text = "\n\n\xA8K" + (globals.gHtmlBlocks.push(text) - 1) + "K\n\n";
        text = globals.converter._dispatch("hashBlock.after", text, options, globals);
        return text;
      });
      showdown.subParser("hashCodeTags", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashCodeTags.before", text, options, globals);
        var repFunc = function(wholeMatch, match, left, right) {
          var codeblock = left + showdown.subParser("encodeCode")(match, options, globals) + right;
          return "\xA8C" + (globals.gHtmlSpans.push(codeblock) - 1) + "C";
        };
        text = showdown.helper.replaceRecursiveRegExp(text, repFunc, "<code\\b[^>]*>", "</code>", "gim");
        text = globals.converter._dispatch("hashCodeTags.after", text, options, globals);
        return text;
      });
      showdown.subParser("hashElement", function(text, options, globals) {
        "use strict";
        return function(wholeMatch, m1) {
          var blockText = m1;
          blockText = blockText.replace(/\n\n/g, "\n");
          blockText = blockText.replace(/^\n/, "");
          blockText = blockText.replace(/\n+$/g, "");
          blockText = "\n\n\xA8K" + (globals.gHtmlBlocks.push(blockText) - 1) + "K\n\n";
          return blockText;
        };
      });
      showdown.subParser("hashHTMLBlocks", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashHTMLBlocks.before", text, options, globals);
        var blockTags = [
          "pre",
          "div",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "blockquote",
          "table",
          "dl",
          "ol",
          "ul",
          "script",
          "noscript",
          "form",
          "fieldset",
          "iframe",
          "math",
          "style",
          "section",
          "header",
          "footer",
          "nav",
          "article",
          "aside",
          "address",
          "audio",
          "canvas",
          "figure",
          "hgroup",
          "output",
          "video",
          "p"
        ], repFunc = function(wholeMatch, match, left, right) {
          var txt = wholeMatch;
          if (left.search(/\bmarkdown\b/) !== -1) {
            txt = left + globals.converter.makeHtml(match) + right;
          }
          return "\n\n\xA8K" + (globals.gHtmlBlocks.push(txt) - 1) + "K\n\n";
        };
        if (options.backslashEscapesHTMLTags) {
          text = text.replace(/\\<(\/?[^>]+?)>/g, function(wm, inside) {
            return "&lt;" + inside + "&gt;";
          });
        }
        for (var i = 0; i < blockTags.length; ++i) {
          var opTagPos, rgx1 = new RegExp("^ {0,3}(<" + blockTags[i] + "\\b[^>]*>)", "im"), patLeft = "<" + blockTags[i] + "\\b[^>]*>", patRight = "</" + blockTags[i] + ">";
          while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {
            var subTexts = showdown.helper.splitAtIndex(text, opTagPos), newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, "im");
            if (newSubText1 === subTexts[1]) {
              break;
            }
            text = subTexts[0].concat(newSubText1);
          }
        }
        text = text.replace(
          /(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
          showdown.subParser("hashElement")(text, options, globals)
        );
        text = showdown.helper.replaceRecursiveRegExp(text, function(txt) {
          return "\n\n\xA8K" + (globals.gHtmlBlocks.push(txt) - 1) + "K\n\n";
        }, "^ {0,3}<!--", "-->", "gm");
        text = text.replace(
          /(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
          showdown.subParser("hashElement")(text, options, globals)
        );
        text = globals.converter._dispatch("hashHTMLBlocks.after", text, options, globals);
        return text;
      });
      showdown.subParser("hashHTMLSpans", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashHTMLSpans.before", text, options, globals);
        function hashHTMLSpan(html) {
          return "\xA8C" + (globals.gHtmlSpans.push(html) - 1) + "C";
        }
        text = text.replace(/<[^>]+?\/>/gi, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = text.replace(/<[^>]+?>/gi, function(wm) {
          return hashHTMLSpan(wm);
        });
        text = globals.converter._dispatch("hashHTMLSpans.after", text, options, globals);
        return text;
      });
      showdown.subParser("unhashHTMLSpans", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("unhashHTMLSpans.before", text, options, globals);
        for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
          var repText = globals.gHtmlSpans[i], limit = 0;
          while (/C(\d+)C/.test(repText)) {
            var num = RegExp.$1;
            repText = repText.replace("\xA8C" + num + "C", globals.gHtmlSpans[num]);
            if (limit === 10) {
              console.error("maximum nesting of 10 spans reached!!!");
              break;
            }
            ++limit;
          }
          text = text.replace("\xA8C" + i + "C", repText);
        }
        text = globals.converter._dispatch("unhashHTMLSpans.after", text, options, globals);
        return text;
      });
      showdown.subParser("hashPreCodeTags", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("hashPreCodeTags.before", text, options, globals);
        var repFunc = function(wholeMatch, match, left, right) {
          var codeblock = left + showdown.subParser("encodeCode")(match, options, globals) + right;
          return "\n\n\xA8G" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
        };
        text = showdown.helper.replaceRecursiveRegExp(text, repFunc, "^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>", "^ {0,3}</code>\\s*</pre>", "gim");
        text = globals.converter._dispatch("hashPreCodeTags.after", text, options, globals);
        return text;
      });
      showdown.subParser("headers", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("headers.before", text, options, globals);
        var headerLevelStart = isNaN(parseInt(options.headerLevelStart)) ? 1 : parseInt(options.headerLevelStart), setextRegexH1 = options.smoothLivePreview ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm, setextRegexH2 = options.smoothLivePreview ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
        text = text.replace(setextRegexH1, function(wholeMatch, m1) {
          var spanGamut = showdown.subParser("spanGamut")(m1, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
          return showdown.subParser("hashBlock")(hashBlock, options, globals);
        });
        text = text.replace(setextRegexH2, function(matchFound, m1) {
          var spanGamut = showdown.subParser("spanGamut")(m1, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart + 1, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
          return showdown.subParser("hashBlock")(hashBlock, options, globals);
        });
        var atxStyle = options.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
        text = text.replace(atxStyle, function(wholeMatch, m1, m2) {
          var hText = m2;
          if (options.customizedHeaderId) {
            hText = m2.replace(/\s?\{([^{]+?)}\s*$/, "");
          }
          var span = showdown.subParser("spanGamut")(hText, options, globals), hID = options.noHeaderId ? "" : ' id="' + headerId(m2) + '"', hLevel = headerLevelStart - 1 + m1.length, header = "<h" + hLevel + hID + ">" + span + "</h" + hLevel + ">";
          return showdown.subParser("hashBlock")(header, options, globals);
        });
        function headerId(m) {
          var title, prefix;
          if (options.customizedHeaderId) {
            var match = m.match(/\{([^{]+?)}\s*$/);
            if (match && match[1]) {
              m = match[1];
            }
          }
          title = m;
          if (showdown.helper.isString(options.prefixHeaderId)) {
            prefix = options.prefixHeaderId;
          } else if (options.prefixHeaderId === true) {
            prefix = "section-";
          } else {
            prefix = "";
          }
          if (!options.rawPrefixHeaderId) {
            title = prefix + title;
          }
          if (options.ghCompatibleHeaderId) {
            title = title.replace(/ /g, "-").replace(/&amp;/g, "").replace(/T/g, "").replace(/D/g, "").replace(/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g, "").toLowerCase();
          } else if (options.rawHeaderId) {
            title = title.replace(/ /g, "-").replace(/&amp;/g, "&").replace(/T/g, "\xA8").replace(/D/g, "$").replace(/["']/g, "-").toLowerCase();
          } else {
            title = title.replace(/[^\w]/g, "").toLowerCase();
          }
          if (options.rawPrefixHeaderId) {
            title = prefix + title;
          }
          if (globals.hashLinkCounts[title]) {
            title = title + "-" + globals.hashLinkCounts[title]++;
          } else {
            globals.hashLinkCounts[title] = 1;
          }
          return title;
        }
        text = globals.converter._dispatch("headers.after", text, options, globals);
        return text;
      });
      showdown.subParser("horizontalRule", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("horizontalRule.before", text, options, globals);
        var key = showdown.subParser("hashBlock")("<hr />", options, globals);
        text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
        text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
        text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);
        text = globals.converter._dispatch("horizontalRule.after", text, options, globals);
        return text;
      });
      showdown.subParser("images", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("images.before", text, options, globals);
        var inlineRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, crazyRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g, base64RegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, referenceRegExp = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g, refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;
        function writeImageTagBase64(wholeMatch, altText, linkId, url, width, height, m5, title) {
          url = url.replace(/\s/g, "");
          return writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title);
        }
        function writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title) {
          var gUrls = globals.gUrls, gTitles = globals.gTitles, gDims = globals.gDimensions;
          linkId = linkId.toLowerCase();
          if (!title) {
            title = "";
          }
          if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
            url = "";
          } else if (url === "" || url === null) {
            if (linkId === "" || linkId === null) {
              linkId = altText.toLowerCase().replace(/ ?\n/g, " ");
            }
            url = "#" + linkId;
            if (!showdown.helper.isUndefined(gUrls[linkId])) {
              url = gUrls[linkId];
              if (!showdown.helper.isUndefined(gTitles[linkId])) {
                title = gTitles[linkId];
              }
              if (!showdown.helper.isUndefined(gDims[linkId])) {
                width = gDims[linkId].width;
                height = gDims[linkId].height;
              }
            } else {
              return wholeMatch;
            }
          }
          altText = altText.replace(/"/g, "&quot;").replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
          url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
          var result = '<img src="' + url + '" alt="' + altText + '"';
          if (title && showdown.helper.isString(title)) {
            title = title.replace(/"/g, "&quot;").replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
            result += ' title="' + title + '"';
          }
          if (width && height) {
            width = width === "*" ? "auto" : width;
            height = height === "*" ? "auto" : height;
            result += ' width="' + width + '"';
            result += ' height="' + height + '"';
          }
          result += " />";
          return result;
        }
        text = text.replace(referenceRegExp, writeImageTag);
        text = text.replace(base64RegExp, writeImageTagBase64);
        text = text.replace(crazyRegExp, writeImageTag);
        text = text.replace(inlineRegExp, writeImageTag);
        text = text.replace(refShortcutRegExp, writeImageTag);
        text = globals.converter._dispatch("images.after", text, options, globals);
        return text;
      });
      showdown.subParser("italicsAndBold", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("italicsAndBold.before", text, options, globals);
        function parseInside(txt, left, right) {
          return left + txt + right;
        }
        if (options.literalMidWordUnderscores) {
          text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
            return parseInside(txt, "<strong><em>", "</em></strong>");
          });
          text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
            return parseInside(txt, "<strong>", "</strong>");
          });
          text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function(wm, txt) {
            return parseInside(txt, "<em>", "</em>");
          });
        } else {
          text = text.replace(/___(\S[\s\S]*?)___/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong><em>", "</em></strong>") : wm;
          });
          text = text.replace(/__(\S[\s\S]*?)__/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong>", "</strong>") : wm;
          });
          text = text.replace(/_([^\s_][\s\S]*?)_/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<em>", "</em>") : wm;
          });
        }
        if (options.literalMidWordAsterisks) {
          text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function(wm, lead, txt) {
            return parseInside(txt, lead + "<strong><em>", "</em></strong>");
          });
          text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function(wm, lead, txt) {
            return parseInside(txt, lead + "<strong>", "</strong>");
          });
          text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function(wm, lead, txt) {
            return parseInside(txt, lead + "<em>", "</em>");
          });
        } else {
          text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong><em>", "</em></strong>") : wm;
          });
          text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<strong>", "</strong>") : wm;
          });
          text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function(wm, m) {
            return /\S$/.test(m) ? parseInside(m, "<em>", "</em>") : wm;
          });
        }
        text = globals.converter._dispatch("italicsAndBold.after", text, options, globals);
        return text;
      });
      showdown.subParser("lists", function(text, options, globals) {
        "use strict";
        function processListItems(listStr, trimTrailing) {
          globals.gListLevel++;
          listStr = listStr.replace(/\n{2,}$/, "\n");
          listStr += "\xA80";
          var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm, isParagraphed = /\n[ \t]*\n(?!0)/.test(listStr);
          if (options.disableForced4SpacesIndentedSublists) {
            rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm;
          }
          listStr = listStr.replace(rgx, function(wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
            checked = checked && checked.trim() !== "";
            var item = showdown.subParser("outdent")(m4, options, globals), bulletStyle = "";
            if (taskbtn && options.tasklists) {
              bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
              item = item.replace(/^[ \t]*\[(x|X| )?]/m, function() {
                var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
                if (checked) {
                  otp += " checked";
                }
                otp += ">";
                return otp;
              });
            }
            item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function(wm2) {
              return "\xA8A" + wm2;
            });
            if (m1 || item.search(/\n{2,}/) > -1) {
              item = showdown.subParser("githubCodeBlocks")(item, options, globals);
              item = showdown.subParser("blockGamut")(item, options, globals);
            } else {
              item = showdown.subParser("lists")(item, options, globals);
              item = item.replace(/\n$/, "");
              item = showdown.subParser("hashHTMLBlocks")(item, options, globals);
              item = item.replace(/\n\n+/g, "\n\n");
              if (isParagraphed) {
                item = showdown.subParser("paragraphs")(item, options, globals);
              } else {
                item = showdown.subParser("spanGamut")(item, options, globals);
              }
            }
            item = item.replace("\xA8A", "");
            item = "<li" + bulletStyle + ">" + item + "</li>\n";
            return item;
          });
          listStr = listStr.replace(/0/g, "");
          globals.gListLevel--;
          if (trimTrailing) {
            listStr = listStr.replace(/\s+$/, "");
          }
          return listStr;
        }
        function styleStartNumber(list, listType) {
          if (listType === "ol") {
            var res = list.match(/^ *(\d+)\./);
            if (res && res[1] !== "1") {
              return ' start="' + res[1] + '"';
            }
          }
          return "";
        }
        function parseConsecutiveLists(list, listType, trimTrailing) {
          var olRgx = options.disableForced4SpacesIndentedSublists ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm, ulRgx = options.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm, counterRxg = listType === "ul" ? olRgx : ulRgx, result = "";
          if (list.search(counterRxg) !== -1) {
            (function parseCL(txt) {
              var pos = txt.search(counterRxg), style2 = styleStartNumber(list, listType);
              if (pos !== -1) {
                result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt.slice(0, pos), !!trimTrailing) + "</" + listType + ">\n";
                listType = listType === "ul" ? "ol" : "ul";
                counterRxg = listType === "ul" ? olRgx : ulRgx;
                parseCL(txt.slice(pos));
              } else {
                result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt, !!trimTrailing) + "</" + listType + ">\n";
              }
            })(list);
          } else {
            var style = styleStartNumber(list, listType);
            result = "\n\n<" + listType + style + ">\n" + processListItems(list, !!trimTrailing) + "</" + listType + ">\n";
          }
          return result;
        }
        text = globals.converter._dispatch("lists.before", text, options, globals);
        text += "\xA80";
        if (globals.gListLevel) {
          text = text.replace(
            /^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
            function(wholeMatch, list, m2) {
              var listType = m2.search(/[*+-]/g) > -1 ? "ul" : "ol";
              return parseConsecutiveLists(list, listType, true);
            }
          );
        } else {
          text = text.replace(
            /(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
            function(wholeMatch, m1, list, m3) {
              var listType = m3.search(/[*+-]/g) > -1 ? "ul" : "ol";
              return parseConsecutiveLists(list, listType, false);
            }
          );
        }
        text = text.replace(/0/, "");
        text = globals.converter._dispatch("lists.after", text, options, globals);
        return text;
      });
      showdown.subParser("metadata", function(text, options, globals) {
        "use strict";
        if (!options.metadata) {
          return text;
        }
        text = globals.converter._dispatch("metadata.before", text, options, globals);
        function parseMetadataContents(content) {
          globals.metadata.raw = content;
          content = content.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
          content = content.replace(/\n {4}/g, " ");
          content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function(wm, key, value) {
            globals.metadata.parsed[key] = value;
            return "";
          });
        }
        text = text.replace(/^\s*+(\S*?)\n([\s\S]+?)\n+\n/, function(wholematch, format, content) {
          parseMetadataContents(content);
          return "\xA8M";
        });
        text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function(wholematch, format, content) {
          if (format) {
            globals.metadata.format = format;
          }
          parseMetadataContents(content);
          return "\xA8M";
        });
        text = text.replace(/M/g, "");
        text = globals.converter._dispatch("metadata.after", text, options, globals);
        return text;
      });
      showdown.subParser("outdent", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("outdent.before", text, options, globals);
        text = text.replace(/^(\t|[ ]{1,4})/gm, "\xA80");
        text = text.replace(/0/g, "");
        text = globals.converter._dispatch("outdent.after", text, options, globals);
        return text;
      });
      showdown.subParser("paragraphs", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("paragraphs.before", text, options, globals);
        text = text.replace(/^\n+/g, "");
        text = text.replace(/\n+$/g, "");
        var grafs = text.split(/\n{2,}/g), grafsOut = [], end = grafs.length;
        for (var i = 0; i < end; i++) {
          var str = grafs[i];
          if (str.search(/(K|G)(\d+)\1/g) >= 0) {
            grafsOut.push(str);
          } else if (str.search(/\S/) >= 0) {
            str = showdown.subParser("spanGamut")(str, options, globals);
            str = str.replace(/^([ \t]*)/g, "<p>");
            str += "</p>";
            grafsOut.push(str);
          }
        }
        end = grafsOut.length;
        for (i = 0; i < end; i++) {
          var blockText = "", grafsOutIt = grafsOut[i], codeFlag = false;
          while (/(K|G)(\d+)\1/.test(grafsOutIt)) {
            var delim = RegExp.$1, num = RegExp.$2;
            if (delim === "K") {
              blockText = globals.gHtmlBlocks[num];
            } else {
              if (codeFlag) {
                blockText = showdown.subParser("encodeCode")(globals.ghCodeBlocks[num].text, options, globals);
              } else {
                blockText = globals.ghCodeBlocks[num].codeblock;
              }
            }
            blockText = blockText.replace(/\$/g, "$$$$");
            grafsOutIt = grafsOutIt.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, blockText);
            if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
              codeFlag = true;
            }
          }
          grafsOut[i] = grafsOutIt;
        }
        text = grafsOut.join("\n");
        text = text.replace(/^\n+/g, "");
        text = text.replace(/\n+$/g, "");
        return globals.converter._dispatch("paragraphs.after", text, options, globals);
      });
      showdown.subParser("runExtension", function(ext, text, options, globals) {
        "use strict";
        if (ext.filter) {
          text = ext.filter(text, globals.converter, options);
        } else if (ext.regex) {
          var re = ext.regex;
          if (!(re instanceof RegExp)) {
            re = new RegExp(re, "g");
          }
          text = text.replace(re, ext.replace);
        }
        return text;
      });
      showdown.subParser("spanGamut", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("spanGamut.before", text, options, globals);
        text = showdown.subParser("codeSpans")(text, options, globals);
        text = showdown.subParser("escapeSpecialCharsWithinTagAttributes")(text, options, globals);
        text = showdown.subParser("encodeBackslashEscapes")(text, options, globals);
        text = showdown.subParser("images")(text, options, globals);
        text = showdown.subParser("anchors")(text, options, globals);
        text = showdown.subParser("autoLinks")(text, options, globals);
        text = showdown.subParser("simplifiedAutoLinks")(text, options, globals);
        text = showdown.subParser("emoji")(text, options, globals);
        text = showdown.subParser("underline")(text, options, globals);
        text = showdown.subParser("italicsAndBold")(text, options, globals);
        text = showdown.subParser("strikethrough")(text, options, globals);
        text = showdown.subParser("ellipsis")(text, options, globals);
        text = showdown.subParser("hashHTMLSpans")(text, options, globals);
        text = showdown.subParser("encodeAmpsAndAngles")(text, options, globals);
        if (options.simpleLineBreaks) {
          if (!/\n\nK/.test(text)) {
            text = text.replace(/\n+/g, "<br />\n");
          }
        } else {
          text = text.replace(/  +\n/g, "<br />\n");
        }
        text = globals.converter._dispatch("spanGamut.after", text, options, globals);
        return text;
      });
      showdown.subParser("strikethrough", function(text, options, globals) {
        "use strict";
        function parseInside(txt) {
          if (options.simplifiedAutoLink) {
            txt = showdown.subParser("simplifiedAutoLinks")(txt, options, globals);
          }
          return "<del>" + txt + "</del>";
        }
        if (options.strikethrough) {
          text = globals.converter._dispatch("strikethrough.before", text, options, globals);
          text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function(wm, txt) {
            return parseInside(txt);
          });
          text = globals.converter._dispatch("strikethrough.after", text, options, globals);
        }
        return text;
      });
      showdown.subParser("stripLinkDefinitions", function(text, options, globals) {
        "use strict";
        var regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm, base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm;
        text += "\xA80";
        var replaceFunc = function(wholeMatch, linkId, url, width, height, blankLines, title) {
          linkId = linkId.toLowerCase();
          if (url.match(/^data:.+?\/.+?;base64,/)) {
            globals.gUrls[linkId] = url.replace(/\s/g, "");
          } else {
            globals.gUrls[linkId] = showdown.subParser("encodeAmpsAndAngles")(url, options, globals);
          }
          if (blankLines) {
            return blankLines + title;
          } else {
            if (title) {
              globals.gTitles[linkId] = title.replace(/"|'/g, "&quot;");
            }
            if (options.parseImgDimensions && width && height) {
              globals.gDimensions[linkId] = {
                width,
                height
              };
            }
          }
          return "";
        };
        text = text.replace(base64Regex, replaceFunc);
        text = text.replace(regex, replaceFunc);
        text = text.replace(/0/, "");
        return text;
      });
      showdown.subParser("tables", function(text, options, globals) {
        "use strict";
        if (!options.tables) {
          return text;
        }
        var tableRgx = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm, singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm;
        function parseStyles(sLine) {
          if (/^:[ \t]*--*$/.test(sLine)) {
            return ' style="text-align:left;"';
          } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
            return ' style="text-align:right;"';
          } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
            return ' style="text-align:center;"';
          } else {
            return "";
          }
        }
        function parseHeaders(header, style) {
          var id = "";
          header = header.trim();
          if (options.tablesHeaderId || options.tableHeaderId) {
            id = ' id="' + header.replace(/ /g, "_").toLowerCase() + '"';
          }
          header = showdown.subParser("spanGamut")(header, options, globals);
          return "<th" + id + style + ">" + header + "</th>\n";
        }
        function parseCells(cell, style) {
          var subText = showdown.subParser("spanGamut")(cell, options, globals);
          return "<td" + style + ">" + subText + "</td>\n";
        }
        function buildTable(headers, cells) {
          var tb = "<table>\n<thead>\n<tr>\n", tblLgn = headers.length;
          for (var i = 0; i < tblLgn; ++i) {
            tb += headers[i];
          }
          tb += "</tr>\n</thead>\n<tbody>\n";
          for (i = 0; i < cells.length; ++i) {
            tb += "<tr>\n";
            for (var ii = 0; ii < tblLgn; ++ii) {
              tb += cells[i][ii];
            }
            tb += "</tr>\n";
          }
          tb += "</tbody>\n</table>\n";
          return tb;
        }
        function parseTable(rawTable) {
          var i, tableLines = rawTable.split("\n");
          for (i = 0; i < tableLines.length; ++i) {
            if (/^ {0,3}\|/.test(tableLines[i])) {
              tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, "");
            }
            if (/\|[ \t]*$/.test(tableLines[i])) {
              tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, "");
            }
            tableLines[i] = showdown.subParser("codeSpans")(tableLines[i], options, globals);
          }
          var rawHeaders = tableLines[0].split("|").map(function(s) {
            return s.trim();
          }), rawStyles = tableLines[1].split("|").map(function(s) {
            return s.trim();
          }), rawCells = [], headers = [], styles = [], cells = [];
          tableLines.shift();
          tableLines.shift();
          for (i = 0; i < tableLines.length; ++i) {
            if (tableLines[i].trim() === "") {
              continue;
            }
            rawCells.push(
              tableLines[i].split("|").map(function(s) {
                return s.trim();
              })
            );
          }
          if (rawHeaders.length < rawStyles.length) {
            return rawTable;
          }
          for (i = 0; i < rawStyles.length; ++i) {
            styles.push(parseStyles(rawStyles[i]));
          }
          for (i = 0; i < rawHeaders.length; ++i) {
            if (showdown.helper.isUndefined(styles[i])) {
              styles[i] = "";
            }
            headers.push(parseHeaders(rawHeaders[i], styles[i]));
          }
          for (i = 0; i < rawCells.length; ++i) {
            var row = [];
            for (var ii = 0; ii < headers.length; ++ii) {
              if (showdown.helper.isUndefined(rawCells[i][ii])) {
              }
              row.push(parseCells(rawCells[i][ii], styles[ii]));
            }
            cells.push(row);
          }
          return buildTable(headers, cells);
        }
        text = globals.converter._dispatch("tables.before", text, options, globals);
        text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);
        text = text.replace(tableRgx, parseTable);
        text = text.replace(singeColTblRgx, parseTable);
        text = globals.converter._dispatch("tables.after", text, options, globals);
        return text;
      });
      showdown.subParser("underline", function(text, options, globals) {
        "use strict";
        if (!options.underline) {
          return text;
        }
        text = globals.converter._dispatch("underline.before", text, options, globals);
        if (options.literalMidWordUnderscores) {
          text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
            return "<u>" + txt + "</u>";
          });
          text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
            return "<u>" + txt + "</u>";
          });
        } else {
          text = text.replace(/___(\S[\s\S]*?)___/g, function(wm, m) {
            return /\S$/.test(m) ? "<u>" + m + "</u>" : wm;
          });
          text = text.replace(/__(\S[\s\S]*?)__/g, function(wm, m) {
            return /\S$/.test(m) ? "<u>" + m + "</u>" : wm;
          });
        }
        text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);
        text = globals.converter._dispatch("underline.after", text, options, globals);
        return text;
      });
      showdown.subParser("unescapeSpecialChars", function(text, options, globals) {
        "use strict";
        text = globals.converter._dispatch("unescapeSpecialChars.before", text, options, globals);
        text = text.replace(/E(\d+)E/g, function(wholeMatch, m1) {
          var charCodeToReplace = parseInt(m1);
          return String.fromCharCode(charCodeToReplace);
        });
        text = globals.converter._dispatch("unescapeSpecialChars.after", text, options, globals);
        return text;
      });
      showdown.subParser("makeMarkdown.blockquote", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            var innerTxt = showdown.subParser("makeMarkdown.node")(children[i], globals);
            if (innerTxt === "") {
              continue;
            }
            txt += innerTxt;
          }
        }
        txt = txt.trim();
        txt = "> " + txt.split("\n").join("\n> ");
        return txt;
      });
      showdown.subParser("makeMarkdown.codeBlock", function(node, globals) {
        "use strict";
        var lang = node.getAttribute("language"), num = node.getAttribute("precodenum");
        return "```" + lang + "\n" + globals.preList[num] + "\n```";
      });
      showdown.subParser("makeMarkdown.codeSpan", function(node) {
        "use strict";
        return "`" + node.innerHTML + "`";
      });
      showdown.subParser("makeMarkdown.emphasis", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          txt += "*";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "*";
        }
        return txt;
      });
      showdown.subParser("makeMarkdown.header", function(node, globals, headerLevel) {
        "use strict";
        var headerMark = new Array(headerLevel + 1).join("#"), txt = "";
        if (node.hasChildNodes()) {
          txt = headerMark + " ";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown.subParser("makeMarkdown.node")(children[i], globals);
          }
        }
        return txt;
      });
      showdown.subParser("makeMarkdown.hr", function() {
        "use strict";
        return "---";
      });
      showdown.subParser("makeMarkdown.image", function(node) {
        "use strict";
        var txt = "";
        if (node.hasAttribute("src")) {
          txt += "![" + node.getAttribute("alt") + "](";
          txt += "<" + node.getAttribute("src") + ">";
          if (node.hasAttribute("width") && node.hasAttribute("height")) {
            txt += " =" + node.getAttribute("width") + "x" + node.getAttribute("height");
          }
          if (node.hasAttribute("title")) {
            txt += ' "' + node.getAttribute("title") + '"';
          }
          txt += ")";
        }
        return txt;
      });
      showdown.subParser("makeMarkdown.links", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes() && node.hasAttribute("href")) {
          var children = node.childNodes, childrenLength = children.length;
          txt = "[";
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "](";
          txt += "<" + node.getAttribute("href") + ">";
          if (node.hasAttribute("title")) {
            txt += ' "' + node.getAttribute("title") + '"';
          }
          txt += ")";
        }
        return txt;
      });
      showdown.subParser("makeMarkdown.list", function(node, globals, type3) {
        "use strict";
        var txt = "";
        if (!node.hasChildNodes()) {
          return "";
        }
        var listItems = node.childNodes, listItemsLenght = listItems.length, listNum = node.getAttribute("start") || 1;
        for (var i = 0; i < listItemsLenght; ++i) {
          if (typeof listItems[i].tagName === "undefined" || listItems[i].tagName.toLowerCase() !== "li") {
            continue;
          }
          var bullet = "";
          if (type3 === "ol") {
            bullet = listNum.toString() + ". ";
          } else {
            bullet = "- ";
          }
          txt += bullet + showdown.subParser("makeMarkdown.listItem")(listItems[i], globals);
          ++listNum;
        }
        txt += "\n<!-- -->\n";
        return txt.trim();
      });
      showdown.subParser("makeMarkdown.listItem", function(node, globals) {
        "use strict";
        var listItemTxt = "";
        var children = node.childNodes, childrenLenght = children.length;
        for (var i = 0; i < childrenLenght; ++i) {
          listItemTxt += showdown.subParser("makeMarkdown.node")(children[i], globals);
        }
        if (!/\n$/.test(listItemTxt)) {
          listItemTxt += "\n";
        } else {
          listItemTxt = listItemTxt.split("\n").join("\n    ").replace(/^ {4}$/gm, "").replace(/\n\n+/g, "\n\n");
        }
        return listItemTxt;
      });
      showdown.subParser("makeMarkdown.node", function(node, globals, spansOnly) {
        "use strict";
        spansOnly = spansOnly || false;
        var txt = "";
        if (node.nodeType === 3) {
          return showdown.subParser("makeMarkdown.txt")(node, globals);
        }
        if (node.nodeType === 8) {
          return "<!--" + node.data + "-->\n\n";
        }
        if (node.nodeType !== 1) {
          return "";
        }
        var tagName = node.tagName.toLowerCase();
        switch (tagName) {
          case "h1":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.header")(node, globals, 1) + "\n\n";
            }
            break;
          case "h2":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.header")(node, globals, 2) + "\n\n";
            }
            break;
          case "h3":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.header")(node, globals, 3) + "\n\n";
            }
            break;
          case "h4":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.header")(node, globals, 4) + "\n\n";
            }
            break;
          case "h5":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.header")(node, globals, 5) + "\n\n";
            }
            break;
          case "h6":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.header")(node, globals, 6) + "\n\n";
            }
            break;
          case "p":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.paragraph")(node, globals) + "\n\n";
            }
            break;
          case "blockquote":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.blockquote")(node, globals) + "\n\n";
            }
            break;
          case "hr":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.hr")(node, globals) + "\n\n";
            }
            break;
          case "ol":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.list")(node, globals, "ol") + "\n\n";
            }
            break;
          case "ul":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.list")(node, globals, "ul") + "\n\n";
            }
            break;
          case "precode":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.codeBlock")(node, globals) + "\n\n";
            }
            break;
          case "pre":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.pre")(node, globals) + "\n\n";
            }
            break;
          case "table":
            if (!spansOnly) {
              txt = showdown.subParser("makeMarkdown.table")(node, globals) + "\n\n";
            }
            break;
          case "code":
            txt = showdown.subParser("makeMarkdown.codeSpan")(node, globals);
            break;
          case "em":
          case "i":
            txt = showdown.subParser("makeMarkdown.emphasis")(node, globals);
            break;
          case "strong":
          case "b":
            txt = showdown.subParser("makeMarkdown.strong")(node, globals);
            break;
          case "del":
            txt = showdown.subParser("makeMarkdown.strikethrough")(node, globals);
            break;
          case "a":
            txt = showdown.subParser("makeMarkdown.links")(node, globals);
            break;
          case "img":
            txt = showdown.subParser("makeMarkdown.image")(node, globals);
            break;
          default:
            txt = node.outerHTML + "\n\n";
        }
        return txt;
      });
      showdown.subParser("makeMarkdown.paragraph", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown.subParser("makeMarkdown.node")(children[i], globals);
          }
        }
        txt = txt.trim();
        return txt;
      });
      showdown.subParser("makeMarkdown.pre", function(node, globals) {
        "use strict";
        var num = node.getAttribute("prenum");
        return "<pre>" + globals.preList[num] + "</pre>";
      });
      showdown.subParser("makeMarkdown.strikethrough", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          txt += "~~";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "~~";
        }
        return txt;
      });
      showdown.subParser("makeMarkdown.strong", function(node, globals) {
        "use strict";
        var txt = "";
        if (node.hasChildNodes()) {
          txt += "**";
          var children = node.childNodes, childrenLength = children.length;
          for (var i = 0; i < childrenLength; ++i) {
            txt += showdown.subParser("makeMarkdown.node")(children[i], globals);
          }
          txt += "**";
        }
        return txt;
      });
      showdown.subParser("makeMarkdown.table", function(node, globals) {
        "use strict";
        var txt = "", tableArray = [[], []], headings = node.querySelectorAll("thead>tr>th"), rows = node.querySelectorAll("tbody>tr"), i, ii;
        for (i = 0; i < headings.length; ++i) {
          var headContent = showdown.subParser("makeMarkdown.tableCell")(headings[i], globals), allign = "---";
          if (headings[i].hasAttribute("style")) {
            var style = headings[i].getAttribute("style").toLowerCase().replace(/\s/g, "");
            switch (style) {
              case "text-align:left;":
                allign = ":---";
                break;
              case "text-align:right;":
                allign = "---:";
                break;
              case "text-align:center;":
                allign = ":---:";
                break;
            }
          }
          tableArray[0][i] = headContent.trim();
          tableArray[1][i] = allign;
        }
        for (i = 0; i < rows.length; ++i) {
          var r = tableArray.push([]) - 1, cols = rows[i].getElementsByTagName("td");
          for (ii = 0; ii < headings.length; ++ii) {
            var cellContent = " ";
            if (typeof cols[ii] !== "undefined") {
              cellContent = showdown.subParser("makeMarkdown.tableCell")(cols[ii], globals);
            }
            tableArray[r].push(cellContent);
          }
        }
        var cellSpacesCount = 3;
        for (i = 0; i < tableArray.length; ++i) {
          for (ii = 0; ii < tableArray[i].length; ++ii) {
            var strLen = tableArray[i][ii].length;
            if (strLen > cellSpacesCount) {
              cellSpacesCount = strLen;
            }
          }
        }
        for (i = 0; i < tableArray.length; ++i) {
          for (ii = 0; ii < tableArray[i].length; ++ii) {
            if (i === 1) {
              if (tableArray[i][ii].slice(-1) === ":") {
                tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, "-") + ":";
              } else {
                tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, "-");
              }
            } else {
              tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
            }
          }
          txt += "| " + tableArray[i].join(" | ") + " |\n";
        }
        return txt.trim();
      });
      showdown.subParser("makeMarkdown.tableCell", function(node, globals) {
        "use strict";
        var txt = "";
        if (!node.hasChildNodes()) {
          return "";
        }
        var children = node.childNodes, childrenLength = children.length;
        for (var i = 0; i < childrenLength; ++i) {
          txt += showdown.subParser("makeMarkdown.node")(children[i], globals, true);
        }
        return txt.trim();
      });
      showdown.subParser("makeMarkdown.txt", function(node) {
        "use strict";
        var txt = node.nodeValue;
        txt = txt.replace(/ +/g, " ");
        txt = txt.replace(/NBSP;/g, " ");
        txt = showdown.helper.unescapeHTMLEntities(txt);
        txt = txt.replace(/([*_~|`])/g, "\\$1");
        txt = txt.replace(/^(\s*)>/g, "\\$1>");
        txt = txt.replace(/^#/gm, "\\#");
        txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3");
        txt = txt.replace(/^( {0,3}\d+)\./gm, "$1\\.");
        txt = txt.replace(/^( {0,3})([+-])/gm, "$1\\$2");
        txt = txt.replace(/]([\s]*)\(/g, "\\]$1\\(");
        txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:");
        return txt;
      });
      var root = this;
      if (typeof define === "function" && define.amd) {
        define(function() {
          "use strict";
          return showdown;
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = showdown;
      } else {
        root.showdown = showdown;
      }
    }).call(exports);
  }
});

// node_modules/@serlo/markdown/dist/markdown.cjs.production.min.js
var require_markdown_cjs_production_min = __commonJS({
  "node_modules/@serlo/markdown/dist/markdown.cjs.production.min.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var e;
    var t3;
    var n;
    var r;
    var a = (e = require_showdown()) && "object" == typeof e && "default" in e ? e.default : e;
    var i = { img: "src|width|height|alt", a: "href|name", "*": "title", span: "class", table: "class", tr: "rowspan", td: "colspan|align", th: "rowspan|align", div: "class", b: "class", h1: "id", h2: "id", h3: "id", h4: "id", h5: "id", h6: "id" };
    var s = new RegExp("^(" + "a|b|blockquote|code|del|dd|dl|dt|em|h1|h2|h3|h4|h5|h6|i|img|li|ol|p|pre|sup|sub|strong|strike|ul|br|hr|span|table|th|tr|td|tbody|thead|tfoot|div".toLowerCase() + ")$");
    var l = /<(\/?)\s*([\w:-]+)([^>]*)>/g;
    var p = /(\s*)([\w:-]+)\s*=\s*(?:(?:(["'])([^\3]+?)(?:\3))|([^\s]+))/g;
    t3 = function(e2) {
      return function(e3) {
        return e3.replace(n.regexp, n.replace);
      }(e2);
    }, n = function() {
      for (var e2 = "", t4 = ["*", "`", "_", "{", "}", "[", "]", "<", "\\"], n2 = {}, r2 = t4.length, a2 = 0; a2 < r2; a2++)
        e2 += "\\" + t4[a2], n2[t4[a2]] = "\xA7LT" + a2;
      return { regexp: e2 = new RegExp("([" + e2 + "])", "gm"), replace: function(e3) {
        return n2[e3] || e3;
      } };
    }(), r = function() {
      for (var e2 = ["*", "`", "_", "{", "}", "[", "]", "&lt;", "\\"], t4 = {}, n2 = e2.length, r2 = 0; r2 < n2; r2++)
        t4["" + r2] = e2[r2];
      return { regexp: new RegExp("\xA7LT([0-9])", "gm"), replace: function(e3, n3) {
        return t4[parseInt(n3)] || n3;
      } };
    }(), exports.converter = new a.Converter({ extensions: [function() {
      return [{ type: "lang", filter: function() {
        var e2, t4, n2, r2 = {}, a2 = /(?:^|\n)```(.*)\n([\s\S]*?)\n```/gm, i2 = ["~D", "%", "\\|", "/"];
        for (t4 = 0, n2 = i2.length; t4 < n2; t4++)
          r2[i2[t4].replace(/\\/g, "")] = "\xA7SC" + t4;
        function s2(t5, n3, a3) {
          return "\n```" + n3 + "\n" + (a3 = a3.replace(e2, function(e3) {
            return r2[e3] || e3;
          })) + "\n```";
        }
        return e2 = new RegExp("(" + i2.join("|") + ")", "gm"), function(e3) {
          return e3.replace(a2, s2);
        };
      }() }];
    }, function() {
      var e2 = new RegExp(/>\[(.*)\]\((.*)\)/g);
      return [{ type: "lang", filter: function(t4) {
        return t4.replace(e2, function(e3, t5, n2) {
          var r2 = function(e4) {
            return "http:" === (e4 = e4.split("/"))[0] || "https:" === e4[0] ? e4.join("/") : ("" === e4[0] && e4.shift(), "/" + e4.join("/"));
          }(n2);
          return /assets\.serlo\.org\/legacy\/.*\.xml/.test(r2) ? `<div class="legacy-injection">Legacy GeoGebra applets aren't supported anymore. Please upload the applet to GeoGebra instead.</div>` : /assets\.serlo\.org\/legacy\//.test(r2) ? '<div>\n            <div class="injection"><a href="' + r2 + '" class="injection-link">' + t5 + `</a></div>
            <div class="legacy-injection">Please don't use injections for images. Change <code>>[...](...)</code> to <code>![...](...)</code></div>
          </div>` : '<div class="injection"><a href="' + r2 + '" class="injection-link">' + t5 + "</a></div>";
        });
      } }];
    }, function() {
      var e2, t4 = {}, n2 = "text-align:left;";
      return t4.th = function(t5) {
        return '<th style="' + n2 + '">' + e2.makeHtml(t5) + "</th>";
      }, t4.td = function(t5) {
        return '<td style="' + n2 + '">' + e2.makeHtml(t5) + "</td>";
      }, t4.ths = function() {
        for (var e3 = "", n3 = 0, r2 = [].slice.apply(arguments); n3 < r2.length; n3 += 1)
          e3 += t4.th(r2[n3]) + "\n";
        return e3;
      }, t4.tds = function() {
        for (var e3 = "", n3 = 0, r2 = [].slice.apply(arguments); n3 < r2.length; n3 += 1)
          e3 += t4.td(r2[n3]) + "\n";
        return e3;
      }, t4.thead = function() {
        var e3, n3 = [].slice.apply(arguments);
        return e3 = "<thead>\n", e3 += "<tr>\n", e3 += t4.ths.apply(this, n3), (e3 += "</tr>\n") + "</thead>\n";
      }, t4.tr = function() {
        var e3, n3 = [].slice.apply(arguments);
        return e3 = "<tr>\n", (e3 += t4.tds.apply(this, n3)) + "</tr>\n";
      }, [{ type: "lang", filter: function(n3, r2) {
        var a2, i2, s2 = 0, l2 = n3.split("\n"), p2 = [], u = [];
        for (e2 = r2; s2 < l2.length; s2 += 1) {
          if ((a2 = l2[s2]).trim().match(/^[|]{1}.*[|]{1}$/)) {
            if (a2 = a2.trim(), p2.push('<div class="table-responsive">'), p2.push('<table class="table table-striped">'), i2 = a2.substring(1, a2.length - 1).split("|"), p2.push(t4.thead.apply(this, i2)), (a2 = l2[++s2]).trim().match(/^[|]{1}[-=| ]+[|]{1}$/)) {
              for (a2 = l2[++s2], p2.push("<tbody>"); a2.trim().match(/^[|]{1}.*[|]{1}$/); )
                a2 = a2.trim(), p2.push(t4.tr.apply(this, a2.substring(1, a2.length - 1).split("|"))), a2 = l2[++s2];
              p2.push("</tbody>"), p2.push("</table>"), p2.push("</div>"), u.push(p2.join("\n")), p2 = [];
              continue;
            }
            a2 = l2[--s2];
          }
          u.push(a2);
        }
        return u.join("\n");
      } }];
    }, function() {
      return [{ type: "output", filter: function(e2) {
        return function(e3) {
          for (var t4 in i)
            i.hasOwnProperty(t4) && "string" == typeof i[t4] && (i[t4] = new RegExp("^(" + i[t4].toLowerCase() + ")$"));
          return e3.replace(l, function(e4, t5, n2, r2) {
            var a2, l2, u = "/" === r2.substr(-1) ? "/" : "";
            return (n2 = n2.toLowerCase()).match(s) ? (l2 = "*" in i && i["*"], (a2 = n2 in i && i[n2]) || l2 ? (r2 = r2.trim(), u && (r2 = r2.substr(0, r2.length - 1)), "<" + t5 + n2 + ((r2 = r2.replace(p, function(e5, t6, n3, r3, i2) {
              return i2 || r3 ? i2 || (i2 = r3, r3 = '"') : (i2 = "", r3 = '"'), "href" !== (n3 = n3.toLowerCase()) && "src" !== n3 || "javascript:" !== i2.trim().substr(0, "javascript:".length) && "data:" !== i2.trim().substr(0, "data:".length) || (i2 = "#"), l2 && n3.match(l2) || a2 && n3.match(a2) ? t6 + n3 + "=" + r3 + i2 + r3 : "";
            })) ? " " + r2 : "") + u + ">") : "<" + t5 + n2 + u + ">") : "";
          });
        }(e2);
      } }];
    }, function() {
      return [{ type: "lang", filter: function(e2) {
        return e2 = (e2 = e2.replace(/(^|[^\\])(%%)([^\r]*?[^%])(%%?%)/gm, function(n2, r2, a2, i2, s2) {
          var l2 = i2;
          return l2 = (l2 = l2.replace(/^([ \t]*)/g, "")).replace(/[ \t]*$/g, ""), "%%%" === s2 && (l2 += "% "), e2 = (e2 = e2.replace(/\$/g, "\\$")).replace(/%/g, "\\%"), r2 + '<span class="mathInline">%%' + (l2 = t3(l2)) + "%%</span>";
        })).replace(/(^|[^\\])(DD)([^\r]*?[^~])\2(?!D)/gm, function(n2, r2, a2, i2) {
          var s2 = i2;
          return s2 = (s2 = s2.replace(/^([ \t]*)/g, "")).replace(/[ \t]*$/g, ""), s2 = t3(s2), e2 = e2.replace(/[^\\]D/g, "\\\xA8D"), r2 + '<span class="math">\xA8D\xA8D' + s2 + "\xA8D\xA8D</span>";
        });
      } }];
    }, function() {
      return [{ type: "lang", regex: "\\B(\\\\)?@([\\S]+)\\b", replace: function(e2, t4, n2) {
        return "\\" === t4 ? e2 : '<a class="user-mention" href="/user/profile/' + n2 + '">@' + n2 + "</a>";
      } }, { type: "lang", regex: "\\\\@", replace: "@" }];
    }, function() {
      return [{ type: "lang", regex: "(~T){2}([^~]+)(~T){2}", replace: function(e2, t4, n2, r2) {
        return "<del>" + n2 + "</del>";
      } }];
    }, function() {
      var e2 = new RegExp(/^<p>=,sp. (.*)<\/p>([\s\S]*?)<p>=,sp.<\/p>/gm);
      return [{ type: "output", filter: function(t4) {
        return t4.replace(e2, function(e3, t5, n2) {
          return '<div class="spoiler panel panel-default"><div class="spoiler-teaser panel-heading"><span class="fa fa-caret-square-o-down"></span>' + t5 + '</div><div class="spoiler-content panel-body">' + n2 + "</div></div>";
        });
      } }];
    }, function() {
      var e2 = new RegExp(/^\/\/\/ (.*)\n([\s\S]*?)(\n|\r)+\/\/\//gm);
      return [{ type: "lang", filter: function(t4) {
        return t4.replace(e2, function(e3, t5, n2) {
          return "<p>=,sp. " + t5 + "</p>\n" + n2 + "<p>=,sp.</p>";
        });
      } }];
    }, function() {
      return [{ type: "output", filter: function(e2) {
        return function(e3) {
          return e3.replace(r.regexp, r.replace);
        }(e2);
      } }];
    }, function() {
      return [{ type: "lang", filter: function() {
        var e2, t4, n2, r2 = ["~D", "%", "|", "/"], a2 = {};
        for (t4 = 0, n2 = r2.length; t4 < n2; t4++)
          a2["" + t4] = r2[t4];
        function i2(e3, t5) {
          return a2[parseInt(t5)] || t5;
        }
        return e2 = new RegExp("\xA7SC([0-9])", "gm"), function(t5) {
          return t5.replace(e2, i2);
        };
      }() }];
    }] });
  }
});

// node_modules/@serlo/markdown/dist/markdown.cjs.development.js
var require_markdown_cjs_development = __commonJS({
  "node_modules/@serlo/markdown/dist/markdown.cjs.development.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Showdown = _interopDefault(require_showdown());
    var codeprepare = function codeprepare2() {
      return [{
        type: "lang",
        filter: function() {
          var replacements = {};
          var replacementRegexp = "";
          var codeRegexp = /(?:^|\n)```(.*)\n([\s\S]*?)\n```/gm;
          var charsToDecode = ["~D", "%", "\\|", "/"];
          var i;
          var l;
          for (i = 0, l = charsToDecode.length; i < l; i++) {
            replacements[charsToDecode[i].replace(/\\/g, "")] = "\xA7SC" + i;
          }
          replacementRegexp = new RegExp("(" + charsToDecode.join("|") + ")", "gm");
          function replace(whole, language, code) {
            code = code.replace(replacementRegexp, function(match) {
              return replacements[match] || match;
            });
            return "\n```" + language + "\n" + code + "\n```";
          }
          return function(text) {
            return text.replace(codeRegexp, replace);
          };
        }()
      }];
    };
    var injections = function injections2() {
      var filter2;
      var findInjections = new RegExp(/>\[(.*)\]\((.*)\)/g);
      function correctUrl(url) {
        url = url.split("/");
        if (url[0] === "http:" || url[0] === "https:") {
          return url.join("/");
        }
        if (url[0] === "") {
          url.shift();
        }
        return "/" + url.join("/");
      }
      filter2 = function filter3(text) {
        return text.replace(findInjections, function(original, title, url) {
          var href = correctUrl(url);
          if (/assets\.serlo\.org\/legacy\/.*\.xml/.test(href)) {
            return `<div class="legacy-injection">Legacy GeoGebra applets aren't supported anymore. Please upload the applet to GeoGebra instead.</div>`;
          }
          if (/assets\.serlo\.org\/legacy\//.test(href)) {
            return '<div>\n            <div class="injection"><a href="' + href + '" class="injection-link">' + title + `</a></div>
            <div class="legacy-injection">Please don't use injections for images. Change <code>>[...](...)</code> to <code>![...](...)</code></div>
          </div>`;
          }
          return '<div class="injection"><a href="' + href + '" class="injection-link">' + title + "</a></div>";
        });
      };
      return [{
        type: "lang",
        filter: filter2
      }];
    };
    var table = function table2() {
      var tables = {};
      var style = "text-align:left;";
      var filter2;
      var callbackConverter;
      tables.th = function(header) {
        return '<th style="' + style + '">' + callbackConverter.makeHtml(header) + "</th>";
      };
      tables.td = function(cell) {
        return '<td style="' + style + '">' + callbackConverter.makeHtml(cell) + "</td>";
      };
      tables.ths = function() {
        var out = "";
        var i = 0;
        var hs = [].slice.apply(arguments);
        for (i; i < hs.length; i += 1) {
          out += tables.th(hs[i]) + "\n";
        }
        return out;
      };
      tables.tds = function() {
        var out = "";
        var i = 0;
        var ds = [].slice.apply(arguments);
        for (i; i < ds.length; i += 1) {
          out += tables.td(ds[i]) + "\n";
        }
        return out;
      };
      tables.thead = function() {
        var out;
        var hs = [].slice.apply(arguments);
        out = "<thead>\n";
        out += "<tr>\n";
        out += tables.ths.apply(this, hs);
        out += "</tr>\n";
        out += "</thead>\n";
        return out;
      };
      tables.tr = function() {
        var out;
        var cs = [].slice.apply(arguments);
        out = "<tr>\n";
        out += tables.tds.apply(this, cs);
        out += "</tr>\n";
        return out;
      };
      filter2 = function filter3(text, converter3) {
        var i = 0;
        var lines = text.split("\n");
        var tbl = [];
        var line;
        var hs;
        var out = [];
        callbackConverter = converter3;
        for (i; i < lines.length; i += 1) {
          line = lines[i];
          if (line.trim().match(/^[|]{1}.*[|]{1}$/)) {
            line = line.trim();
            tbl.push('<div class="table-responsive">');
            tbl.push('<table class="table table-striped">');
            hs = line.substring(1, line.length - 1).split("|");
            tbl.push(tables.thead.apply(this, hs));
            line = lines[++i];
            if (!line.trim().match(/^[|]{1}[-=| ]+[|]{1}$/)) {
              line = lines[--i];
            } else {
              line = lines[++i];
              tbl.push("<tbody>");
              while (line.trim().match(/^[|]{1}.*[|]{1}$/)) {
                line = line.trim();
                tbl.push(tables.tr.apply(this, line.substring(1, line.length - 1).split("|")));
                line = lines[++i];
              }
              tbl.push("</tbody>");
              tbl.push("</table>");
              tbl.push("</div>");
              out.push(tbl.join("\n"));
              tbl = [];
              continue;
            }
          }
          out.push(line);
        }
        return out.join("\n");
      };
      return [{
        type: "lang",
        filter: filter2
      }];
    };
    var allowedTags = "a|b|blockquote|code|del|dd|dl|dt|em|h1|h2|h3|h4|h5|h6|i|img|li|ol|p|pre|sup|sub|strong|strike|ul|br|hr|span|table|th|tr|td|tbody|thead|tfoot|div";
    var allowedAttributes = {
      img: "src|width|height|alt",
      a: "href|name",
      "*": "title",
      span: "class",
      table: "class",
      tr: "rowspan",
      td: "colspan|align",
      th: "rowspan|align",
      div: "class",
      b: "class",
      h1: "id",
      h2: "id",
      h3: "id",
      h4: "id",
      h5: "id",
      h6: "id"
    };
    var testAllowed = /* @__PURE__ */ new RegExp("^(" + /* @__PURE__ */ allowedTags.toLowerCase() + ")$");
    var findTags = /<(\/?)\s*([\w:-]+)([^>]*)>/g;
    var findAttribs = /(\s*)([\w:-]+)\s*=\s*(?:(?:(["'])([^\3]+?)(?:\3))|([^\s]+))/g;
    var htmlstrip = function htmlstrip2() {
      var filter2;
      filter2 = function filter3(text) {
        return stripUnwantedHTML(text);
      };
      return [{
        type: "output",
        filter: filter2
      }];
    };
    function stripUnwantedHTML(html) {
      for (var i in allowedAttributes) {
        if (allowedAttributes.hasOwnProperty(i) && typeof allowedAttributes[i] === "string") {
          allowedAttributes[i] = new RegExp("^(" + allowedAttributes[i].toLowerCase() + ")$");
        }
      }
      return html.replace(findTags, function(original, lslash, tag, params) {
        var tagAttr;
        var wildcardAttr;
        var rslash = params.substr(-1) === "/" && "/" || "";
        tag = tag.toLowerCase();
        if (!tag.match(testAllowed))
          return "";
        else {
          tagAttr = tag in allowedAttributes && allowedAttributes[tag];
          wildcardAttr = "*" in allowedAttributes && allowedAttributes["*"];
          if (!tagAttr && !wildcardAttr)
            return "<" + lslash + tag + rslash + ">";
          params = params.trim();
          if (rslash) {
            params = params.substr(0, params.length - 1);
          }
          params = params.replace(findAttribs, function(original2, space, name, quot, value) {
            name = name.toLowerCase();
            if (!value && !quot) {
              value = "";
              quot = '"';
            } else if (!value) {
              value = quot;
              quot = '"';
            }
            if ((name === "href" || name === "src") && (value.trim().substr(0, "javascript:".length) === "javascript:" || value.trim().substr(0, "data:".length) === "data:")) {
              value = "#";
            }
            if (wildcardAttr && name.match(wildcardAttr) || tagAttr && name.match(tagAttr)) {
              return space + name + "=" + quot + value + quot;
            } else
              return "";
          });
          return "<" + lslash + tag + (params ? " " + params : "") + rslash + ">";
        }
      });
    }
    var _EncodeCode;
    var serloSpecificCharsToEscape;
    var latex = function latex2() {
      var filter2;
      filter2 = function filter3(text) {
        text = text.replace(/(^|[^\\])(%%)([^\r]*?[^%])(%%?%)/gm, function(wholeMatch, m1, m2, m3, m4) {
          var c = m3;
          c = c.replace(/^([ \t]*)/g, "");
          c = c.replace(/[ \t]*$/g, "");
          if (m4 === "%%%") {
            c += "% ";
          }
          text = text.replace(/\$/g, "\\$");
          text = text.replace(/%/g, "\\%");
          c = _EncodeCode(c);
          return m1 + '<span class="mathInline">%%' + c + "%%</span>";
        });
        text = text.replace(/(^|[^\\])(DD)([^\r]*?[^~])\2(?!D)/gm, function(wholeMatch, m1, m2, m3) {
          var c = m3;
          c = c.replace(/^([ \t]*)/g, "");
          c = c.replace(/[ \t]*$/g, "");
          c = _EncodeCode(c);
          text = text.replace(/[^\\]D/g, "\\\xA8D");
          return m1 + '<span class="math">\xA8D\xA8D' + c + "\xA8D\xA8D</span>";
        });
        return text;
      };
      return [{
        type: "lang",
        filter: filter2
      }];
    };
    _EncodeCode = function _EncodeCode2(text) {
      text = escapeSerloSpecificCharacters(text);
      return text;
    };
    serloSpecificCharsToEscape = /* @__PURE__ */ function() {
      var regexp = "";
      var chars = ["*", "`", "_", "{", "}", "[", "]", "<", "\\"];
      var replacements = {};
      var l = chars.length;
      var i = 0;
      for (; i < l; i++) {
        regexp += "\\" + chars[i];
        replacements[chars[i]] = "\xA7LT" + i;
      }
      regexp = /* @__PURE__ */ new RegExp("([" + regexp + "])", "gm");
      function replace(match) {
        return replacements[match] || match;
      }
      return {
        regexp,
        replace
      };
    }();
    function escapeSerloSpecificCharacters(text) {
      return text.replace(serloSpecificCharsToEscape.regexp, serloSpecificCharsToEscape.replace);
    }
    var atusername = function atusername2() {
      return [
        // @username syntax
        {
          type: "lang",
          regex: "\\B(\\\\)?@([\\S]+)\\b",
          replace: function replace(match, leadingSlash, username) {
            if (leadingSlash === "\\") {
              return match;
            } else {
              return '<a class="user-mention" href="/user/profile/' + username + '">@' + username + "</a>";
            }
          }
        },
        // Escaped @'s so we don't get into trouble
        //
        {
          type: "lang",
          regex: "\\\\@",
          replace: "@"
        }
      ];
    };
    var strikethrough = function strikethrough2() {
      return [{
        // strike-through
        // NOTE: showdown already replaced "~" with "~T", so we need to adjust accordingly.
        type: "lang",
        regex: "(~T){2}([^~]+)(~T){2}",
        replace: function replace(match, prefix, content, suffix) {
          return "<del>" + content + "</del>";
        }
      }];
    };
    var spoiler = function spoiler2() {
      var filter2;
      var findSpoilers = new RegExp(/^<p>=,sp. (.*)<\/p>([\s\S]*?)<p>=,sp.<\/p>/gm);
      filter2 = function filter3(text) {
        return text.replace(findSpoilers, function(original, title, content) {
          return '<div class="spoiler panel panel-default"><div class="spoiler-teaser panel-heading"><span class="fa fa-caret-square-o-down"></span>' + title + '</div><div class="spoiler-content panel-body">' + content + "</div></div>";
        });
      };
      return [{
        type: "output",
        filter: filter2
      }];
    };
    var spoilerprepare = function spoilerprepare2() {
      var filter2;
      var findSpoilers = new RegExp(/^\/\/\/ (.*)\n([\s\S]*?)(\n|\r)+\/\/\//gm);
      filter2 = function filter3(text) {
        return text.replace(findSpoilers, function(original, title, content) {
          return "<p>=,sp. " + title + "</p>\n" + content + "<p>=,sp.</p>";
        });
      };
      return [{
        type: "lang",
        filter: filter2
      }];
    };
    var serloSpecificCharsToEncode;
    var latexoutput = function latexoutput2() {
      return [{
        type: "output",
        filter: function filter2(text) {
          return encodeSerloSpecificChars(text);
        }
      }];
    };
    serloSpecificCharsToEncode = /* @__PURE__ */ function() {
      var regexp;
      var chars = ["*", "`", "_", "{", "}", "[", "]", "&lt;", "\\"];
      var replacements = {};
      var l = chars.length;
      var i = 0;
      for (; i < l; i++) {
        replacements["" + i] = chars[i];
      }
      regexp = /* @__PURE__ */ new RegExp("\xA7LT([0-9])", "gm");
      function replace(whole, match) {
        return replacements[parseInt(match)] || match;
      }
      return {
        regexp,
        replace
      };
    }();
    function encodeSerloSpecificChars(text) {
      return text.replace(serloSpecificCharsToEncode.regexp, serloSpecificCharsToEncode.replace);
    }
    var codeoutput = function codeoutput2() {
      return [{
        type: "lang",
        filter: function() {
          var charsToEncode = ["~D", "%", "|", "/"];
          var replacements = {};
          var regexp;
          var i;
          var l;
          for (i = 0, l = charsToEncode.length; i < l; i++) {
            replacements["" + i] = charsToEncode[i];
          }
          regexp = new RegExp("\xA7SC([0-9])", "gm");
          function replace(whole, match) {
            return replacements[parseInt(match)] || match;
          }
          return function(text) {
            return text.replace(regexp, replace);
          };
        }()
      }];
    };
    var converter2 = /* @__PURE__ */ new Showdown.Converter({
      extensions: [codeprepare, injections, table, htmlstrip, latex, atusername, strikethrough, spoiler, spoilerprepare, latexoutput, codeoutput]
    });
    exports.converter = converter2;
  }
});

// node_modules/@serlo/markdown/dist/index.js
var require_dist = __commonJS({
  "node_modules/@serlo/markdown/dist/index.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_markdown_cjs_production_min();
    } else {
      module2.exports = require_markdown_cjs_development();
    }
  }
});

// src/20230917105600-upgrade-all-edtr-io-states.ts
var import_fp_ts = __toESM(require_lib(), 1);
var t2 = __toESM(require_lib2(), 1);

// src/utils/api-cache.ts
var import_ioredis = __toESM(require_built3(), 1);
var ApiCache = class {
  redis;
  constructor() {
    if (typeof process.env.REDIS_URL === "string") {
      this.redis = new import_ioredis.default(process.env.REDIS_URL);
    } else {
      throw new Error("Env `REDIS_URL` is not defined");
    }
  }
  async quit() {
    await this.redis.quit();
  }
  async deleteUuid(uuid) {
    await this.redis.del(`de.serlo.org/api/uuid/${uuid}`);
    console.log(`INFO: API cache for UUID ${uuid} deleted`);
  }
};

// src/utils/database.ts
function createDatabase(db) {
  return {
    runSql: async (query, ...params) => {
      return new Promise((resolve, reject) => {
        db.runSql(query, ...params, (error, results) => {
          if (error) {
            reject(error);
            return;
          }
          resolve(results);
        });
      });
    },
    dropTable: async (table) => {
      return new Promise((resolve, reject) => {
        db.dropTable(table, (error) => {
          if (error) {
            reject(error);
            return;
          }
          resolve();
        });
      });
    }
  };
}

// src/utils/edtr-io.ts
var t = __toESM(require_lib2(), 1);

// node_modules/ramda/es/internal/_isPlaceholder.js
function _isPlaceholder(a) {
  return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
}

// node_modules/ramda/es/internal/_curry1.js
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

// node_modules/ramda/es/internal/_curry2.js
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a2) {
          return fn(_a2, b);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

// node_modules/ramda/es/internal/_isArray.js
var isArray_default = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
};

// node_modules/ramda/es/internal/_has.js
function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/ramda/es/internal/_isArguments.js
var toString = Object.prototype.toString;
var _isArguments = /* @__PURE__ */ function() {
  return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
    return toString.call(x) === "[object Arguments]";
  } : function _isArguments2(x) {
    return _has("callee", x);
  };
}();
var isArguments_default = _isArguments;

// node_modules/ramda/es/keys.js
var hasEnumBug = !/* @__PURE__ */ {
  toString: null
}.propertyIsEnumerable("toString");
var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
var hasArgsEnumBug = /* @__PURE__ */ function() {
  "use strict";
  return arguments.propertyIsEnumerable("length");
}();
var contains = function contains2(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};
var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : /* @__PURE__ */ _curry1(function keys3(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
  for (prop in obj) {
    if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
      ks[ks.length] = prop;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];
      if (_has(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }
      nIdx -= 1;
    }
  }
  return ks;
});
var keys_default = keys;

// node_modules/ramda/es/internal/_toISOString.js
var pad = function pad2(n) {
  return (n < 10 ? "0" : "") + n;
};
var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
  return d.toISOString();
} : function _toISOString3(d) {
  return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
};

// node_modules/ramda/es/internal/_arrayReduce.js
function _arrayReduce(reducer, acc, list) {
  var index = 0;
  var length = list.length;
  while (index < length) {
    acc = reducer(acc, list[index]);
    index += 1;
  }
  return acc;
}

// node_modules/ramda/es/internal/_isInteger.js
var isInteger_default = Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
};

// node_modules/ramda/es/isNil.js
var isNil = /* @__PURE__ */ _curry1(function isNil2(x) {
  return x == null;
});
var isNil_default = isNil;

// node_modules/ramda/es/hasPath.js
var hasPath = /* @__PURE__ */ _curry2(function hasPath2(_path, obj) {
  if (_path.length === 0 || isNil_default(obj)) {
    return false;
  }
  var val = obj;
  var idx = 0;
  while (idx < _path.length) {
    if (!isNil_default(val) && _has(_path[idx], val)) {
      val = val[_path[idx]];
      idx += 1;
    } else {
      return false;
    }
  }
  return true;
});
var hasPath_default = hasPath;

// node_modules/ramda/es/has.js
var has = /* @__PURE__ */ _curry2(function has2(prop, obj) {
  return hasPath_default([prop], obj);
});
var has_default = has;

// node_modules/ramda/es/mapObjIndexed.js
var mapObjIndexed = /* @__PURE__ */ _curry2(function mapObjIndexed2(fn, obj) {
  return _arrayReduce(function(acc, key) {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {}, keys_default(obj));
});
var mapObjIndexed_default = mapObjIndexed;

// node_modules/ramda/es/trim.js
var hasProtoTrim = typeof String.prototype.trim === "function";

// src/utils/edtr-io.ts
function replacePlugins(transformations) {
  return updatePlugins((plugin, applyChangeToChildren) => {
    const transformFunc = transformations[plugin.plugin];
    if (typeof transformFunc === "function") {
      return transformFunc({ plugin, applyChangeToChildren });
    }
  });
}
function replacePluginState(transformations) {
  return updatePlugins(({ plugin, state }, applyChangeToChildren) => {
    const transformFunc = transformations[plugin];
    if (typeof transformFunc === "function") {
      return { plugin, state: transformFunc({ state, applyChangeToChildren }) };
    }
  });
}
function updatePlugins(updatePlugin) {
  function applyChangeToChildren(value) {
    if (isPlugin(value)) {
      const newPlugin = updatePlugin(value, applyChangeToChildren);
      if (newPlugin)
        return newPlugin;
    }
    if (Array.isArray(value)) {
      return value.map(applyChangeToChildren);
    }
    if (typeof value === "object" && value !== null) {
      return mapObjIndexed_default(applyChangeToChildren, value);
    }
    return value;
  }
  return applyChangeToChildren;
}
function transformPlugins(transformations) {
  return transformLists((value) => {
    if (isPlugin(value)) {
      const transformFunc = transformations[value.plugin];
      if (typeof transformFunc === "function") {
        return transformFunc(value);
      }
    }
  });
}
function transformLists(transform) {
  function applyTransformation(value) {
    if (Array.isArray(value)) {
      const newValue = value.flatMap((element) => {
        const transformation = transform(element);
        return transformation !== void 0 ? transformation : [element];
      });
      return newValue.map(applyTransformation);
    }
    if (typeof value === "object" && value !== null) {
      return mapObjIndexed_default(applyTransformation, value);
    }
    return value;
  }
  return applyTransformation;
}
function isPlugin(value) {
  return has_default("plugin", value) && has_default("state", value) && typeof value.plugin === "string";
}
var SlateNodeDecoder = t.type({ type: t.string });

// src/utils/create-migration.ts
var import_fs = require("fs");
var import_path7 = __toESM(require("path"), 1);
var import_os = require("os");
function createMigration(exports, {
  up,
  down
}) {
  exports._meta = {
    version: 1
  };
  exports.up = (db, cb) => {
    up(createDatabase(db)).then(() => {
      cb(void 0);
    }).catch((error) => {
      cb(error);
    });
  };
  exports.down = (db, cb) => {
    if (typeof down === "function") {
      down(createDatabase(db)).then(() => {
        cb();
      }).catch((error) => {
        cb(error);
      });
    } else {
      cb();
    }
  };
}
function createEdtrIoMigration({
  exports,
  migrateState: migrateState2,
  dryRun: dryRun2,
  migrationName = "migration"
}) {
  createMigration(exports, {
    up: async (db) => {
      const apiCache = new ApiCache();
      const logFileName = import_path7.default.join((0, import_os.tmpdir)(), `${migrationName}.log.json`);
      const logFileStream = (0, import_fs.createWriteStream)(logFileName);
      console.log("Convert entity revisions");
      await changeUuidContents({
        query: `
          SELECT
            entity_revision_field.id as id,
            entity_revision_field.entity_revision_id as uuid,
            entity_revision_field.value as content
          FROM entity_revision_field
          JOIN entity_revision on entity_revision_field.entity_revision_id = entity_revision.id
          JOIN entity on entity.id = entity_revision.repository_id
          JOIN type on type.id = entity.type_id
          WHERE
            ((entity_revision_field.field = "content" and type.name != "video")
            or field = "reasoning" or field = "description")
            and type.name not in ("input-expression-equal-match-challenge",
              "input-number-exact-match-challenge", "input-string-normalized-match-challenge",
              "math-puzzle", "multiple-choice-right-answer", "multiple-choice-wrong-answer",
              "single-choice-right-answer", "single-choice-wrong-answer")
            and entity_revision_field.id > ?
        `,
        migrateState: migrateState2,
        table: "entity_revision_field",
        column: "value",
        apiCache,
        dryRun: dryRun2,
        db,
        logFileStream
      });
      console.log("Convert page revisions");
      await changeUuidContents({
        query: `
          SELECT
            page_revision.id, page_revision.content, page_revision.id as uuid
          FROM page_revision WHERE page_revision.id > ?
        `,
        migrateState: migrateState2,
        table: "page_revision",
        column: "content",
        apiCache,
        dryRun: dryRun2,
        db,
        logFileStream
      });
      console.log("Convert taxonomy terms");
      await changeUuidContents({
        query: `
          SELECT id, description as content, id as uuid
          FROM term_taxonomy WHERE id > ?
        `,
        migrateState: migrateState2,
        table: "term_taxonomy",
        column: "description",
        apiCache,
        dryRun: dryRun2,
        db,
        logFileStream
      }), console.log("Convert users");
      await changeUuidContents({
        query: `
          SELECT id, description as content, id as uuid
          FROM user WHERE id != 191656 and description != "NULL" and id > ?
        `,
        migrateState: migrateState2,
        table: "user",
        column: "description",
        apiCache,
        dryRun: dryRun2,
        db,
        logFileStream
      });
      await apiCache.quit();
    }
  });
}
async function changeUuidContents({
  query,
  db,
  migrateState: migrateState2,
  apiCache,
  dryRun: dryRun2,
  table,
  column,
  logFileStream
}) {
  const querySQL = query + " LIMIT ?";
  let uuids = [];
  do {
    const lastID = uuids.at(-1)?.id ?? 0;
    console.log(`Last ID: ${lastID}`);
    uuids = await db.runSql(querySQL, lastID, 5e3);
    for (const uuid of uuids) {
      let oldState;
      try {
        oldState = JSON.parse(uuid.content);
      } catch (e) {
        continue;
      }
      if (!isPlugin(oldState)) {
        continue;
      }
      const newContent = JSON.stringify(migrateState2(oldState));
      if (newContent !== JSON.stringify(oldState)) {
        if (!dryRun2) {
          await db.runSql(
            `UPDATE ${table} SET ${column} = ? WHERE id = ?`,
            newContent,
            uuid.id
          );
          await apiCache.deleteUuid(uuid.uuid);
        }
        console.log(`Update ${table}.${column} with ID ${uuid.uuid}`);
        logFileStream.write(
          JSON.stringify({
            table,
            column,
            uuid: uuid.uuid,
            tableId: uuid.id,
            oldContent: uuid.content,
            newContent
          })
        );
        logFileStream.write("\n");
      }
    }
  } while (uuids.length > 0);
}

// src/20220517163100-add-image-caption.ts
var addImageCaption = replacePluginState({
  image: ({ state }) => {
    if (typeof state !== "object" || state === null)
      throw new Error("Illegal image state");
    return has_default("caption", state) ? state : {
      ...state,
      caption: { plugin: "text", state: [{ type: "p", children: [{}] }] }
    };
  }
});
createEdtrIoMigration({
  exports: module.exports,
  migrateState: addImageCaption
});

// src/20210923155000-add-first-explanation-to-equation.ts
var addFirstExplanationToEquation = replacePluginState({
  equations: ({ state }) => {
    if (typeof state !== "object" || state === null)
      throw new Error("Illegal equation state");
    return { firstExplanation: { plugin: "text" }, ...state };
  }
});
createEdtrIoMigration({
  exports: module.exports,
  migrateState: addFirstExplanationToEquation
});

// src/20210923231900-add-transformation-target-to-equations.ts
var addTransformationTargetToEquation = replacePluginState({
  equations: ({ state }) => {
    if (typeof state !== "object" || state === null)
      throw new Error("Illegal equation state");
    return { transformationTarget: "equation", ...state };
  }
});
createEdtrIoMigration({
  exports: module.exports,
  migrateState: addTransformationTargetToEquation
});

// src/20220625202000-convert-important-and-blockquote-to-box.ts
var convertImportantAndBlockquoteToBox = replacePlugins({
  important: convertToBox,
  blockquote: convertToBox
});
createEdtrIoMigration({
  exports: module.exports,
  migrateState: convertImportantAndBlockquoteToBox
});
function convertToBox({
  plugin,
  applyChangeToChildren
}) {
  return {
    plugin: "box",
    state: {
      title: {
        plugin: "text",
        state: [{ type: "p", children: [{}] }]
      },
      content: {
        plugin: "rows",
        state: [applyChangeToChildren(plugin.state)]
      },
      type: plugin.plugin === "blockquote" ? "quote" : "blank",
      anchorId: `box${Math.floor(1e4 + Math.random() * 9e4)}`
    }
  };
}

// src/20230526090001-convert-table-to-serlo-table.ts
var import_markdown = __toESM(require_dist(), 1);

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["InEntity"] = 25] = "InEntity";
})(State || (State = {}));
function isWhitespace(c) {
  return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace(c);
}
function isASCIIAlpha(c) {
  return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
var Tokenizer = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityDecoder = new EntityDecoder(xmlMode ? decode_data_xml_default : decode_data_html_default, (cp, consumed) => this.emitCodePoint(cp, consumed));
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  stateText(c) {
    if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes2.Gt || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes2.Amp) {
          this.startEntity();
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) {
    } else if (c === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes2.Gt || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace(c) || c === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  startEntity() {
    this.baseState = this.state;
    this.state = State.InEntity;
    this.entityStart = this.index;
    this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
  }
  stateInEntity() {
    const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
    if (length >= 0) {
      this.state = this.baseState;
      if (length === 0) {
        this.index = this.entityStart;
      }
    } else {
      this.index = this.offset + this.buffer.length - 1;
    }
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InEntity) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      if (this.sectionStart < this.entityStart) {
        this.cbs.onattribdata(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.onattribentity(cp);
    } else {
      if (this.sectionStart < this.entityStart) {
        this.cbs.ontext(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.ontextentity(cp, this.sectionStart);
    }
  }
};

// node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser = class {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.htmlMode = !this.options.xmlMode;
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : this.htmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
    this.foreignContext = [!this.htmlMode];
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a2, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
    this.startIndex = endIndex;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(name) {
    return this.htmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = this.htmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
        const element = this.stack.shift();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.unshift(name);
      if (this.htmlMode) {
        if (foreignContextElements.has(name)) {
          this.foreignContext.unshift(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.unshift(false);
        }
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (this.htmlMode && (foreignContextElements.has(name) || htmlIntegrationElements.has(name))) {
      this.foreignContext.shift();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.indexOf(name);
      if (pos !== -1) {
        for (let index = 0; index <= pos; index++) {
          const element = this.stack.shift();
          (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, index !== pos);
        }
      } else if (this.htmlMode && name === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (this.htmlMode && name === "br") {
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
      (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
      (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.recognizeSelfClosing || this.foreignContext[0]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[0] === name) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name, !isOpenImplied);
      this.stack.shift();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (!this.htmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = 0; index < this.stack.length; index++) {
        this.cbs.onclosetag(this.stack[index], true);
      }
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.foreignContext.length = 0;
    this.foreignContext.unshift(!this.htmlMode);
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/domelementtype/lib/esm/index.js
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children = [], type3 = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type3;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a2, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

// node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type3 = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name, attribs, void 0, type3);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment2(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node = new CDATA2([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node = new ProcessingInstruction(name, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
};

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function getEscaper(regex, map) {
  return function escape2(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// node_modules/domutils/lib/esm/helpers.js
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(void 0, options);
  new Parser(handler, options).end(data);
  return handler.root;
}
function parseDOM(data, options) {
  return parseDocument(data, options).children;
}

// src/20230526090001-convert-table-to-serlo-table.ts
var dryRun = false;
var convertTableToSerloTable = replacePlugins({
  table({ plugin }) {
    if (typeof plugin.state !== "string") {
      throw new Error("plugin state is not a string");
    }
    const serloTable = convertTable(plugin);
    if (!serloTable)
      console.log("could not convert this table!!");
    if (dryRun)
      return { plugin: "table", state: plugin.state + " " };
    return serloTable ?? plugin;
  }
});
createEdtrIoMigration({
  exports: module.exports,
  migrateState: convertTableToSerloTable,
  dryRun
});
function convertTable(legacyState) {
  const html = import_markdown.converter.makeHtml(legacyState.state);
  return convertHTMLtoState(html);
}
function convertHTMLtoState(html) {
  const dom = parseDOM(html);
  const table = dom[0]?.children.filter((child) => child.type === "tag")[0];
  if (!table) {
    console.log("Invalid table, replacing with empty text plugin!");
    return { plugin: "text" };
  }
  if (table.name !== "table") {
    if (table.name === "span" && (table.attribs.class === "math" || table.attribs.class === "mathInline")) {
      const mathContent = table.children[0]?.data?.replace(/%%/g, "").replace("$$", "").replace("$$", "") ?? "";
      return {
        plugin: "text",
        state: [
          {
            type: "p",
            children: [
              {
                type: "math",
                src: mathContent,
                inline: true,
                children: [{ text: mathContent }]
              }
            ]
          }
        ]
      };
    } else {
      console.log("table misused for something else check!!");
      console.log(table.attribs);
      console.log(table.name);
      return void 0;
    }
  }
  const tHeadAndTBody = table.children.filter((child) => child.type === "tag");
  if (tHeadAndTBody.length !== 2) {
    console.log("Unexpected state (no header or body), skipping this table!");
    return void 0;
  }
  const rows = [
    ...tHeadAndTBody[0].children,
    ...tHeadAndTBody[1].children
  ].filter((child) => child.type === "tag");
  const convertedRows = rows.map((row) => {
    const columns = row.children.filter((col) => col.type === "tag").map((col) => ({ content: convertCellContent(col) }));
    return {
      columns
    };
  });
  const hasEmptyHeaderRow = convertedRows[0].columns.every(
    (cell) => !cell.content.hasOwnProperty("state")
  );
  const trimmedRows = hasEmptyHeaderRow ? convertedRows.slice(1) : convertedRows;
  const colLength = trimmedRows.reduce(
    (acc, { columns }) => Math.max(columns.length, acc),
    0
  );
  const finalRows = trimmedRows.map(({ columns }) => {
    if (columns.length === colLength)
      return { columns };
    const oldLength = columns.length;
    columns.length = colLength;
    return {
      columns: columns.fill({ content: { plugin: "text" } }, oldLength)
    };
  });
  return {
    plugin: "serloTable",
    state: {
      tableType: hasEmptyHeaderRow ? "OnlyRowHeader" /* OnlyRowHeader */ : "OnlyColumnHeader" /* OnlyColumnHeader */,
      rows: finalRows
    }
  };
}
function convertCellContent(cell) {
  const cellChildren = cell.children;
  if (cellChildren.length === 0)
    return { plugin: "text" };
  if (cellChildren.length > 1) {
    console.log("unexpected: cell has more than one child, cell will be empty");
    return { plugin: "text" };
  }
  const onlyChild = cellChildren[0];
  if (!["p", "h4", "ul", "ol", "pre"].includes(onlyChild.name)) {
    console.log("unexpected state, cell will be empty");
    console.log(onlyChild.name);
    return { plugin: "text" };
  }
  const filteredChildren = onlyChild.children.filter((child) => {
    const text = child.data?.replace(/\r?\n|\r$/, "");
    return child.type === "text" && (text === "\\n" || text === "*" || text === "#" || text === "") ? false : true;
  });
  if (filteredChildren.length === 0)
    return { plugin: "text" };
  const liElement = filteredChildren.find((child) => child.name === "li");
  if (liElement) {
    const liConverted = filteredChildren[0].children.map(convertContentNode);
    return { plugin: "text", state: [{ type: "p", children: liConverted }] };
  }
  const converted = filteredChildren.map(convertContentNode);
  const convertedImg = converted.find(
    // @ts-expect-error
    (obj) => obj.hasOwnProperty("plugin") && obj.plugin === "image"
  );
  if (convertedImg)
    return convertedImg;
  return { plugin: "text", state: [{ type: "p", children: converted }] };
}
function convertContentNode(node) {
  if (node.type === "text")
    return { text: node.data ?? "" };
  if (node.type === "tag") {
    if (node.name === "br") {
      return { text: " " };
    }
    if (node.name === "strong") {
      if (node.children[0].type !== "text") {
        return convertContentNode(node.children[0]);
      }
      return { text: node.children[0].data ?? "", strong: true };
    }
    if (node.name === "em") {
      if (node.children[0].type !== "text") {
        return convertContentNode(node.children[0]);
      }
      return { text: node.children[0].data ?? "", em: true };
    }
    if (node.name === "a" && node.attribs.href) {
      if (node.children[0].data?.includes("%") || node.children[0].data?.includes("$$")) {
        console.log(
          "content: link with formula that will not be converted! check manually"
        );
      }
      if (node.children[0].type !== "text") {
        console.log(
          "content: link with unexpected content, content will be deleted!"
        );
        return { text: "" };
      }
      return {
        type: "a",
        href: node.attribs.href,
        children: [{ text: node.children[0].data ?? "" }]
      };
    }
    if (node.name === "span" && node.attribs.class === "mathInline") {
      if (node.children.length !== 1 || !node.children[0].hasOwnProperty("children")) {
        console.log(
          "content: mathInline has unexpected state, content will be empty"
        );
        return { text: " " };
      }
      const mathContent = node.children[0].children[0].data?.replace(/%%/g, "") ?? "";
      return {
        type: "math",
        src: mathContent,
        inline: true,
        children: [{ text: mathContent }]
        //???
      };
    }
    if (node.name === "span" && node.attribs.class === "math") {
      if (node.children.length !== 1) {
        console.log("content: math has unexpected state, content will be empty");
        return { text: "" };
      }
      const mathContent = node.children[0].data?.replace(/%%/g, "").replace("$$", "").replace("$$", "") ?? "";
      return {
        type: "math",
        src: mathContent,
        inline: true,
        children: [{ text: mathContent }]
        //???
      };
    }
    if (node.name === "code") {
      if (!node.children || node.children.length !== 1 || node.children[0].type !== "text" || !node.children[0].data) {
        console.log("content: math has unexpected state, content will be empty");
        return { text: "" };
      }
      const text = node.children[0].data.replace(/\r?\n|\r$/, "").trim();
      return {
        text,
        code: true
      };
    }
    if (node.name === "img") {
      if (!node.attribs || !node.attribs.src) {
        console.log("content: img has unexpected state, content will be empty");
        return { text: "" };
      }
      return {
        plugin: "image",
        state: { src: node.attribs.src, alt: node.attribs.alt }
      };
    }
    console.log("content: unsupported tag, content will be empty");
    console.log(node.name);
    return { text: "" };
  }
  console.log("content: unsupported type, content will be empty");
  console.log(node.type);
  return { text: "" };
}

// src/20201101234700-migrate-equations.ts
createMigration(module.exports, {
  up: async (db) => {
    async function processResults(results2) {
      if (results2.length === 0)
        return;
      const [field, ...remainingResults] = results2;
      const state = JSON.parse(field.value);
      const newState = JSON.stringify(migrateState(state));
      if (field.value !== newState) {
        await db.runSql(
          `UPDATE entity_revision_field SET value = ? WHERE id = ?`,
          newState,
          field.id
        );
        console.log("Updated revision", field.revision);
      }
      await processResults(remainingResults);
    }
    const results = await db.runSql(`
      SELECT erf.id, erf.value, er.id as revision
      FROM entity_revision_field erf
        LEFT JOIN entity_revision er on erf.entity_revision_id = er.id
        LEFT JOIN entity e on er.repository_id = e.id
      WHERE erf.field = 'content'
        AND erf.value LIKE '%{"plugin":"equations"%'
    `);
    await processResults(results);
  }
});
function migrateState(document2) {
  switch (document2.plugin) {
    case "equations":
      return migrateEquationsState(
        document2.state
      );
    case "blockquote":
      return {
        ...document2,
        state: migrateState(document2.state)
      };
    case "exercise":
      return {
        ...document2,
        state: {
          ...document2.state,
          content: migrateState(document2.state.content),
          interactive: document2.state.interactive ? migrateState(document2.state.interactive) : void 0
        }
      };
    case "important":
      return {
        ...document2,
        state: migrateState(document2.state)
      };
    case "inputExercise":
      return {
        ...document2,
        state: {
          ...document2.state,
          answers: document2.state.answers.map((answer) => {
            return {
              ...answer,
              feedback: migrateState(answer.feedback)
            };
          })
        }
      };
    case "layout":
      return {
        ...document2,
        state: document2.state.map((row) => {
          return {
            ...row,
            child: migrateState(row.child)
          };
        })
      };
    case "multimedia":
      return {
        ...document2,
        state: {
          ...document2.state,
          explanation: migrateState(document2.state.explanation),
          multimedia: migrateState(document2.state.multimedia)
        }
      };
    case "rows":
      return {
        ...document2,
        state: document2.state.map((row) => {
          return migrateState(row);
        })
      };
    case "scMcExercise":
      return {
        ...document2,
        state: {
          ...document2.state,
          answers: document2.state.answers.map((answer) => {
            return {
              ...answer,
              content: migrateState(answer.content),
              feedback: migrateState(answer.feedback)
            };
          })
        }
      };
    case "spoiler":
      return {
        ...document2,
        state: {
          ...document2.state,
          content: migrateState(document2.state.content)
        }
      };
    case "solution":
      return {
        ...document2,
        state: {
          ...document2.state,
          strategy: migrateState(document2.state.strategy),
          steps: migrateState(document2.state.steps)
        }
      };
    case "anchor":
    case "deprecated":
    case "error":
    case "geogebra":
    case "highlight":
    case "image":
    case "injection":
    case "separator":
    case "table":
    case "text":
    case "video":
      return document2;
    default:
      throw new Error("Unexpected plugin");
  }
}
function migrateEquationsState(state) {
  try {
    return {
      plugin: "equations",
      state: {
        steps: state.steps.map((step) => {
          const { left, sign, right, transform } = step;
          return {
            left: extractSingleFormulaFromText(left),
            sign,
            right: extractSingleFormulaFromText(right),
            ...extractTransformOrExplanationFromText(transform)
          };
        })
      }
    };
  } catch (e) {
    const error = e;
    console.log("Failed to", error.message);
    return {
      plugin: "deprecated",
      state: {
        plugin: "equations",
        state
      }
    };
  }
}
function extractSingleFormulaFromText(textState) {
  const paragraphs = textState.state.filter((paragraph2) => {
    return paragraph2.type === "p" && getCleanChildren(paragraph2.children).length > 0;
  });
  if (paragraphs.length === 0)
    return "";
  if (paragraphs.length !== 1) {
    throw new Error("text has more than one paragraph");
  }
  const paragraph = paragraphs[0];
  if (paragraph.type !== "p") {
    throw new Error("text has block that is not a paragraph");
  }
  const children = getCleanChildren(paragraph.children);
  if (children.length === 0)
    return "";
  return children.map((child) => {
    if (child.type === "math") {
      return children[0].src;
    } else if (child.text) {
      return child.text;
    } else {
      throw new Error("text contains unexpected child");
    }
  }).join("");
}
function extractTransformOrExplanationFromText(textState) {
  if (textState.state.length !== 1)
    return noTransform();
  const paragraph = textState.state[0];
  if (paragraph.type !== "p")
    return noTransform();
  const cleanChildren = getCleanChildren(paragraph.children);
  if (cleanChildren.length === 1 && cleanChildren[0].type === "math") {
    const src = cleanChildren[0].src;
    if (src.startsWith("|") || src.startsWith("\\vert")) {
      return transform(src.replace(/^(\||\\vert)(\\:)*/, "").trim());
    }
    if (src.startsWith("\\left|")) {
      return transform(
        src.replace(/^\\left\|/, "").replace(/\\right\.$/, "").trim()
      );
    }
  }
  return noTransform();
  function noTransform() {
    return {
      transform: "",
      explanation: textState
    };
  }
  function transform(src) {
    return {
      transform: src,
      explanation: {
        plugin: "text"
      }
    };
  }
}
function getCleanChildren(children) {
  return children.filter((child) => {
    return Object.keys(child).length !== 0 && child["text"] !== "" && child["text"] !== " ";
  });
}

// src/20230917105600-upgrade-all-edtr-io-states.ts
createEdtrIoMigration({
  exports: module.exports,
  migrateState: convertEdtrIo,
  migrationName: "2023-09-17-upgrade-all-edtr-io-states"
});
function convertEdtrIo(content) {
  return import_fp_ts.function.pipe(
    content,
    migrateEquations,
    addFirstExplanationToEquation,
    addTransformationTargetToEquation,
    addImageCaption,
    convertImportantAndBlockquoteToBox,
    convertTableToSerloTable,
    removeLayoutPlugins
  );
}
var LegacyEquationsState = t2.type({
  steps: t2.array(
    t2.type({
      left: t2.type({ plugin: t2.literal("text") }),
      right: t2.type({ plugin: t2.literal("text") }),
      transform: t2.type({ plugin: t2.literal("text") }),
      sign: t2.string
    })
  )
});
var migrateEquations = replacePluginState({
  equation: ({ state }) => {
    if (LegacyEquationsState.is(state)) {
      return migrateEquationsState(
        state
      );
    } else {
      return document;
    }
  }
});
var PluginDecoder = t2.type({ plugin: t2.string, state: t2.unknown });
var RowsPluginDecoder = t2.type({
  plugin: t2.literal("rows"),
  state: t2.array(PluginDecoder)
});
var LayoutPluginDecoder = t2.type({
  plugin: t2.literal("layout"),
  state: t2.array(
    t2.type({
      width: t2.number,
      child: t2.unknown
    })
  )
});
var removeLayoutPlugins = transformPlugins({
  layout: (value) => {
    if (LayoutPluginDecoder.is(value)) {
      return value.state.flatMap(({ child }) => {
        if (RowsPluginDecoder.is(child)) {
          return child.state;
        } else if (PluginDecoder.is(child)) {
          return [child];
        } else {
          throw new Error(
            `Illegal value (remove layout plugin): ${JSON.stringify(value)}`
          );
        }
      });
    } else {
      throw new Error(
        `Illegal value (remove layout plugin): ${JSON.stringify(value)}`
      );
    }
  }
});
/*! Bundled license information:

showdown/dist/showdown.js:
  (*! showdown v 1.9.1 - 02-11-2019 *)

@serlo/markdown/dist/markdown.cjs.development.js:
  (**
   * This file is part of Serlo.org.
   *
   * Copyright (c) 2013-2021 Serlo Education e.V.
   *
   * Licensed under the Apache License, Version 2.0 (the "License")
   * you may not use this file except in compliance with the License
   * You may obtain a copy of the License at
   *
   *    http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * @copyright Copyright (c) 2013-2021 Serlo Education e.V.
   * @license   http://www.apache.org/licenses/LICENSE-2.0 Apache License 2.0
   * @link      https://github.com/serlo-org/serlo.org for the canonical source repository
   *)
*/
